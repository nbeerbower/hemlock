// @stdlib/logging - Logging module with levels, filtering, and structured logging
// Provides comprehensive logging facilities for Hemlock applications

// ========== LOG LEVELS ==========
// Log level constants (lower number = more verbose)
export let DEBUG = 0;
export let INFO = 1;
export let WARN = 2;
export let ERROR = 3;

// ========== LOGGER FACTORY ==========

// Logger(config?: object) -> Logger object
// Create a logger with optional configuration
//
// Config options:
//   - output: "stdout" (default) or file path string
//   - level: minimum log level (DEBUG, INFO, WARN, ERROR) - default INFO
//   - format: format string with placeholders - default "{timestamp} [{level}] {message}"
//   - include_timestamp: boolean - default true
//
// Example:
//   let logger = Logger({ output: "app.log", level: WARN });
//   logger.warn("Something went wrong");
export fn Logger(config?: null) {
    // Default configuration
    let output_target = "stdout";
    let min_level = INFO;
    let format_string = "{timestamp} [{level}] {message}";
    let include_timestamp = true;
    let file_handle = null;

    // Parse configuration if provided
    if (config != null && typeof(config) == "object") {
        if (config.output != null) {
            output_target = config.output;
        }
        if (config.level != null) {
            min_level = config.level;
        }
        if (config.format != null) {
            format_string = config.format;
        }
        if (config.include_timestamp != null) {
            include_timestamp = config.include_timestamp;
        }
    }

    // Open file if output is not stdout
    if (output_target != "stdout") {
        try {
            file_handle = open(output_target, "a");  // Append mode
        } catch (e) {
            print("Failed to open log file: " + e);
            output_target = "stdout";  // Fallback to stdout
        }
    }

    // Helper: Convert log level to string
    fn level_to_string(level: i32): string {
        if (level == DEBUG) {
            return "DEBUG";
        }
        if (level == INFO) {
            return "INFO";
        }
        if (level == WARN) {
            return "WARN";
        }
        if (level == ERROR) {
            return "ERROR";
        }
        return "UNKNOWN";
    }

    // Helper: Format timestamp (Unix timestamp to ISO-like format)
    fn format_timestamp(ts: i64): string {
        // For now, just return the Unix timestamp as string
        // A full implementation would convert to ISO 8601 format
        return typeof(ts);
    }

    // Helper: Convert value to string safely
    fn value_to_log_string(val): string {
        let t = typeof(val);
        if (t == "string") {
            return val;
        }
        if (t == "null") {
            return "null";
        }
        if (t == "bool") {
            if (val) {
                return "true";
            }
            return "false";
        }
        if (t == "object") {
            // Try to serialize as JSON
            try {
                return val.serialize();
            } catch (e) {
                return "[object]";
            }
        }
        if (t == "array") {
            try {
                return val.join(", ");
            } catch (e) {
                return "[array]";
            }
        }
        // For numbers, convert using string concatenation with empty string
        if (t == "i32" || t == "i64" || t == "u32" || t == "u64" ||
            t == "i8" || t == "i16" || t == "u8" || t == "u16" ||
            t == "f32" || t == "f64") {
            // Convert number to string using string context
            let str = "";
            if (t == "i32") {
                let num: i32 = val;
                str = str + num;
            } else if (t == "f64") {
                let num: f64 = val;
                str = str + num;
            } else {
                // For other numeric types, use generic approach
                str = str + val;
            }
            return str;
        }
        // For other types, return type name
        return "[" + t + "]";
    }

    // Helper: Format structured data (key-value pairs)
    fn format_structured(data): string {
        if (data == null || typeof(data) != "object") {
            return "";
        }

        // Try to serialize as JSON
        try {
            return " " + data.serialize();
        } catch (e) {
            return " [structured data]";
        }
    }

    // Core logging function
    fn log_message(level: i32, message: string, data?: null) {
        // Filter by log level
        if (level < min_level) {
            return null;
        }

        // Build the log message
        let log_line = format_string;

        // Replace placeholders
        if (include_timestamp) {
            let ts = __now();  // Get current timestamp
            let ts_str = format_timestamp(ts);
            log_line = log_line.replace("{timestamp}", ts_str);
        } else {
            log_line = log_line.replace("{timestamp} ", "");
            log_line = log_line.replace("{timestamp}", "");
        }

        log_line = log_line.replace("{level}", level_to_string(level));
        log_line = log_line.replace("{message}", message);

        // Add structured data if provided
        if (data != null) {
            log_line = log_line + format_structured(data);
        }

        // Output the log
        if (output_target == "stdout") {
            print(log_line);
        } else {
            if (file_handle != null) {
                try {
                    file_handle.write(log_line + "\n");
                } catch (e) {
                    print("Failed to write to log file: " + e);
                    print(log_line);  // Fallback to stdout
                }
            }
        }

        return null;
    }

    // Return the logger object
    return {
        output: output_target,
        level: min_level,
        format: format_string,

        // debug(message, data?) - Log debug message
        debug: fn(message, data?: null) {
            log_message(DEBUG, value_to_log_string(message), data);
            return null;
        },

        // info(message, data?) - Log info message
        info: fn(message, data?: null) {
            log_message(INFO, value_to_log_string(message), data);
            return null;
        },

        // warn(message, data?) - Log warning message
        warn: fn(message, data?: null) {
            log_message(WARN, value_to_log_string(message), data);
            return null;
        },

        // error(message, data?) - Log error message
        error: fn(message, data?: null) {
            log_message(ERROR, value_to_log_string(message), data);
            return null;
        },

        // log(level, message, data?) - Log with explicit level
        log: fn(level: i32, message, data?: null) {
            log_message(level, value_to_log_string(message), data);
            return null;
        },

        // set_level(level) - Change minimum log level
        set_level: fn(level: i32) {
            min_level = level;
            return null;
        },

        // close() - Close file handle if using file output
        close: fn() {
            if (file_handle != null) {
                try {
                    file_handle.close();
                    file_handle = null;
                } catch (e) {
                    // Ignore close errors
                }
            }
            return null;
        },
    };
}

// ========== DEFAULT LOGGER ==========

// Create a default logger instance for convenience
export let default_logger = Logger();

// Export convenience functions that use the default logger
export fn debug(message, data?: null) {
    default_logger.debug(message, data);
    return null;
}

export fn info(message, data?: null) {
    default_logger.info(message, data);
    return null;
}

export fn warn(message, data?: null) {
    default_logger.warn(message, data);
    return null;
}

export fn error(message, data?: null) {
    default_logger.error(message, data);
    return null;
}

export fn log(level: i32, message, data?: null) {
    default_logger.log(level, message, data);
    return null;
}
