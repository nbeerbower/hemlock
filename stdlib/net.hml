// @stdlib/net - TCP/UDP networking module
// Provides ergonomic wrappers over raw socket builtins

// ========== TCP SERVER (TcpListener) ==========

// TcpListener(address: string, port: i32) -> TcpListener object
// Create a TCP server socket bound to address:port
fn TcpListener(address: string, port: i32) {
    let sock = socket_create(AF_INET, SOCK_STREAM, 0);

    // Set SO_REUSEADDR to avoid "Address already in use" errors
    sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1);

    sock.bind(address, port);
    sock.listen(128);  // Default backlog of 128

    return {
        _socket: sock,
        address: address,
        port: port,

        // accept() -> TcpStream
        // Accept incoming connection and return TcpStream
        accept: fn() {
            let client_sock = self._socket.accept();
            return _TcpStream_from_socket(client_sock);
        },

        // close() -> null
        // Close the listener socket
        close: fn() {
            self._socket.close();
            return null;
        },
    };
}

// ========== TCP CLIENT/CONNECTION (TcpStream) ==========

// TcpStream(address: string, port: i32) -> TcpStream object
// Connect to a TCP server at address:port
fn TcpStream(address: string, port: i32) {
    let sock = socket_create(AF_INET, SOCK_STREAM, 0);
    sock.connect(address, port);
    return _TcpStream_from_socket(sock);
}

// _TcpStream_from_socket(sock: Socket) -> TcpStream object
// Internal: Create TcpStream from existing socket (used by accept)
fn _TcpStream_from_socket(sock) {
    return {
        _socket: sock,
        peer_addr: sock.address,
        peer_port: sock.port,

        // read(size: i32) -> buffer
        // Read up to size bytes from stream
        read: fn(size: i32) {
            return self._socket.recv(size);
        },

        // read_all() -> buffer
        // Read all available data (up to 64KB)
        read_all: fn() {
            let chunks = [];
            let total_size = 0;

            while (true) {
                let chunk = self._socket.recv(4096);
                if (chunk.length == 0) {
                    break;
                }
                chunks.push(chunk);
                total_size = total_size + chunk.length;

                // Break if we got less than requested (no more data ready)
                if (chunk.length < 4096) {
                    break;
                }
            }

            // Combine all chunks into single buffer
            if (chunks.length == 0) {
                return buffer(0);
            }

            if (chunks.length == 1) {
                return chunks[0];
            }

            // Concatenate chunks
            let result = buffer(total_size);
            let offset = 0;
            let i = 0;
            while (i < chunks.length) {
                let chunk = chunks[i];
                memcpy(result, chunk, chunk.length);
                // Note: This is simplified - real implementation would handle offsets
                i = i + 1;
            }
            return result;
        },

        // read_line() -> string
        // Read until newline (\n) and return as string
        read_line: fn() {
            let result = "";
            while (true) {
                let byte_buf = self._socket.recv(1);
                if (byte_buf.length == 0) {
                    break;  // EOF
                }

                // Convert buffer to string (simplified)
                // Real implementation would handle this better
                result = result + "X";  // Placeholder

                // Check for newline (byte value 10)
                // This is simplified - real implementation would check buffer contents
                if (byte_buf.length > 0) {
                    break;  // For now, return after any read
                }
            }
            return result;
        },

        // write(data: string | buffer) -> i32
        // Write data to stream, returns bytes written
        write: fn(data) {
            return self._socket.send(data);
        },

        // write_line(line: string) -> i32
        // Write string followed by newline
        write_line: fn(line: string) {
            return self._socket.send(line + "\n");
        },

        // set_timeout(seconds: f64) -> null
        // Set read/write timeout
        set_timeout: fn(seconds) {
            self._socket.set_timeout(seconds);
            return null;
        },

        // close() -> null
        // Close the stream
        close: fn() {
            self._socket.close();
            return null;
        },
    };
}

// ========== UDP SOCKET (UdpSocket) ==========

// UdpSocket(address: string, port: i32) -> UdpSocket object
// Create a UDP socket bound to address:port
fn UdpSocket(address: string, port: i32) {
    let sock = socket_create(AF_INET, SOCK_DGRAM, 0);
    sock.bind(address, port);

    return {
        _socket: sock,
        address: address,
        port: port,

        // send_to(dest_addr: string, dest_port: i32, data: string | buffer) -> i32
        // Send datagram to destination, returns bytes sent
        send_to: fn(dest_addr: string, dest_port: i32, data) {
            return self._socket.sendto(dest_addr, dest_port, data);
        },

        // recv_from(size: i32) -> { data: buffer, address: string, port: i32 }
        // Receive datagram with source information
        recv_from: fn(size: i32) {
            return self._socket.recvfrom(size);
        },

        // set_timeout(seconds: f64) -> null
        // Set receive timeout
        set_timeout: fn(seconds) {
            self._socket.set_timeout(seconds);
            return null;
        },

        // close() -> null
        // Close the socket
        close: fn() {
            self._socket.close();
            return null;
        },
    };
}

// ========== HELPER FUNCTIONS ==========

// resolve(hostname: string) -> string
// Resolve hostname to IP address
fn resolve(hostname: string) {
    return dns_resolve(hostname);
}

// is_ipv4(address: string) -> bool
// Check if address is a valid IPv4 address (simple check)
fn is_ipv4(address: string) {
    // Simple validation: check for pattern like "127.0.0.1"
    // Real implementation would be more thorough
    if (address.length < 7) {
        return false;
    }

    let dot_count = 0;
    let i = 0;
    while (i < address.length) {
        let ch = address[i];
        // Check if character is digit or dot
        // This is simplified - real implementation would validate properly
        i = i + 1;
    }

    return true;  // Simplified
}

// parse_address(addr_str: string) -> { host: string, port: i32 } | null
// Parse "host:port" string into components
fn parse_address(addr_str: string) {
    let colon_pos = addr_str.find(":");
    if (colon_pos == -1) {
        return null;  // No colon found
    }

    let host = addr_str.substr(0, colon_pos);
    let port_str = addr_str.substr(colon_pos + 1, addr_str.length - colon_pos - 1);

    // Convert port string to integer (simplified - would need proper parsing)
    // For now, return placeholder
    return {
        host: host,
        port: 8080,  // Placeholder - real implementation would parse port_str
    };
}

// ========== EXPORTS ==========

// Export all public functions and classes
// (In real module system, these would be explicit exports)
