// Test: UdpSocket basic functionality
// Tests UDP datagram sending and receiving

import { UdpSocket } from "@stdlib/net";

async fn udp_server(port: i32) {
    let sock = UdpSocket("127.0.0.1", port);
    sock.set_timeout(5.0);  // 5 second timeout
    defer sock.close();

    print("UDP server bound to 127.0.0.1:" + typeof(port));

    // Receive datagram
    let packet = sock.recv_from(1024);
    print("Server received " + typeof(packet.data.length) + " bytes from " + packet.address + ":" + typeof(packet.port));

    // Small delay before echoing to ensure client is ready
    __sleep(0.2);

    // Echo back to sender
    try {
        let sent = sock.send_to(packet.address, packet.port, packet.data);
        print("Server sent " + typeof(sent) + " bytes");
    } catch (e) {
        print("Server send error: " + e);
    }

    return null;
}

async fn udp_client(port: i32) {
    // Give server time to start and bind
    __sleep(0.5);

    let sock = UdpSocket("0.0.0.0", 0);  // Bind to any port
    sock.set_timeout(5.0);  // 5 second timeout
    defer sock.close();

    print("UDP client ready");

    // Send datagram
    let message = "Hello UDP!";
    let sent = sock.send_to("127.0.0.1", port, message);
    print("Client sent " + typeof(sent) + " bytes");

    // Receive echo
    try {
        let packet = sock.recv_from(1024);
        print("Client received " + typeof(packet.data.length) + " bytes");
    } catch (e) {
        print("Client recv error: " + e);
    }

    return null;
}

let test_port = 29999;

// Spawn server and client
let server_task = spawn(udp_server, test_port);
let client_task = spawn(udp_client, test_port);

// Wait for completion
join(server_task);
join(client_task);

print("UdpSocket test passed!");
