<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hemlock Language Manual</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --sage: #9CAF88;
            --pine: #2F4F4F;
            --dark-pine: #1a2f2f;
            --light-sage: #E8F4E1;
            --cream: #FAF9F6;
            --text: #2C3E2C;
            --text-light: #5A6F5A;
            --border: #D4E4CB;
            --code-bg: #F5F9F3;
            --accent: #6B8E6B;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', sans-serif;
            line-height: 1.7;
            color: var(--text);
            background: var(--cream);
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 70px;
            background: var(--pine);
            color: white;
            display: flex;
            align-items: center;
            padding: 0 2rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        .header-logo {
            height: 45px;
            margin-right: 1rem;
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .header .tagline {
            margin-left: auto;
            font-size: 0.9rem;
            font-style: italic;
            color: var(--light-sage);
            display: none;
        }

        @media (min-width: 768px) {
            .header .tagline {
                display: block;
            }
        }

        /* Layout */
        .container {
            display: flex;
            margin-top: 70px;
            min-height: calc(100vh - 70px);
        }

        /* Sidebar */
        .sidebar {
            position: fixed;
            left: 0;
            top: 70px;
            width: 280px;
            height: calc(100vh - 70px);
            background: var(--light-sage);
            border-right: 2px solid var(--border);
            overflow-y: auto;
            padding: 2rem 0;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            z-index: 900;
        }

        .sidebar.open {
            transform: translateX(0);
        }

        @media (min-width: 1024px) {
            .sidebar {
                transform: translateX(0);
            }
        }

        .nav-section {
            margin-bottom: 1.5rem;
        }

        .nav-section-title {
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--pine);
            padding: 0 1.5rem;
            margin-bottom: 0.5rem;
        }

        .nav-link {
            display: block;
            padding: 0.5rem 1.5rem;
            color: var(--text);
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.2s;
            border-left: 3px solid transparent;
            cursor: pointer;
        }

        .nav-link:hover {
            background: rgba(47, 79, 79, 0.05);
            border-left-color: var(--sage);
        }

        .nav-link.active {
            background: rgba(47, 79, 79, 0.1);
            border-left-color: var(--pine);
            font-weight: 600;
            color: var(--pine);
        }

        /* Mobile Menu Toggle */
        .menu-toggle {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 56px;
            height: 56px;
            background: var(--pine);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @media (min-width: 1024px) {
            .menu-toggle {
                display: none;
            }
        }

        /* Main Content */
        .main-content {
            flex: 1;
            margin-left: 0;
            padding: 3rem 2rem;
            max-width: 900px;
        }

        @media (min-width: 1024px) {
            .main-content {
                margin-left: 280px;
            }
        }

        /* Typography */
        .content h1 {
            font-size: 2.5rem;
            color: var(--pine);
            margin: 2rem 0 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid var(--sage);
        }

        .content h2 {
            font-size: 2rem;
            color: var(--pine);
            margin: 3rem 0 1rem;
            padding-top: 1rem;
        }

        .content h3 {
            font-size: 1.5rem;
            color: var(--accent);
            margin: 2rem 0 1rem;
        }

        .content h4 {
            font-size: 1.2rem;
            color: var(--accent);
            margin: 1.5rem 0 0.8rem;
        }

        .content p {
            margin: 1rem 0;
            color: var(--text);
        }

        .content ul, .content ol {
            margin: 1rem 0 1rem 2rem;
        }

        .content li {
            margin: 0.5rem 0;
        }

        .content blockquote {
            border-left: 4px solid var(--sage);
            background: var(--light-sage);
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            font-style: italic;
            color: var(--text-light);
        }

        .content hr {
            border: none;
            border-top: 2px solid var(--border);
            margin: 2rem 0;
        }

        /* Code Blocks */
        .content code {
            background: var(--code-bg);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            color: var(--pine);
        }

        .content pre {
            background: var(--code-bg);
            border: 1px solid var(--border);
            border-left: 4px solid var(--pine);
            border-radius: 4px;
            padding: 1.2rem;
            overflow-x: auto;
            margin: 1.5rem 0;
        }

        .content pre code {
            background: none;
            padding: 0;
            border-radius: 0;
            font-size: 0.85rem;
            line-height: 1.6;
        }

        /* Tables */
        .content table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
        }

        .content th,
        .content td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .content th {
            background: var(--light-sage);
            color: var(--pine);
            font-weight: 600;
        }

        /* Links */
        .content a {
            color: var(--accent);
            text-decoration: none;
            border-bottom: 1px solid transparent;
            transition: border-color 0.2s;
        }

        .content a:hover {
            border-bottom-color: var(--accent);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--cream);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--sage);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }

        /* Section anchors */
        .section-anchor {
            scroll-margin-top: 90px;
        }

        /* Mobile adjustments */
        @media (max-width: 768px) {
            .main-content {
                padding: 2rem 1rem;
            }

            .content h1 {
                font-size: 2rem;
            }

            .content h2 {
                font-size: 1.6rem;
            }

            .content h3 {
                font-size: 1.3rem;
            }
        }

        /* Page switching */
        .page {
            display: none;
        }

        .page.active {
            display: block;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA/4AAAEWCAYAAADfFEwLAAAALHRFWHRDcmVhdGlvbiBUaW1lAE1vbiAxMyBPY3QgMjAyNSAxMDo0NjoyOSAtMDUwMDkKRCAAAAAHdElNRQfpCg0VFSBTc4fRAAAACXBIWXMAAB7BAAAewQHDaVRTAAAABGdBTUEAALGPC/xhBQACWDJJREFUeNrsvQeU5NZ5JvoDqBy6qnMOM50ncEiKwxFFiaRE0xIpK5O0ktder99697x97+07Z3fPezo6x/I+rbO9luRsSbZkeW1RsmRJliVRkUGkGGc4sbunc86pcgDw7r1VqL6FAlCoZndPT8//kRhUowDcCxRw7/3u///fD4BAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIxL5AuNEVQCAQCERl+MlPflJR2/3AAw+oN7rOCAQCgUAgEIgbByT+CMQugeQLcRAweM52224XPX/4PCIQCAQCgUDcOkDij0BUCB0Rs/MOIeFCVASLZ6zSZ49C1a2LPuPziEAgEAgEAnH0gcQfgbABEyJWjoQZES22RrKF0KPMM2a2BpO/zZ491WAbAz6TCAQCgUAgEEcXSPwRiDLgCBm/NvqshxnhQrKFKMCA8Js9b4LFPkbQP3OqybbCvvg8IhAIBAKBQBxNIPFHIExgQfj1C+g+mxEuJFuIAkyeL21tZzE6lsLO82f6XOLziEAgEAgEAnH0gMQfgTCAjpQZLSKYkzEKjUgpJp+RbN2iqGBCSf+cGT1z/Hl4GD1nCuw8g/o1Po8IBAKBQCAQRxiOG12BmwXprCq4HAIOhg8Au7nXe/X7mJAyPfniF/57HjzR0hZ+O/tcW1cvrq2uKIC4JVDBhJJo8Vn/zFkRf57g6xc5fyz/fLJjaT2R/CMQCAQCgUAcHaDF3yaQ+B9u7MXvY0HK9GRfMtgmcqfiSZfMrbXPhYUQf9CI/2EjWvjM7x0srPx6cm+06J83/WQUf17ezZ8n/UbPof6Z1HsAHLpnEoFAIBAIxI1BpWmseeB44nAAib9NHAYStMs60N/4UL5sh+GeatCT/kAgKEajEZ6QSdyaLg4wJmQUPNmiS1a31k8AHEqidZh+n5sZFUwoGT1nksF2K08TCr1rf7lnkX8mkfwjEAgEAoEwIvrl/uaBKYQPIdDV3yb2mgARUiWSc1bk4r3LOhzaF+ygSOXHPv4b4m998jdN77UBMeNJP0/AHLpF28YTf40w8URLzK/1UMFYlO2wkO5DO2l0M8DAym8WMiIZLA7dmp8EEKE03l+DPqafJ/bZ/Dn4Z1LfaStg8kwiEAgEAoE4+rCZXlj/mYc2vi0ZQ5BzszVOANwYoMXfJvY67vx73/+x461vfUCu5Jy7mSw4zNgtuaXH0bXdY7Vy9OVZWWL9fr8jFovRzzzhd3JrJ/e3Rsg00N8om18ytAq6tfadHE8kwef10G2MrGkNodW9OSSTArbu+Y2ux42CDSs/b8HnSb7RYuVhos8mwS+8Sz//POqXwvMIxt4o2EEjEAgEAnGEYYPsW2Ui4qEarDGt9SEBEv/XiZuV4JjV+2a9nkpQJt5ab4Xlyb5LEAS3qqr0bxfskH9tXwqNcGkkKwU5wp/iPvOESyNmhYbxRjWCdn97fgJqv5+Xm/F5NPIggVLSryf8ZpNK+gkAo9ASDUYK/ry1nyf7aW7hyb82AVAUhoIdMwKBQCAQRw8WhN8sbXW5zEJGJN8wgxCgceHAgcR/H3EzkpajDD3hn52bl9paWzR3JI1I8W7VGgFzcYubWzTyzxN/ZTgy3XJ9e6YHBCnxSPu5J0VZiJDtSW7hyb8+vrosycLn6vAi/4zpXfv1E0o8mXfqFheYk3+e+Jdz8dcTf43c84Q/pftbmxwwivnHjhmBQCAQiCMCA8Jv5alotE1/nAb9eKRcCmEk/wcIjPHfRyA5M8dBkleTxk0gpJ/+zZMzfSw/T/g9kCP7Hu4zXTRyJqYg6/3GxNNvn04sP+KWXA4VFPXzw6u3/1rPL/wPKFVX5z9rdcLn5SYGR/r1naNG2DXyrj0zGsl3GSxm4STseXW73Z76hsbuQLCqw+P2tDqcjnpJclSLouAXBNGbL1tWFCUiy9m5ZDJ5eWVp6YeLi/OjUBoaYKbqry34bCIQCAQCcURg4JnIfzbSI9J/rlRgWFuMUgizYzCN8MEAif/rRJlY7EMbk3+jrcY3gPTbSaPGu11rhMzDLV7dWrP6Oy6sXx/8yeL5x0ASa5wOJ6H8Kjm5IKynIg+CJPwFyOoKlKqp0/L4xtAWwcIJpcMFk3h+Myu/mRcJ703CW/4L4n5VoXBtc3PLXYTs30aI/zHY8TIxgySKYlgUXWGn03UyGKx6vKWt/Zmx0eE/3trcXALjjlnO1xknpBAIBAKBOEKwGBPbTS+8G4FhvdCwdox+AgDJ/wEAXf1fJ240gb6V6l1Jnc2s/FA+5tqI9Hvzi49bM+KfgmzgX6affcdUdPmsSGiWyyFBfVUVRBNJiJAlnc2o7+p48//ZH2y7TPaPkiWeXzSXf83F2ra7/14LTe7idzi0E1oHjTKkX+9BwhN+t27hJ5IKpF8QBGd7R9eZuvr6+zweby/sQZutKMryxNj1/3tpaXEcdsJP9BoUWrw/xvojEIhDCSQJCIR9WIgOG5F9fWphu2mFjcINsyZro7TWOM7YZ6DF/3XiMJDnXZK6m86StwvSbyXeZ0X6eTKmEX26+LnP3tHI3PEfLLz8zpSaqRcEEQbaWqC7uQG8bhe8MDTKiL8kSjAbXQwT4k/PpxF9I6E2zcJ66C3+SPpzsCD9vGu/kZVfHzbCh46wfURRdHV2HT9bX9/wkMPprN/LepNzN3Qd7/md7cj2rybi8Wy+jlqqP6uZfAQCgThQGOQR1yDovi/pF5FAIBC7HhPrRYj1i5nQsD6VMJ9RiE9tLXCfi4T+cEJvf4HEXwc+VZz+M79N264/lt/G76s/D7dPifXUqlz9OfRllKsnd6xqVT+z78zOWe54/XH57wVeHb6S+250r+nfY+OT4sz0pBaXLNTW1UuE3EA8HhNcLpeUTqdZYyc5HA5QVQfZUVJkmbpEMyuroiiUoHlkWfBKkuoRBIGRfVVVNeLvp9uenHvxLZc3J+4VRUmibv09LU3wxsEeSGeyrOVyOnKvFtlXUAS1BnSWXMg3nKQekpzNym6PR0wlkyqpr1BHFnI9Spl7p90HTWBFtfitwWqb/rkxe+6Mni+j59Ds/GbPg/55Nnu24BDBRLnfKCOEfjKJJ/xeMCD+zS2t/a1tHe8hz2sTVEa8yWOqZrLZzHQ2k11WyZ9Op7PR6XSVhAVIktTe33/iVy+cf/nTUNqRGyn2Hqr7j0Agji5MVMb1n/UomQDQ8oVTIJFA3IqwkVrYSIeIFxR2GmwzGjNQ6F38+WxCdP80lE4SAHeM6SQeYu+A1hybuBld429W7NaV/blnn9L+tMqdrne/NnLBpoSfkn3N2k8Jf4Cut7Kxhq9PPf3ujUy0QxREUGQFbu/ugtt7OkGWc1ydEC54cWQMRueWWKz/uYaBv35Tzanvka+284vm8p+QJEdalrN6d3/lTW++/4aT3T0ODzgy748N0s+LQ2qkXyP3WthICfH3en3VvX0D7wkEg2egsrZZSaWSl9fX1n44NztzIZ1OpbjvhKqqULjrePf7AoHgQ/x5yfMdv3Tx/PuikcgqlM86wTpmHDwjEIj9goFlkv9sljqMh2q1xvYLcSvBhv4QP2YxSi1stObJv1GGIb213yqTkBZWiJmEDhBo8UccOlRKEGnjlif9dqywRmnUikh/fqFk3ws7pD8wF19p/5e55z6QUrJVjPQrMtwz2Ad9HS3kswqCKLAmi3B99ncOZLskNkKxtb9g8Sek3zAnKrmeG97g7SVRv0VIPz9DrhF+I60IfmGkv7Wt43Rbe8cHJEkKVFAdNZFIvDQ3M/3E8vLiJOx0mnz9hO3trbWLF179XP/Aicnauvr/Lb+deqN429u77r929dLXoTReT7+guj8CgdgXWLgiW33WQ583vKTN0jwAkFAgjjpMxir6DFb6MTFvsODHx/yYWTtGOw//ThpZ+x3c/nrPALMFxxr7CCT+tyiOggW2jICfUQNnlkatxAWbd+0HSvqT611fm3r6vYrI/gaVEPvbj3dBf3vLDsnPryRRgHgyZ3TNZjNKl7vpKuw0nuVcpY5kg3fEnjcrET+9OCRv5ecFIhnpJ0TfTwj5O8PVNfeAfSu/ms1kpufnZz8/OzNNRSN5IT4VSp9/Vs/hoatP3nnX3ac9Hu892nX4/P67yPobYE76EQgEYl9QRmHcagFufyPCb7aw/TCGGHGUwaUWprASszYzgvGhqfxEgKHF3+lyuWtr69oCgWCz2+2pczgdQbI9m0mn59fWVn+2tLhglUZYn+rvSI6BDxOQ+NvEzUpajgLhMoJ+wBAKhcWtrU3tb6sUffp4a72QH13zYn7+qJJs/ObMM++VBdWvFXqysw3u6OkCWWFp+0Clt7hA/CXYiMboVgi6/cvN3toNGm4NxjnZD62Q2lF9dnaDCkg/P5nEP08lWSEI6a4fGDz1YY/H02G3HqqqZslz/jVC4r8qZ7MJ2CH9dNE6VKO6sWduaXHxG51dxzTiDw6How+sB9YasDNGIBB7ApuEXzRZG7n861OI8cSi4DrM74/kH3EUwZF+KyOYWWph3hCmnwAojF8FQXA0NDR21dTV3+b3+/ucTlc72VaaXpiMoMPVNR9pbW1/eujalU/F47E1KE3tJ8FOGmHe4s88dPAd3Xsg8d9HHGbidFjrVQ5mVn5ChuzEWxtZ93nCz1tl2ULIfui7cy+8MyVnqKgfJV7Q29IId/V1E9K/E9PPO1grqgKxZAockgQdnsYxsskpO4WwqEAcZLXI1R/MLRp7ms7vRuNmqy+PCkm/9nzpJ5EK2SDoUltX39Xd0/cRQrxDduuRzWbnp6cmPr24MD8EO7FyGunX4vBBVzcn7HSm0vzc7HBHZ1eUPMsspEAUxSbdtZl9RrVdBALxumEjpZiZ2riRVxKFnvSbWRIxZzjiSMOA9JsZwYzGxEZLEemvqgo1tLS1v5Gsz5KxSxjsGasEj9d7/8nTZ+pfO//Kf02nU7yxgtZDI//8u4rYRyDx30ccBrJzGOqwVyiTksQu6TeLtda7YjOi9tPli+fmYisNGunvqK+Fe070MXK/g2Kevh6JsUB/uv+avNX9qWtPfCyWSnqqXL7r/+nEo/+FbC+nog6EGNLt8o2830fp2dktbJB+vScJP5nkM1g8La3tpwn5foyQbrfNaqiJePz5a1cv/0UymdiAnAAfJf6aMI7ezZ9PJaiBXYeqKiqdQHA6nX1soyC4fD6/Nx6PJfn9DD4jEAjErrGL/ttobUX89bnD+YVHEfm/0fcFgdgLWJB+Myu/UaYhXoi4YO2vq6vvbG3reNAfCJwCXYYguyBjjhP9gyc+cum183+Vr4Om9G/0XqOH4T5CfP2nOBqgVlSzlGPa95We80v/oO7qBTFK0celbTPaX/rYx1WRru3W93Vda3aHEGj7Wp7PgEBYXY8RaJq+9o4uU2VSp9PliMcTBfVRSZKMLPx6lf4gIT41/zLz3Du/OPH9//cL49/5D0vJjU6yPcQWQQgPbc30Qp701wT9cP9tg0y8rxjFGxZWN0BySJRUwUY62qQKos/v8YlxJd2j5sTbzKwYoK3XVldKUyLu/G14r62e4b3anv9OSn+89Pejv6nd94R/bso9i7t59/YCFZB+/aQSrw9RyAhBt3cdO/6mzq5jH6qA9Mvra6v/6/yrL/0hIf1UfT8GuYwQ2kLd/TU1/hTseALwkwJFGSPIsxzlCyAdMk4AIxCIfYNNrymjcCn9ZKrZhCqvnaK3Vuq97IpIhs6LEIG46WCD9JcbqwTyS5D7HAiFqzvP3PGGf9c3cOI/E9J/BnZJ+jUEAsH3kCUMpTpXRuNgfC/3CTjgy6OcdXM31s/HHwP1ox96/XXJ/21Z/m99UlB+65Ovr762j3Xs1EXb1+oYl3HdbdePNmoz05O8aFkJ+c9k0pLP5y00JrIs8+5MhqSMujt/fvRff2UzHb2LBi2phKh/derHTf+m5+Eng5IXLm+Nd8cyCR8haawelPSXbYtILTcTcRb3z4IAVDppoIAokaoIqhiXE34fOC1Jf36tcukJ8/e9cI8N753lb1Dh81D2fSDPm8Exil2Sbue52U299wplBqr6QSo/OOUHon7us6e3b+DB+obGt4HNDk1RlPjC/OynpyYnXoBSgs+ngNTc/LV68sr+Wr21GLoSZAluxD1GIBBHGyZWfjMLvz6tGL+YCeLybv6akri2ZKCY5OtRyIKCLv+ImxVlSL/RWMVoMq0otbDD4fT39PY9VF1T+2YyNHbuVV3Jufxt7R1vHrp25Z/BntYVWv73AUj89xGUCB1QURWXc6PduO2WX0EeUv1gQS/kx1sKmAX2BwuvPLSVjt1FiL2g5puXDKjBf5392bkPdr1taHhr5jgl/bSipzs7IOj1Glj7NdBIf4Ep+m9FY7m4f7J4HA6oDoRgZTsCqqyqHsmdgqwiQfEAaE9mN61i/82+2+vn4EY/V3uBXcT0661Rfm7tpZ3dwODJR0gneo/dOsiyvDoxPvp7y0uLI5Cz7Ce5hbfo83GrAuzMyNPPMhjEulL3fq4oJZlM0HPqla8BsMNFIBC7hEUsf7m+2yx3OD8BwPeZvHu/Rvh5N2J9/8oLiPHhAgjETYUKSD/v1q8XHS5KLdzQ2NTb2XX8UafTWVdhdVQqPpxJpxeyshx1Ohxhp8vVDLqxrc/vv4OsvgXmpB8t/fsMJP5HAHtNtg6heFwlgwZ9ahKemBVcr5NKpuHSxvjPC6IgUDLfGA7C0sY2I+xT0YWWqJpaX0ysVTFCr6hw8lgbc/enbv+gGk1C5toqSRRhMxZnX7+htxt6WhvhJxeugKLKEHD5FiVZTanmjd3ravQO6jcj5dxQ7YH9xOtw79eeryJLvyiK/sGTp98XCoXvsFuHTCYzMzJ09be3tjZnIWfp5639aSi29utj+7XPvFhOUUorUqcqrSxVUbZlAigl/IbeJWgVQyAQ5WBjwt5IYVwfg+zULeWIv0b6tTaS96ajwHzhiCMDA6HrSvWtikJkyLjA29M38FBtbd39hgr95lBTqeTE2urKs/Nzs1fS6XRK297Reex0W3vHvwUuRMDpcB4n5xdVVbUyfmGc/z4Cif8+4qAI9F6X83rOZRUvVylpsGjYjGY09QMGvVsTb+0PPL1w4W7C4X3sep0S3N3fA09fGoLteIJcv1t8eXWoI53NgCBJcLy5gYoG5GqhkX4q3icIXEuVU/ZPZzLQXlcDZ8n5XA4HXJ2ahS1yTqoFeLyufVFRFBpVwF+LEem3bPQqteq/3t9Uj499/DfE3/rkbxp6mRzCSSPbeB2Wfr1rP1tLkhQ4ceq2x4PBqhN260D6zJGrVy79TjwWW4Ed0k8Xffw+T/p5sg9gQvhhh/gXZvIVVVk22Y9H2VAjBAKBoNDlEC/noceH5BmlFitJJQY7lvxcAQLrb2RCJDTSr+3LE3+9+B+mDkPctNCNVfjQGf7dMkstXKKL4fF6awYGT37Q5/P3VFANlZD8aUL2vz4/NzPMbS/UbXpq4tWamtozPr//rPalKEn1DofTkcmkzca+JdeK7+XeAon/EQAhWhUfs5cEzYTsG73Ahc9UqK/7eJedEAWzfKRWeUiNYpl4wbXAUnr9hFbFEx2tEPL74C2n++Fbz78KgijAxbWxMHXzVxSVfb+D/C0ThJJqZhWZufqf7e9mpJ9ifn0dEuk0O2ygqTsgZNlxou56LBu+/fztdlPOJz7xCYEQ//0u/kCxR6S/YOmnafpOnj7zi35/oM9mFdRUMnn58qXXfi+VSlLlfkr2eRd/TcWfDmy1uH7exZ+vt6kWRCgcDpGBsk/7W5blaSjNfw2AZB+BQFQAG679RkJ++v7brVvz5L+QQ7y+obGzpqbuhNfn7SQkolYUBRfpqxOETExtbW4+MzU5/pySS7drleJPAbQsIm4ymJB+3oNG75VoJYrpDVfXdPT2DXzU6XTW2K2DqqrptbXVfx4dGf6+osjU00Y1qBObnIvFokM88aehj06nw5kn/sAdZ3sMjHh9QFV/Dpp6vqZOrv1NLZxGomWcMrmo27dIYd/smLwSPztWK4Mvx0DdX+LrxpVtdU0iVdU3KEOwPIavF1mM6kMbILowEr8VcZB1Uex6KBQWG5uaebe8AsmNx2PCwuKyRBeq2L+6tuHgr80gdokd7/F6C+I/GUfWnc1mPYIgkkXg3a0DuqVIqZS6Oq+noo1AOK0iK9DZWMfE+Kr9ATjX38Nc+xXyH50ACPu9UBcKFq5Zf9O0Oy+TQYZIPQAEkboyse2b8SjzIKDnPt7YoS4tL70COuuHmFMOJPdDEglZFF0uF7vX5L6J2j02/I3yVeGf2TK/aZGKvp1sDJT065/9j+WehbKDpNwxauG5yx9n+rzly+Gfb9N3aB9h5pJqJ6a/YO13OJ2hU7fd/uFKSH8ikXj14mvnf4eQ/nXIEX6q3s+7+WsWfy1+lXf111z19WS95HGtrq7t5DdkMpkJMPcQACgNAUAgEIgiWLj2m6n2W7WjfL9d6LsJeWjuHzjx3rPn7vnvPb39/62mtvZdXq/vNkJYWiXJUU/WHT6f/y3NLa0fu/Ouu/9HVVWoEUrV/S1T6aLCP+Iwo0wIDT9WMcpmpX/H/I2NzYPknfq1Skg/GTPMjY4M/X8jQ1e/RUg/zRBklGGoEJJIsK07heB0uWnd+MkCxAECb/g+Yq8ts3t5vtd7LhO1XqO1HmqZNeiO189omimU8qqkRkthcJFSs42fuvrEB90Ot+B2OODR+86B5rQvSgL8y89ehfVIjJV6pqsDTh/voHME+QrSPVWaEy33F031ByxWmn3OefHntABeGhqFazPz4JAkqPOHoh9oe+CTLlWaJztskmWLLLRB1AgeL9omBwJBNRqNMEJ31N2cbnR4gIlATrnBqj5lH/vbSUn/6ds/4vX5jtksXo3H4y9cvnj+U/kOUutE9Qr+PNnnY/K1Ouvj+vh3Q7OaOU6dPvN4VSj861rZKyvL//n68LWnYGdiIQk7ngX68pSj/iwiEIjKYIOMmFn53VCaS1y/zUna0upjx7ofDIXD9wiC7TSolKCMXLzwyn9JpVLaZCrfrurb1MLEJ7ZxiMMK3VjFTH9Ir9pvNFbxtbS23dbReewxURRdNosnY5XYS0NXL/91MpmkYxVeYFg/Dil4IBzv7rm7qbn1P/EnunLptfdsbW0uwI5nIx/KmIVi4WJ8J/cY6Op/E+GwxE4bdPT8ZyuXHSOyXyKyU1tXL9A89mA9iNAGD3zj5o15lftfmr9yNp1ITt7XdGbII7oU0AmarGcidRJh+FTIz+d2MWIuyzmvaUVW4U2DffDNF16l+dTgWFMDCEVifmqhwqLm7q+qoKX80y57aWMLplfW2ESA3+lRu72tPyKkPw2l8Y6GIn+E9B9URogbjkNK+vWxckaz50Wp+3ZF+mOxZy9dPP+nsixrpJ+38muz5pqVnyfhhdhUKH7PLAUj3R5PP1/+yvLSVSh2feVd/k1F/hAIBMIiRKqctV9P9j2gI/6SJHmPd/feT8YDD1LhsUrrRtrjvt6+wUcvX7rwN1CaFcCo78U2DnFoUYb0G71fRqSfEf/WtvYzlPTTsBmbxSubGxvfuHb10ldUVS0yUkGxuDA9n5Jf5zWFJL3npprJZFJQOr7A9++AgMTfJnZjlTwsRH0v62YRx2ek0GlE/M2WwveE9AOUxsFri9EggjVwiiBU/f3Fb783Jid7yNXdd2VzInpv423fv7t2YAI48i8Jol8j7T5PqQGhOuiHhlAAtuJJ9jlDRc+5qQnq1i9xRJ+q/QtczD/9/srkNMRTaTY5EHIFZu+uGbgMxQ21CMUDENN8wyhusj8oQ/r5Z6yctZ+691edPH2mItIfjUZ+cvnihb9QFCUC5S39RTPg3HmsBDBLXFmdTtdt2s6yLI9tbqxvQGkcLHbCCATCEhYCY2biu0baO/qFuebXNzR205Rirlw6sF0jEAz+gsfjeSKZTKagjJs/AnFYYRb6CvZCEYvCEZtb2k4T0v+oXdJPRTOXlxc/N3Z95EdQrDekecsAVxfeYMXeK8nh8OrOl8xms/R4KzFhxD4CiT/CNixc+vSEw4z868m+lYURwNyCYOh6/YO5Fx8kpL9bFETmkU8ODj6zfPF9i/HVS+9uf/Nr+X09QYdXZWRdzKXfU1VdO6MKhPiHoDEUhkx2J3Mdy+ZH1ik5Cz7OO4pa+wsXSc55eWwaFja28vp/gnxP3cmXodiKbEX69Qs2gvsAGxkjrIT8ilT8HQ5H1alTZz7s8/ntk/5I5IeXLp7/S/Ls0VAPo3h+I3d7M9Kvn3QzJP8trW3HyLNaiOVLp1MvwI5GgGUmgBv9eyEQiMMDnXK/kaq4XmSMb0v1IXgF0k+t/D19Az9fU1N7fwXWSFPQ9o4QndsmxkefBmvSj/0t4lDCxKvGyCtR84A1MlCwMUtDY1NfZxcj/U47ZauqEp+dmfnMzPTki1CqNcSHHGr1AChuDwSnwxkoPqe6IcslxN90rIFGr70HEv99xI2OXd7LutnIy2tEZkXuGCPSb+ZiDLqyrNwGC43campzgJB+gRL5Kp8XthMJkMjfY7GF2/5x4vt1v3js5y4JpB0i+3gYWVehEKvPd/nUmb+toRYCHk/RPaC7KKoCWRoWYNBs0sNnl9ZgdH6RTSbQc99Z2z1e7wln4nK6Jq6mXEHRK7gFxzaUDkLMrP44GNljGFiqjMRxzGbQi1zmyEA1ePLUmcd9fn+3zeLVSGT7ycsXL3yWPCOaMI6e9BvF9Ost8Ubu/WZhJOw9rK2tP8fXY3t7+1mw5+bP9scOGIFAmFgf+QntclZ+rS0tsvSHQuHmnr7+X3S7PZ0VVagMAsHgKbJ6Fswn17G/RRxKlAml0XslGpH+gqGiurqm49jxng+Ssa8tnQxFUbanJsb/YGFhjnqrat6IBdE+2LH2C7Dj2s+P1+n3gsPpKBIOlGV5hSx6QWJ85w4QSPx10Agxr2SeJ8imHYKVMrpVOfz5DcqzfbzVMXm1d9XOvlbnn5meYkr8eTf8EsIkORwOOZvVW7WZaj2XVqeI9BPStEM6BEERdtY0BoiP8S+QfnI6JyFMBUJGPheIWTyTaqCnp1b8d5w9A+dHJ2FkdoFUQoDF9HbLlyd/6PzFYw9NuAWn5HN45XgmKaXSGeaOT9P28agNBovc9zUsR6PQFKwq2c4uSlXgwsQkJDJZts3v9sBIZLbrxeUrPTmvAJGUBWpHsPnJR7se/KySSUf5+0TKYwv9KEqSmEwkDOP8zZ6dcr+r2XNq8exYKv6XK0urG7+2Kkf/Htgpp1KUUZ8upzxd1JGS38l/4tRtH/AHAv02i1cj29vfu3zpwuc40m/XvZ+fFDOL6RfBnPwLPp/vvkJFVHWDdOrnodjab0b+sVNGIBBm4VFGYXj6NpRvR0tIf0fnsbtaWtveU0EsPx0jrMWikeFkMkmJREKUREd1de2dHo+naBLW5XJ1cHW1CkVEIA4NXsdYhSf9bB0IBBt7+wY+TMbcPjtlK7K8OT4++jvLS4vDsGOc0I9PeGu/Vs+SkEGHw9nAnzubzU6BcWghehoeEJD4c+DJiQHhKCFY2v52iFM6S9OZfYIeqxid3845+H30++uJFSX8tCytPD3018Afoz9XvgHShPccVHjP5XZLqqKKqqpI5EWWCOnXGiJ+oaSfV71jpIJ07nRNJ/00YiODzrLpdrsF8r1Kzs2IvyhKpIFTneR8RhZ/ms7Pl1WzNbTpqfJ7wO1wwj2DvVBfFYSXRsYhS0j5Ymqz/p+nnnK+r/O+xRqHPxXPJn2JVNqQ4NPJgh0PgHyrS/6JpVIgVAkl4QF0/xevTsBmNMH2lcn32wnaXoJTFCQWPpDP3CdMRZbe/rmxb9z3YOPdv97hrr1CN+YnR7Ti2Jo01qLb41F8Pj/9bUx/f93vbjoJUAmJLucRontuBLPnmV8bPKMl74/Rc11p3W1gN2n7ijpS+rwNnjj1nmCw6pTNMs1Iv9ah8p0qL+RnFnNvNgA38roRmppb2iWHo5BeMJVK/SibzWTAOLc1ivohEIgiWJB+M10ULWbfa7CwftvpdAb6Bk68OxQKnwWbRJz0lcmV5aVvT4yP/kzhOk6g+kChlasnT535GO/KTMYOtdy5zVz8cRIAcRhR6VhFH47odbs91f2DJz/scDrDdgokpH9rfOz6by8vL41AcdYpo9h+jRtoBroSIu9wOFr486dTyetgTfp54PhjH4DEn4MVudgNkSomNL9JHvLf3NM6We1nRvit62g8KZEHa4DyavtiOpXiZx+dBguvoKt1quxFJ321Rmqy3JpPq6MQYqJw5UrkEGbth+KBRVGjF8nEAm6nBxrCoVxrQch3d0sTNFaH4AfnL0M0mYLJxFL4ueXLSou/UZ5NrEE8nTa8Lyy9n7BTAXq+1WgE/G43s+xDIQGgyjwGXrw2Clenp6GjoR6aasLMY6A6GKBXC1kmBijA+MIynB+botUSthJx35WNsWMdTTniD8UDEYZoNEIF4NQ1WFG7j3ft6jnYLSp7tnf9jJY9bi8Jf4WquGYCOexz/8CJh0Ph6jttFk1J/5MmpJ+39NN3wIz06639VlZ+3uuG7dfY1Pzz3LHqxvrqt6F0wg0t/QgEogQ2SL++bzay8hcRf0L2W3r6Bj7kdrtbbFZDJeOCibHRkb/b3FhfBoPMJttbW8uZTHrG5XIf1w4SRcEL9toydPNHHApYjFXKeSUWEX9JkqoGT556nLxjTXbKpULDExNjv8uRfn0KTG2crr0n2hjDUKibjJHC5P3jXWTVra2tS1DsXYjGhgMGEn8Ohzkm/5CgnMsRU+TlFo38FwgHFFv4NaKT1S18Y6DNJDpIo6QXCuJjB32qqojULF/j9xeqS+P1A14v/MIb74TvvfwabMRi8OLqteq3tN6RIPtDOqNAMp0pVumH0ul/iZx3fmsbeurrC5SflUC2XxyfYQd88K33gs/jgYIRgp1IYpUFJTcJwYg/vchsWm3x1s2DubVhV+EjB/H8ap4h+13OXsKmKq5VDtzCDHpPb//9NbV199gsmsb0/4CQ/s+WIf1mMf1G97mc2E+RtZ/Gjni9voe0gxVFnpwYH7sIxtZ+PqSg0JljfD8CcWuiDOk3IyJGZKRg6W9t67itvaPjA6Joz/WYtJ3y1ubmd4eHrnxTlmVNGAx0dWLtYjqdnuWJPwJxM2GPFPypV6J/4MSpd/t89vSHyHg4OT01+UdLiwvXYIf086mFtTEKb5Rjh4KxRyJU19R0sUFwoQx1a3lpYRKswwvNzonYIyDx30ccsYkEI0E0viHSC/i4JEnykE6a75R54q+Rfv3Ckx+9Yqie9BfiBBVRqCInFmVZgepQoIQ1Owixf+Ts7fCN51+hafaEV9eGfU6Hk/xGGYjE4xAOBEoulMdqPMq+CLjcO4KA9GIIoT99vB20TaqssokBlY8ToP+IArw2MpWbFBAECHv8Q3dU94wXeyqWWv3BwAph9kzZdc3fA9xUz7SJgr+R+nTRRJLB4u3oOna2obHpQbA3MUM9Nn58+eKFv86r91dC+vUE3Cq2Vu/mX0T+j3f3niXcX4uzU+Px+LegeAKOV/Y3EtlEIBC3ICog/fxEPE9EeELiEQTR19vX/2BtXf3bqJ6NnTqQMcTm3OzMZ2dnpmhmHo14qAb1YeMMRVaiRSdQC/HI6MmEONQoo+CvvW9mKYaLxio9vf1vC4XCZ+yUS1P2zc3N/sn83Ax9x6w8EvmxAS/graHIkBUIBPv5vzOZzHA6nU6BeXghvp8HACT++4ijQPp1aXvMOn/evY91+i9tjLzhuYUL/9Xr8CxWOwMXzzWeernD17AEuZdcs+xrKcu0tZ4EaaxY5Mrh8/0Wlu1ULEQV/alsQC0l8QW6zFvnRXj43O3wT0+/CPF0klnrqZv+dixZRPz1oPssbUeg2usrIv35kxbS/BX5KfEbyD5jc0twbWaWxhvS7cn7mt7wl7r4xMIZD/L33c2EwAFOMLxuWCj486q4VjPoBWt/c3PridbW9l+A0s7OCGosFn2WkP6/zFv6+Vg5Xh3XDunnYeVuqyf97NrD1dXv5KqVIQPob4E56ccOGIFA7Ib0m7kcs21Op7Nq8MTpRwPB4GmbVVDTqdTIyMjQn25vbdKxgxYGVRQGyNUn712oZvmTKLlJV3QnRhxq2FDwL9G2ApP3raPz2Nn6hsa32CxaWVle+pvpyYnnoNjSzwv6GY3JeRiJZ4LH4z3B75RKJs/DzhjHSNm/aOyBnob7A1szrojdKfcfZuzieozS9+gt/qwhEkUx+NLS5V8XHFIooWb659Mbj31l8kf//YeLrzxCyHY12YcuYW6p4pYgWSgLL8o/CqXCQEXKwCuJ9aCDkGpC/sHldBS69Zztfcd53y054VxfzvOJCvRRF//NWMzywrdSSYhnM1DtK/VKFPIF7aR92BlbCPl/1rej8NNrw0zcT1Wy6Tc2Df5Zn7913OD+gsk2QWe13jPshqR/7OO/YdpuHCbSz8Ho2a0kVs5bU1vX2XmM5b+1M1lKreovXr742p/SmDmoLGWfWTo97Tr46zGL7S9Yv2pr6+pdLnchLCGdzjy1vra2BqWk33T2HTtfBOLWgomXlJEmip7087nDC4vfH2i87cydv1YJ6Y9GIj+8cOGVTxLSPws7hERviSwRRRV0ar2KIm+C8YSm0d8IxIGjAgV/o/eNN1B4Gxqbelvb2h4BmwaKjY31r41eH34SrMcpvJu/XnOIJ/0F8u/xeulkX5+urOfBeNyBwn4HCCT+eRQr8KtCubRi2vd2CLT+3Pm1aPS92f5262vnWP159IvF8eyFdjgcRjl7GXmiaufj0fnuuJxuo5ZwRrvJB4focL+2Mfbo34//4D+MxRaoErqe/NMlBLoJAHI+ui7ELIGJOnBWybJQepX8TMVWeaEoJp+ip7WJ/J5SwShP4/7N7Ox089L2NgsVqHJ72Da1ZA8o3a6y4GpYWNuAb7/4KtBkfuQ+JO9rvP3z58InzhsUo18LPp9fCIXCbFt7R1fFz4T+2TD77a32Nzr2tz75myq/r91JJKOyir4zONfrmXDbpZhficscTYXT09v/IVGUPHbKTSYTF69cuvBpWc5qpF8/WNU8XKxIPw/e64bvYPVkv0TRv7W9412w49mlbqyvfQWKRf2MXPzR2o9A3KIw8JLSuxwbhUbpSUhh4j4crm4/ceq2f+/2eNrtlE/djldXlv/20sXzf5XNZLbAmPTzbSlPTLKknXbx55NlmQoBlptURfKPuNGoRMFfC0csSjNcVRVqOXa8+zFBEJ02yqOhiE8NXb38BBi/Y5pXYpHwNhS/I2ZhhwL1kCRj9sKYSVGUlcWFuXHAFMI3HOjqn0elKuUWaf9snZsXR7NSO7cTz23ns526GX2nc/WnELJZ5klnOPtPOm33dHSxzeV0MgL+c2dOAZ0nePX6BKxGIuJKenPwm9PP9B8PtLzyCx33/kBShdgr68PH4nJCua/hjlcoOQYubYi6kzdPJB+1wYae/LslUXSyHIGKCpmsvJOiT+Wt8ZoVXoCuxjq4PrfEti1tboNTlCBDkw3o7kaabIukUlDt9ZKWifcdMABXCPXif+7KCCljASRBpEdm3t5695cHg51XuL2N3KMKp4/HY4UGcGZ6clfPhN1MFWb7mxxv+9k3Opd+XZRG06KOlcCGQI6+M+WfpwLxd7lc4f7BEx9yOBwhO+WmU6nhK5de+8NMbsBqNFDVd6blSD8PO5b+AvkndXf6ff6Cmz8ZAF8fGx15BUpJv1kGAex8EYhbCCak30gPxWzClPfS89XV1R/v7u3/qCRJQTvlk34zOjc782nS370MpVZHzTVYqxs/fi2ENunLymYyVETXKl84AnHDUKGYH69BxJN+r9vtru4bGPxFSXL47ZSbSiavXr1y6bN5/SEjS7+Vi7/ZOKQwng2FwncDH9+fTr9CuEO5FML4Ph4AkPjvI/Y63ll/Piv3731wzzUTFitpnNaS2x10v6ycheqqAPicLnj43B1wdWIGXrw+DqIkieOxhbOfH/nWsdO1Pa89t3DpbVTmZ3J78bZ/0/PwP+bJv15MROvo9Q0fs/orqupiFXJIsLS+xVLqaUy8ID1K8+iJzPIOjeEQTCyuQkaWIZlKk3WWTQjosRKJsM0hQvxBNSf9rCSVpQ6CiYVleObyENtIST85Xn5Lw+3fJaR/DEqtKPz9NJsIuCGN4UHF6+91GTbdVI3c+4tIvyiKVBX3A263p9lOuYTsT1+7eun3U6nUBuxOyK8ors0kxtbK2l8U39/d0/egIIo1+erR2f0vQynhN5t4wBg7BOIWgoW7sVE/b5b5pEBE6hsa+7p7ej9iV7lfzmaXJ8ZHfz+fSox35TdSE9eUwrW6yfnPguSQavjzJpKJKTBOHYYTnIgbCptifnoDhV40k4bXBgYGT73f5XI32CmXEPD5oWtX/jhbaqDgw2d40q9/V4zqW+AFInWP9Hrv5suMRLefBnsphHHssc9A4m8Th0G0bGZ6isZ685tMiX++QSmq7x69SEazkkVW/6yq+Jmbv0obGBlUl8rU7gc72qC5thqefPUipDJZiKuZuueXrzwoORzsbGuZ6N1fn3468972t9Ac4/pZfq0s1gBuZePN35t74YHlxMbxrkDTzB31A1spOQNeyQHTK2t54l98uSJ3R1rqaqC+ahkWNrfY35uxOIT8Pi4sIKfOvxKLMeJf6/OXCPux0wmcfz7Z8dWRCbg0OQ2iJLLrz8gZ9b7GM8/cWd07BuXJmiX5p7/pzdoY3oD3x+w5LSfmV+hMe/sHfz6vSlsWspxdGRm+9ruxWIy6lWqkX2/pr5T0G12PkYJ/ibgfVcyuCoUfyx8DqqKsjV4f/lcw7njLxdohEIgjDAthsUrUxAvW/rr6hu5KSH8mk5kcGb76u1ubm3NgrCaut/ZDfl3UbhHCIUiSo5E7tULOOQnlST+2eYgDRZmJNrN3Tv/esbFLHxmr+AOBXjvlUt2h8bHrfxSLRalgpl7Ij59o06v4m3kl6MckYlt7xyB5F+u1MlVVjc/NzLwM1imE+XcQ38d9BBL/fcReER2tgfD5fEZkwApCbV09rK2uaGSi8MVzzz5lt3i99bScNcApke43t7MAMidcT+Pvqwi5/sCbz8FTl67C7Oo6E+PLfckM7sJYZP7en65c2ry3/jSNg9er+GrEzfWd2effvpjc6KFljMUW+q5vz4Hb6WHke3ZtDe6V+pg1n4da8AAQmKhfU3WIEP9N9jkaSzDiz++7nogx5/5aLyX9CmhSfjtTA1q9SZmra3B1ag6WNrdyIn4qc61W39R46sLddYPTUDyAkgzWejX2khALOODG8EZPdO0GJnH95dzmSkh/Z9exs7W1dffYKZO6p46Pjf7B1uYGFaEqR/qN4uWsZrit0viZTSJRa/9ZSZIKuazjifgTqWQyAebx/SXLzTrJhEAgdoVyeii8iK+RmB9rP0m7eZy0Px+1SfrVVCo1RD2l4rHYCuy0nRoJ4QkIQDHBKGmzQuHqasL9Cyl6SNu8ur21uQbFscRmCv/Y3iEOGnZDEc00iHxkrHJ3TW3dOTuFEQKenZ+b/fPVleVRKHXvNzJQ6OP5rYwPhfErqc99UJTGL/1yLBaNgLnFH939DxBI/A85+FnB1dUVttb+1q21z0UvTZ708yHufKhAYT+jQb7BjCToytJbU1mj5XI4ZNqEUEKcVZSdAvOu8jSt3oO3n4KXh8fhyvQss6grisr2J2RFeHl96Oduq+5eCjp81Bxv5O5P4/ndrEL5eQNR2qkqdd0XDJzktT+p5Z6S/9aGWrg4OQOymtMF4CHRFH6RCNu/xu/LTxcUS/nRSYvtRBzOj07CwvompKm2AOQEDbOyor6l8fTY3bWDs1DckOsXfjJAb/1XuPt8UzeGBzGJYEMZVy9KZeTi76XWqpbWtofBRmpFlv92dvrTK8tLw7C/pL8c4S+Kr6upqf2wVn+aTnByYtxM1A9j7BCIWxg20vbpJ0tLUp1qS3VNbWdP3wCN6bcTZ6wmk4nXrly++EepZHIddqyPRi7+/PhFI/0lqK6u6SK7FYTNstnsmC5vOMb4I244TN65SoWHffVkrNLc0vYOsJcGWl1fX/vy9NTEzyD3nhmFIurHKRrM6loyBnG7PQTeolSC0UjkR2Bu6cfxxwEDVf11qFSpXH+c9rmS48y+0xOZbCZDLfjs5fJ4vRJ5v3jCaGhBDgarnPn9HT6fv0AsQ6FwkWWZlqV3L+aV5MnxRgIkho1B2B1KUBJP3d2TyZThq0yJ/p19x6CvrQlkWYGHz94O3S2Nmvie52crV+8kn0I/W71896euffX/+MrUj9+lCEz1n1kXmjw1C4zdk3O319WymH0KWZbB53ZR4g2C7taquTQD+ckHgSq3QUN1kHzOpfwTcsr7bN9oJgXJTIaJ/gVc7vzxOz8GqT5cHJ+CH716GaaX1xjpZ/vk9wi4PMpWJuZ7cXWoayy+0BpX07UgirTx1ly3eOJfaDhpbJTuvho9M6JZJgY7z6jd4/T77fbdsItK62cCu7Fyhi5zPr+fqlE9Kgiiy0ZZ6urK8hdmpqeoCxs/e27m3m/o2qYn/RYDcTvWfrHrWPdph9N5RjsfGVz/09bmxiaUEn+jOgFg54tA3BKwSfqL0vWCsYK/j4wp2nr7Bn6JkP6AjaLVRCL+yqXXLvw+If3UIs9rovD5w/Xtp2XWk0AweJL/gnD+K1BeTAzjihEHBhvvnD51n6EGkd8fqD/W3fsBMma0peAfi0afGRm6+g3YIf1Wln6rtH2WosIdnV3nSJ2qCgWraoSMkX4K5Y0OhUPwPdxfoMWfQ5k4ZEpEDNP60W1GCulf+ocnpI9+6HHZokhTS6iR9XJra1PbJiUTicJ2OgmQJSQ1m83qY2TUSGSbnYPsr71cbNZ8YXFRbKivl6PRiKIrlxF+qiKfV5JnZeaPB4fDQVX9SxouQqQl8oKzxqDG5d+mrvE0hd12IgmtJVr4auE1PzfQC9NLqxD0eeBNJ/pgammFhQdc25o8cbqme/3ZpUtvcThc0lxi9dRXJ37ofrzrQTpb6ThbP7Dy4spl1ePyCc3VYehrawaHJDJX+7mVNZDz5fM3IyVnGbl3OXK6QORaoKuhARbXt7XbwuYS6KelrW02OVDn9zGSn4vnz8UjbMXi8MroBCxvbEFallk5bA5CzesDknVKyUhXt6dayJ8t8qpCxQNVSRTkgNO/7REc836Hb/KO5oFL8UwqU+8LTzUJVVRtXVQUhY/xBzAm/6rRc0MnBPhsEXaebatn3krhfzfnyxN5QaujRuytMhDY1Qao0GplKOhHB6z9Aycetangr25vb3139Prw98B89lxv6ddc5+wONK2sAvrQkYKbXX1Dwy9D4blRE9OTE18CY20Bs0EwDoARiCOOCq2OlpZHQrib+gZO/BJpO6tsFK0m4vGXLl+68Me67Cc84dcTEH2fqBc8Zd95PN4zfEFkfPMaWFsZi+p1o38TxNFGhcLDpqGI5D0L9OXGKnbeN0in02PXrl7WFPzL6Q9p74lWR31d9fUtGn+EwtVv546jk2/PGbj5W4n7IfYZSPxtwoxQWZGSxx97TPnohyovy8JlWf/ysb+5SQAeWr30Lxb7OxwO0U5RO0fRS0cIPxiUz87PTS4UfZe3lOdyhwca45lsmtwbN6xHY4xAq/q7xNX2jYT8OySJWdtPdrYzcTwVVPfXp5+5T5IcUlt9NSysbcBcYr3n1Y3hjTur++cCkldt8NZEtuRE1eLmBvMcoFb+mmAAQj4vK08VhYKZnvkGks9UANDj9OVIOtnW2lADoWkvuJxSoWI0PGEjmWDf1/kD+ZupMoK/uL4Jr46Mwzoh/7nRSD7uP0/6acgALZaQSKYdkKGpD1U6YeSkEgaOpJypSUKqZiMTOzU9tvROqgfgkVxL/7H3Pe/MT5yU3HPuMxP4s3jmbKXus/v8mqGSyQKD78qmJay0fjbi+vUq/nrLFcsM0dc/+Hav19dp5x4kk8nL165c/jsqWgOlHanVDHphwGkRXmM1iaHvcHXW/uOnnE7XXYV6JpJfW1tjMUJ2rf0IBOKIowwB4S39ejXxEku/z+evGxg89UtOp7PaRtHU0v8yIf2f4kg/337yor56F3+trkZeUEJdXX2TwyEV2m9KclaWWAhWOUs/Eg7EQaJSF3/9WMVHxiqPeL3edjuFKbK8OXZ9+FOEgNNsQ+W8EvXvHV/fsqGG9Q2NbS6X8xRXvLq5sfFdsB53oKjwAQOJ//7i9cRmW7n6Sro1r3SroYTsA/eyKdTXfscCadQhmmkIGBHSoomJsMsXdUlO2qC4FglhlyQRslktXD13O1hqPc1Vv6GOWfnpt5TAvzY+lSPNSsbplBzwpsE+WN3chh9euCK8sHz1BCH+NB5Q6gt1Lr64PlRFXe0BdvT4HZIjVw4328DU90l5KULE+R/E43DCHd2d4Pd5tJrBwvYW2zfkdoODet6T81Br/+LGFpwfm4Q1qvQPQuFyFEWGhlAIjjc3QEdjHQRZ6r/8LSTHxZJpWCHHrm1HIZpOQSyRhO14AhKZjEA1AzfiW+G8x4Spe78dWJHkw5CVYj9gMIA1ius3UqPmO1Jve0fnHdU1tXfbKZOmnRoeuvIZWc7SWWyjVDhm6v12SL/Rtdgi/cCs/U3/DnZi++NTk+N/C9akXy9yhW52CMQRhs6wYGbF49P28eSjSMjP7fZUD5449VGXy1Vvo+hcTP+l1yjpp6FHRpOm+rh+gOKxjZG4GGv7Ghqb79HF949EItvbgHnDEYcAuxAeNsw21Nl1/Fy4uuYOO2VSDaLZ2Zk/29hYn4FSMb80GMf1Wwn68fUtIf7NLa3vILsXeCXhGXNkDPIylKYRRjf/Gwgk/vuLih/gMvG9ZoN/3gOAL5sn+/wiq7ncdCKUn30zskAClJL/wmdVVtWgwxeNyMma7UQCUuksI/I86Vfzcwsa+Rfzanwelwtaa6sZyaYmdL/bBV6yra2+Fjoa6mB6edU/Eplt7gu2bd5V07/xyupQVhbAMbmwDF3NDWA8X5ErWhJEJuxH1f6dolSoS20oyJT4c6r9KqzGYuyAWn9gJ+Y/mWKp+nKkX2QTAdTa39/WBD1tzVAT8IOs5PZlQoGcnKLb6WRCgq3kGuj5RFFgwobXZufZTgGXf5I0kIYeJXrstlE8iqSfw25m0AukPxQKt7a2tb8T7In5paamJj4Ti7JUOPzsOW+tMhPyY9iFe78dUT+xu6fvDU6nszAgIIPsJ3TWfiutgaP8fCAQCLAtgKpNlBqp9xdIiMPprDpx8vSH3B5Pi52yU6nUtSuXL/7PdDrNk35ezE+fuk+rp7bWt4OFtpGmLw0EA/cVl5d8CXaIRtm84QjEfsHCk8/MQGFI+mvr6rsJuX4IbIr5bayv/dPsDNMg4g0URmJ++neDP78VBym4+nu8Xur98za+AvF47LvZbJaWY5VGGN/DAwaK+x0ilMndbWrBJH2eUS5dveIuc2fWFlnO6kXmnGA+oWCUZs5qgZC7apORbUKoqXs8aBZydlUCJDM5F/icZTxv/acgfx9vaijs29VQz7wBKGG+/XgXJdzC+fUR6uLkcktOoTfYtkFd6y9Nz7BwAe2mGbUgTvK9IqtMtI+/xbSOVKGfHrfCQpFyqv4hr4fOWJL90/DTy8OE9EfZmd1OCQZamuGDD9wDd/V3Q9jnY5kBisAJAbLJgzytF0hlJxaWYWxhkf0tK7LS4q/5WvFRJShqFHcjereXgnyHZRLB5gy6UQqqwkJj5Lp7+98vipLHRpFUzO9LiwvzVDAqAaVxqVZuc5bW9Apd/PmF7UNFIcmg4N/DjrV/a3xs9AtQSvr19bJVPwQCcXPDgPSXszoaifkV9FBOnDj9KBnqH7NTdiaTnrh29dIfcEJ+Vi7H+slSM40T3tLY43A4u7kiCelZ1wTFbMX3Y9uH2A+YhNWYCQ+bhSJ6CWqPd/e+z6aYHyHd8RdHhq99HUqFh8vpD+nralbnonews/PYW0jdOH0kNbMwP/cdwNj+Qwck/hzKuEof5L2yK1LGGgRVVTQXvEB+CXKfA7DjnueHnQZFa2DcUKoyXy63vKnwnAKK85nlC6fbwk0iU8onRHd+fSMXBJ/nnjnbvwqJbAaMBHq7muuZpZ/OBTTXhgvf1FT5odrnh7nESvVacoteo+PepttWSRHKRiQGE4vLrEa56Urjn5Km/YulU4WJBloPSXIw8k+3LUeibHsDs/YLkJYz8MLQGKxuR8DpcEB7fQ28+dQAnB3sYV4CBaV/TdiPAyX8NGOBkvdwYN4EG9vkfKOQkZmQoOoV3S882vHWJ6ECS8RhId43EmVc/Pl3RS+SU9SZ9vYNPuTxeJrtlBmLRX/KifmZucwZEn4oT/qNrsWWij9d+gZOvM3hcPRrJ4nHYn+7tbmxAaXeB0Z1QyAQtwbKKYkbaaEUkX7ST/r6B0++KxAMDtopMJvNLo4MXfs90iZR7yPe0m8lLqYn/ZYpTBsam96e/5tBluWJhfnZUSh1LUaLP+JGYDfCw4WYfjLWpGJ+73E6nWE7hWUymbnhoSt/pSgKdV+1k21I/y5YeVGWCPtRhMLV7wJe1C+V/unK8tI8VBBqiJNvBwMk/lCaRsxkN9Uo3VglKdFsHse2+3x+0eV2S04a5U4gSZIzP9OnT62jJ/x0oUqfVaSDDuU/a9sLEwHkuwBwkwDk3B5ShhuKyT+v2MnWZB9Rg8BBq/w/TPzw519ev/5zU7GFLhbHT7ZRQk6t8RoZp//SVHrb8Xgu5l73qlPre10oyCz09eFQPnpfYCkAT3e1gyQ4hBfXrzXS+lU5fPLJqq51mjrwuWsjee2Awm0s/gHpxRGSn0ingWYdyO2V1wYgB20m4sy7QCF7NlSF2EVPLK7C9MoaBNweONnRCm8c6IOmmjCoilp0XrZw17ERjzEPgawik+1KbqIjlYbnh0Zy28hWl+C8/JHuh/6I1LnEAkszDjidLpqxoXBOPr1ipc+b9p3R/vrvzJ5Po33sprE0219T+rc6xuJyrQaxZnH9haWlte10dU3NXWAD2SzpSK9d/VxezM+qIzVy8bfToZVz79db+gsDX/KMeMPh6l/T7iPp7BdGRq79I5Ra+S3d7LDTRSCOJspkPaGLkaux3ouQLb19Az9H2ps32ClXkeWt8bHrv7+1tTkHxer9lVr69bHFhbFJVShU7fX6itz8E/H497PZLC8SiCFOiANHhXH9ZpNt3u7e/gf8/kCPnTLJeDM+NTH2afIOaBNt5bINGYX3amsjo0PJGKSj89gdZMzKe/+o6+trX4VSrwKzNH74Hh4gMMYf7FtQd2Np3aV1VojHY4XPsPMC8oSGt9jzhL2g1K+qqvaCZXVLhop+5I+h6wwhC9n8Z/oi80SBbwxEWZb1RK1o5jwtp8MiqcL85nI+bp60OOkMbEVjEPB6ilzgfW43LEW2oT1cDfwcFHWvD3l9kPSnmSVeVnfC37tbG+GZqyNwPTJT86By17pLdKj3Nd25ObQ5HU6rWcf3X74I7zh7e15DoFSl0Od0wnpMhRgh/wGXe+eGky9pXei61uNjmgPpbBbmVtfB7ZDg3lN90FCdJ/yclV/lCqGTBiuRCKzFo6QcF7SEw0wckJ6TZgp4/sowbMZptgBBdYI4Qkl/UPRGwaAxzObUEJVMpijbwp6o4Bvtb5SO0urcRvvYUPSvqK5lUl0aZbvgB7F6a38R+ac5cNs7Oh8BG5OfLK5/cuLPkskEFZW0Grjyg1dbSrU2XfyNhHQKFv++/sHHybvWpFV3e3vrM6TTpx1+JaJ+CATiCMLCxd8srt/QvZ8ux45331NX33CfnXLJ8CM5PT31P1dXlqnl3Yr0822TBjMX45JwxI6OrrcLguDfKVdNzs/P2lUSZ4fgpCdir2FTeNjIK7HgkUiXpubWwbq6+jfZLFZZXl76IllGoLyBwmgsoNXZyOPQ0PBAl7r6+vdyx1IB5NGpyfELYBxqaBhmeKN/r1sJaPE/JNARAADjhoJ3X2YNxE9XLt37L3PPv+vZ1YsPjMYXbiPbKIumlv5w/jO/Due/M/IC4LUANPd/PgyAf9n19Sx0oNWu4FxRzD4wPyBYXNvUvdkCVHlyafeWYlHd3RDA53UToh1iZLq4aRCglVrcBUE6vzZMr0tyEJr+1uY3rFNSvrS9DU++epEJ6O2Q/p26eAkhp14BUc7dn4LG/UdSaeZV0FhVlXPPJ18PtrfAvSf6mWo/I/1cU85aLurOT9qv+c1NuLq0ACuxHOmv9ftzgoVkycgK/ODVS7CwscXKDkrea7/c/fCf5km/VdwTADaIRahAnMosD66Xuqr29PW/W5IcARtFqutrq08sLS5cg+KYfqv8t0W/4etw8TeL7S90umQQ3uj3Bz6UPxZkOXvx2pVL2qCXn+zT10+xU0cEAnHzwgbpN4svLrH2Uw8pQkKKcnSbQ80uLiz85fzcDB38l7P0m7n3lyX9Xp8vEAhWPcKXnE6nn1ldWV4A44lPdPNHHCSsJvPLpe6jD3djZ1fXu2jWJxtlqdFI5Knx0es/hPIGCquQPytNjRKPm9a29l6Xy307X5Ht7a0nZFk2Cn809brBMcjBAS3+hxOG1kyHw+nOZjOFGcJnVy/f+8LqlY+7RJcoR2TIypepjT9V4wlONfhqxt9QM3C5xVtL1ccLln7YiUemSwqKSQy/6BsIDfo0ghrYC3y8qnV8Irb4oEjaKUp8cy71Asytb8Dx1qaSA6ga/vzmFoQ8XvA6djRLQgEftNbVsImBHD/P0XhGzMMhpvp/aWsifK7+ZCyjZKXBcGfq/NpIaiW77V5Y34RnLw/Dm0/1Qy5rIdeekHP5XS6IJkh7WBUqTCbQCQOHKDCPADo5QL0OHILI3Pqp1V7lK62dimoCbG3CElP6pxZqiRB+HzveTUMbyPcb5LsXr16HdbKmcwntnvoXHu9+2z+R81uSfofTKWQzGWwIjWFG+q2sV4WFWq0IWe62U1AykXjt+sjQt8FeR1riNrcHLv5WM+1CV9fx/51OZOTPJS8vLf2hqqr6Opl1ugA48EUgjiTKTJJa6aCUWPpr6+qPd3Qeex9pa+yMGdW1tbUvT4yPPgXFIqhmpF+biDQzepiFOonHjve8XRTFWq5seXVl6QmwdjHGvOGIfYWJi78Z6TdU8Zckyd/bN/AemwYKyKTTU8NDV/7GRjiiVTo9s5AE01DDxqaW9wOnr0FDDcfHR78P9jwO8R28AUDiv4/YAxG2opeQkH76d8E9aDq6eJckOkUlL1DncbmFRDLliSrp/lhsqX94c/YddZ6q8dure352R23fCHVZhlLSn9Stte8yUBp7x9dJT/7ZS3xbuHv8qYULm2TncJXfC2d7u2F1axuy2Vysu0DItGaKpwcG3R5ClOMwRwh0X10DKPlA+SqvlxFu6k+v7kTiM1Ayfn58CrbSMddUfCn4D6NP1tR5w8oD7XclvznxtFsSJBhdXGIhAvedHmTlaWn56OeAxwvriQTE02k22aCSS1uLxxhRb6wK5XUCctZ6h84pRqsNtezPbW6yi3CKIrSGwuB2OFj9aUYAmdyANXJNV6ZnYSsRZ94Cg9Vdlx5uuftJ0jDyM6FWDSHfebC7RjoU9sWtODtqEqfKE2SjVFQ8+feEq2vaGhqbH7BTniLLm6PXhzWBHL4T1b8fhrPnVr/RLlX8i0h/T2//OZfbXXC7TaXI4z8+ehGMLf0VeyQgEIibHpUq+OtJvzcYrGrq7umj4URuG+Wpkcj290eGrv4zlBfy08YWRn1e2TbQ5/MHq6pC7+ELz2TSr0xPTdKsK3YmPVl9sf1D7CXK6GnYzZzhIf37g16fr9NOmXSMQvr+P0mlUjSFlp70G41VyqXttrL2c6S/ucPjcd/D1yUWjfxTKplMgH2PQ3wHDxhI/G8QqGiZxcSA3pXecLZQZQSS0FZylt7mBmiuzmXSWN2OwvjiMiWwwrYc7/7xyvnun61e3f7AiYderc/6np1Nrla9vDZ8+t6G00/VO6uo6iZtINyw01C4wJr8W1n95Tc2nPzxM0uX3rsRiTHafrKrPfelmou8F4Q8gVZz7vhNVVVwfXUFlqIRqPfnJjdzpH/nBhQ+kAPqw1Xsg0NywERmudrt8ogxOS3+aPblwO21/YnLG6NempxvcnGFEftzJ3oJEd8h/kG3m5H1bdI2+YIuWIpEmKAgtdiHvd7c5IOqZR/YAfVgWIvTSYotyMhZVp2WqjA0BoM7sf5Mto/cNFmGeDIFq1vRvKo/wIXVkdOTkfn2c00nv3Z7sPvHYE76BZZSoLQhLlRHmwCguBUazTJu8Xy8nJFQDltoCqrj3T3vIgNYl40ilcXFhS9sb29Rl1GjgatRR2pLzM8kvY8dMT8+Z663rr7h/8ofQ9+tzYnxsT8B41l2jO1HIG4hWFgczRT89eSDufi73e7qvoETH6RpT+2US8b7F65duUStjpqauB09FABromRo7Sdt+SM6a7+6trr6d3n9IiNhU3TzR+wrLPp2uy7+bGluaT1ZU1t3t81ileXlxS+urq6MQfE7ZyfFMA+7KYQL72BLa/vj5LCCqy7hJOsTE2PfAmOPQytPA8QBAom/DmXU9tUKjymXIrBw3Mz0FBX0E1LJpBjN55IH3SwcjfMhnVqh8ahy+FdXMxFVURXBTUhwR2MdI9M0Nv6Oni6YXV6Dl69PQCyVgpSarfry5e+e++CJd6h/f/17b3a73M7x7bl7W721z7674y3f9YouOlPIZglJOYUQAPI5S8osWKjzgoG82KDe6q+crR24dj06e3olsdnzk9euwNtuPwUNVJ1f0CLuCzn3GGjda3w+WCYEnBJvJ8sAoLul3N0XSJHVAT9EEim4tjohifnzJuU0xNJxoS/QlhyJzXroOa7NzEOY7NvT2lQ4Cd2/yuOBTEZmn2m5dDsl8IpOrZ+C7rOdSsLsxkY+BSFAtdcHHdXVbMJA5XdmkxkqC3Forq2G/ngSUuSYSDIJK5vbQlLJVD81f+Gj1W2+4U5/82Y+IwJ1L6DFsIaWbJIJSZXyAn/amQsDpFAoDA6nkwxyVtTaunphbHxH9K/7eJcCBtjNM2p2TDlPFu64onem0nIMjrHj4m9I+unfx7t77/N4vK1gA7Fo9KdTk+M0D3Q5l7mK0uOZuN/a7XALYjoDAyd/hQx6tWtRI9tbn14no14onWW3VLO+FSaNEIhbCRbeRHrPKEslcTpROnDi1KOE/DfaKTeTyUwPXb38GdJvbYOxpZ8X8+NJvwYjS6NhG0iV/INVVTprf+aVyYmxV6FYUMyOZx0CsZcoZ+03Eh0uvHc54eGud9qM6wfCF56eGBulhiT9RBtvvDMyAOjry9e1bJhNY2NTu9freTNfl1gs9pVoJLIJpe8fpvA7REDiD4x4iIRgKNraZDeV269grbey3OfTkWmW2iJyoy+Hs+CyfV0ul6AoikA6UcgfK+Td1QuNyFtb7xy9OvQ1xevwSF6ns5BOzuN0sSPaGmqho6kezo9MwsWpKaqy5/325LNvdUlORqwlUXItpTbe9rnhb3X/cs87/ibo9DPVcqqKC7nGw5UPD9DU/7OEbKgKDYDPTUQw0T+yT4nl/91tb37qi9e/05hVlOAPz1+Cc/29hHw3Qk4UX+Ws+dTRXmBWf6p4P0G4S39DY2mvzG2gpLq2KghbhFTLcqZwc+l6bHvO8/7O+7ajmYQ4n153SZIAl6amob+jZUcokMDvdpHfR2Yu/oqac9+v8/lBKSpYgJScJoR/C7ZSCVYGzQTQTgg/u99aqTvOBMybgZ6L/QZOFe7o7WITHllZhu++/Bqpc4K6ZbmSatbDjtmJQRDy2Q+17AkKzeJICL4ok4PJ4Esl51Ez2YyytbVZeHYI+Yc1WCncpYXFZSkej6vtHZ38bRHMnmuzZ5TuX27Sin7Pr/PHqdxxarljdPsblSPOTE/RjAbae2BGkK1m0T21tXXH6urtKePKcnbl+sjQF/Kxckak38raX0lcv5FyrmXqPrqQQcGAz+9/TPu9SBvx6tUrl7/B1cksjV+RtQs7XATiaMGGxdHIM8rIxd/f13/iYbspxGhY1NjoyB/FcynE+Lh+XkPIaLIUYMd4wLv4W8YVdx3rflQQxBBXBRrb/3nSt5rprmAKU8S+ooLUfXohzYKSPxlf07j+d5Oxn724/kxmZmTo2hc4Dxs96bdj6QcwN0AYvX85Ub/2jg/qrP2bExOjXwNr0o+Tb4cAqOoPRSS8HNFR8vuXtWLmIWgEKr8uLOXqlE6naUo3K2unGHT44n7JvUG5I1WVp9bnAtQcAaWx5XcS8vnAqUHSOSuwkdgGUcqlmKMLJbqKJHT+7dh3/2NEjrdAaQYAumjq/37SsRbSCJJynWTRGoUiy39A8iQfab/npzSeXSZlvDAyBi8MjUI0mQROTD8fMQ/MU6ElFIIkTaG3tVU4ldHNpduoBoCWss/rcsIDpweYZV4gRP8nyxd899SfTilyll1fPJmGuZX1wsQIRdDlYcr7NP0erXhDMJD7Pl83qpsws7EGVxeXIJJOspCB3vp6NinhceQnWVS1qIKCbs18E0SRCQlSVf/NWJztT+7+8olQ1wSUWjiKBjrk93ckEwkxk0lTLxAhEtkW6N/AkUBuYbdxeOiqStP+PffsU8A/e1bWe6Nn1OrZ/NjHf0PUpwHUCLwd671RCkEzkOtQuTSGRp2TmYp/YaGdaNfx7neSgaKdiU5lYX7+b+LxGLWem7n4m3aku4jr1w92LQe9Lpfb3dLa9t/y102LTi7Mz/62oshavcxE/fQprBAIxBGCDTE/q/RhRdb+Y909b6quqbnLTrnUODA7O/2Z9bVV2qeZWR2N1MR5lLM0FtrH+vqGVr8/8A7+YDJeem5ygqUPs9I3QcKB2BfYSN1nlIq7yNJPF+qV6PP7j9kpkxropifH/5xLM6wZKYwMFPr3zmxMZRVis+Pi39LW7fGUWPufiGxvb0Ip6TcbL+F7eIOAxH8f8cRXvmIj7U0J7FgL2ZrG8Df66yeoRXlmZa2IUPOgFu32pjp4+OwduZR0+W33nuiF27s72AkJ0W38u9Hv/WpcSVGfeD3x19L/MfIPeSsqlKb642fuocvftPb+Y/ef90juLHUSGJ5bgGcvDcH1uUVIy3KRkAFF2OsDn8sFy7EIRFKJ/I0ovR3US4AKB2rH0pj/ltoauI1pCQiwltom9VGEZm99lrndk62TSyuEhHPnIDeL1iGWTjOS3xisylvsBViNReHi/BysJ+KsjNZQCE42NUPA5S2ID5b9qYTcPf7Z0HX42rMvwXokJx6oqkr63sYzX5ZlOh1Sks+VnxF26bZp97kk3hsMJgBoFfjOaA+EJgv4xCc+YXqu3ZRjNVmwczctXfz16aiKBP1IZ/qA2+2x5a5K3eampyZegp1O1CxWbjdx/XrdDqvBrv73Zmk0B0+e+iVJkgoZCUhn+7mZ6alRMHbxN82Zi5YuBOJI4vWK+fmamltONDW1PAi20vaBsrqy/PezM9PUxd5Iwd9KBFWrr13Swfq39s6uj5C+1LNTBTW9uDD3WS62X+/5hNZ+xEGgXPYMSwNFfUNjD1nutVkWDfX88tLS4hCUkn6jcEQzbQu72YSKPG6aW9s+Qg4tGFLI+H5lfOz6V6F4HGIVZoOhhjcQSPw5WJGW3cQnV4IyL4Cp2nujKzQrkp+Rkv6JhZWdb3WH09o3EoL8psG+HPknr2F7fR2c7GyH/tZmlrM+IygNX5986r2wY/Wvfnl96A1fnvzx+4e2p06CMfmnjVgJ+V9PbQX+duxfH/rK2I/vTshJR4FUR6PwyugEPH91GObW1nPx8OxflYn/dVTXsBqPra0WUgGW3BhyHurqz7gz+b8pHGaW9ZPH2sEhiczz4fz6qLsv0JZlXgDk2qjYoUOSiu7g0naERtYzQUEqBkgt+1fm52F2a5OR9pDHA7e1tEKDP5gn/EZaKJo/vcoyENDzUbf+C2NT8L9+/FMYnVsEhyP3mkkqbD/UfNcX31Ddex2MOwKzRduHnwwoifuGUksyI5x02avnlGIvJxGszlfGdU5vwTKM66cu/rV19efs1EOW5bXRkeEvQbGbqh2BHLtx/QClgwM7M+zsN+48dvyU3x/4cP5YWt9rV69c+gKUdrSmYQjl6opAIG4+lMl4Yit9GF1C4XBrZ9fx99pN2xfZ3v7B6PXh70Cpe79ZWJQV8dB7PZVMfrZ3dJ70eLxFlsZkIvmd2ZnpETAmHWjtR+wrKkjdp08xXHjv3G5PuKvr+LtsvneQSMTP6947vZZGudj6cu2F6eQbaR/OuN3us3x9opHtL0WjkS2wtvbje3hIgMSfw27IkRUJevyxx8q69JuAH6TrTcxFL++pmt6ZjJxWqMP80OwcjdtnAnPFF5L7i5LX/o5mONXVDgGfBzxuFyPMdw90Q0t1mBHvleTmsedXr1IXv/ALa1fP/WThwq8vJtfe982p5z7+/aWX3w7F5J+lHYFiUsoahxfXR/q3MrEGSRIFByHiZAXaf5QYz6ysw8vXx+Gl4THmCk8nI2j9XIScN/qD7BKvr6wUpw3gLsrvJfV3OpgYX0tduLD9tmMdbBJjLD7n6KxqUmRFZneLphNMpjOF/WhZG8lcmj2qL0BF+yZW1yCVzYLf6YbBhkY4XlvPwgdUg/LZn/km0+GQIJXJwvWZRaB6BpTwX5mcycf7U4KmqNXO4PivdD/8xZOhY9Ow0wlYpXMpIrBQPAlgNgGg97rYF4v/DYCV26rZLLon7+L/iM3OVFlcnP9i3sWfd1Pl41NNB7BmE3cG7rflYvqdYOBa5/P7/c3NLf8P7Lj4pxbm5z6RSaeTYEz6MX0fAnELoExcv554mJJ+quDf2zfwqCRJPjvlplLJq0PXLn/BhoK/maXfKqa4pG8jcDQ1t/4ycDnDSdnbU5Pjn+fKMvPKwslPxJ6jTLYh/ThF7+JfGOOR9+5hp8tVbadMWZY3COn/bD7NsBnpN00zXKa+Zu8hG4cQOBoam34ZOO5I6jM7en3km2B/4g3HITcYKO53uFAiAsht13dabFuN078V8gQ3I5l4zeLGJmzGohCk8e+6HATUYC0Q7kf17W7v6WTidpQM031k8uXpY+0s9VwassJLa1fvPlHdtfX80uWHnA4Hm0Vwu13SpfWxD9a7wlu3V/fQPLm0g9UmNvgGjjUSq8mNViCEvy7oh7ffdTtsxWKwshmBtUgEIkzpPku2xQnpX4TNaBROdnVAbVWAEFQnNIfCsJaIQZKQ8dnNDWilXgB8PH1eRr+1vgbmVjfY9WoB/Ce72uDlkXGmjT8VWZQaXdXySnqbpglgxN/vzqUiXolF2I2u9vlAEkWqUAjNVVUQIN/Te0O3Uet9OkMnDNKQSGUgTeqcJX9TkcB4Kg0b5F5Twr+yHSHXkWDpBVlLSo6lXgzZbFqtdoe23lDbf/H2cA91yaKNoRt2GkUKfoDGW5d5t0VtQMMTO227CDsNLA9+0kmlHdTN1NDayIWrxczpLVgF4n/seM9b3G5Pk53y4rHYi9OTE89DqYu/UXyqbRf/PPhrsDO7zne2rMMdGDz1n0RRas+fT41FY381PTUxDNaudYYdLgKBOBrQTSyaTSqWdfGnomL9gyff63K5G+yUK2ezKyPDQ3+SyWSogn+5FGL6tqhcXLHh5Gd3T9/9TqfzBFcNNRqN/N3a2uoilA91QtKB2C9YhdYYaWoULR2dXXdWhUInbZYlL8zPfTayvU3TcOu1NMqFI/L1NTKmmBkhCuOQnt5++g72cedSNzc3/iqZTMSgwoxCiBsHJP4cqFX0S//whPT4Y1Qwu2hmmv1toYyuDej1xN30IeeOoWA+7Wt//mfC8OmT/LFFawch4VRBn1rmc8L6ufO3euvGhrMzNZIkwWvjU3DfqQG97hwzT2fJMQ5RYG7tve3NO2J2ZF0bqoJBsu21qRk6aeD56sSP7yfk2d1RXwe1wQC8Mj4JouRw/GTxlV/qCjZ/Ouzwr8FO7JCW2q9g9fdKnoQgRAhhJqSZEOfqQIAtstpAqpILTaDkmgrexWJJFqcvSWL+gnMu/2NrK7Ccn8iocnuK7h8ttL22hhDvTP5C/3/23gPKkes8E/2rCjnHbnQGOvfkGc4wi5lDkaIV16unPZbt9XrfOjw/h137eWX5SVrr2Gud5+O3x8/eXWltyZJtZdGiZEoyg5lEDjmc4cz0dG507kY3cs5AvXsvUEChUAVUS6REDusna4AGqu69dVE3fH/4/rqXA3rf77LDXiQGB4UYg70NWIolln2ODBB1AUTSNTb/XouZ9AMOEehFwH/nIAIXD4IQQ2Aeg/tSudK4jiJhA7yUhLwtl0alIuUUENh36i35Aa0rfNw+vjtgcHIsx1po3YhwpG7cpow/cRd5aRT5lgzyHv3OFbRRq6DGlNB9lWo/LXmly/U0ELznisjU9BEqsB8Ep8sN0Pqcsp3I/ATPNn+sSI0FzhojzBJQ6VJHQ5KJOJ1IJKq11ziANOgXS0lF3tsdjmGX230byBA0lpJr/pUvClj85Wxg5cb1y03bJ+rBMT1z9H6dTvcw15/oJ74yN3ftiyC92ZVc9JUNryKK3HDSiSxUlncZ2tDfZzKZJ+VUhsn8trY2/iKVTGDwIUzb14nMjwVp0NEx1MloNJkcDudHgbemVCqV9ZWlRX5csVA5roAORd40kVjfhc+zFIs/Ocxmi6evf/ABkMenwSaTiSe3Ntdfge4eNlIkmt3CJyWVbwaDEY/Bn+e3tVwuXVtdXnwaOocbKoq3t5gowF8gP/eRf135uY+0f96FrfxHyZ0uvIatTyR8ENQC/svERN/OznmTY3JhPrF5hqEoZi0QhJsmfKDXaAm45rjosMN6Mp8Fu8EIUHe5r11dW4sZBJAnh/thLxaHMLZgV3IW/PkZVJbVYIDNUIgQ1LE0Y3l864UP/vzou78CtcHN3Qd/klONmfq2NtP7E1kWqMsra3D3iSMEaDOclx6mGahUwaJDoF6nAx4OJf/i+HqbVg+JQh7WIxE43tdP3O6bPcOCx2mHTD7PuTOQj3EdDqMR9qNxiJRSdJktNz7nrP2pYoEoQbAyQa/SkO8q5Sp8//WrEEwkawC/3h6sjGjVwNST+LE1ToJytQJ2tbHkMTizg3p3+qhjNK4GBk/IeCIuoLI0RSirl2ObDpqi80ccowdspcpXlPBdtBpgkwf6uaOhFEAbnhI6isLnh/fa5tK4tDhPfqfDTrhyMlAIzq8c5nyxOtA4IA8l2oh2IvQTA/3koGna4PONP0xRtFpG9Ww4HPwaWlADIJ66T4qkpqN0IfPrpF1X876n0a5g2O5w/nb9WvzMpba3Nj5RLpUKcDgXf4XMShFFbiCRGdfP50ARZfAfGBw64XTJS3UKNTK/LwX2dq+DNPjg5k2x2GIAaQ8uSRbxsYnJD9MMw/dGqEbCob/kWRrF5upDZ15RRBE5IpFBQy7ob3jZjE1MPcowjF5OnaVSaWdlaeHL0Erm1wn0S6XvOwzob+xF0Bj8kGAMVoIHB39V34tKjUFF8fYWFAX4v4nyBsVVCwEddzQGlEtrS4wYPRs7ueAYNppfWFiFB04fg0prUnrQqtQQz2XBoTNCUyXRBNM6jRqmBvsgNJci4HekxwkmvY64tt9+dAq+/dJrhBMgVEjMLCa3Z6YtQzh9D99lndtkaE45JvYuhxciKbbowvH8s/4tODY6XOPYJxoJft3CMKkalh9xOOBaIEAA9lokDJPuHuJCX6ffJ+0dQG3kpzPA72wmI4Hn8VKGeEdgEG8zGkGtYqCMAD629uMzPVZLTRmB7umJV1+HaDpdVy7U6frYWlo/ukqx2GtAo1aDXqOvOxaw4FCbS2fsUwmvoSfDyx+MW6daTe9a5uMb9rX0rjVfKqm1ag2m9IfHt15kfZaBrQ977/seTscCPMCPrfwUtuIj0I+tKtCc0PnKAe59C9u74HnhPzN8D4O35KSLLf4c+OdvZtPpFPdcCWP7paxYZIH1+sZu0+n1g3LqLhTyi2urK09B+0LKX0wPxQotiPvjcy5IubWKgX5Gp9MbRkZ8f4ieCXO9LOwF8Rm06d6CzvF0iou/IorcwNIlrp9v7RdzM27EF9ts9qHBoZFHKYqiZVSLXeufW11Z+gGIW/q5OZPveXTYuP6WkEF8Xl//wKjRaHqU35BCofCMf3X5ZWgPixOrW1F+KvJmyGEzaLSEIo6OTdxpMBhG5FSE94PbWxufRc89doH8UeP6u5EQShL69fR6hkwm8/v5bcrn8z/YWPdfhUO6+Ctj8KcvCvB/64nYRp3tdtzTe2r27/zf97I0zeDUfpsHYRh0Y4b8Jrg2arSQTRchWy6CXq0RqZkCt90KFr0ekrksjLhdDY8Ah9kEgy4HBKJxzI5PXQovnEPAH7uxcwssrog/4akfGXnX1a/4n7y3ygD92uoa9LvtYEegXC4Mwez8Iw47bEQikC4WYD+dJAz7pDK2ZsXHbeXc/OsO+YQrAJP6aRFQx/H5WFmB214iKQQpiOVyYFCrwKTWklZfWd2AcCpdJ/JjwchoqqOm/kKPzl52aCwVt95WvRpZ1q6m97SBTFRFCBSRpPIZ9Wps22XTmO1TtqH0u1wnQpuZfcPzwauuSCGlp4gwoNMw9dh/bI7WU7v58HCVAheNsK0/vWddTGz2HeRiA8lSxl0oFxn02+QnLcMvPtR3MwakHNjnDg6g8tn8pZ6TKjQnetI9P61Yf+z90kER1mgb7zOxxUlI6Cd08debLRYPWqTeJadNxGV1c+ML1WqVc/GXIvOTzQwtI5d2t7h+suHFG/Ejx47/BqNSTTT6sFB4Yu76te+CtFud4uKviCLvHJHaxEuR+bVY/DUajW18YuoDDMPo5FRWLBbXlxbmPl8PiZKy9kvl7ObaKydtWGMeRKIeHBr+39F8qOUKQfXHNzfW/rLuFSc2F4qBDkUUeUNEhot/J49EonRzOF0j7p4e2an74rHo4/uBvXnonrqvk1fiYRRvDeUb3sQOD3t/mZ9Ck5Bqrvv/B7SG2UjtmZRx+BYTBfjLlJ8CK3rbQEGLIF3P/944cpWC5lrSP21mTNS003ewEN/opxkanpudh5+96zYSe84Xh9EAe/EEDNrsjXh1vmAL/4DLDvHNNFjMNVCNpYqqvXVmEr75wgWgGQYC+YgvWc72WlQGTO5DACaeIF4IXTuayKetd3lOrXm09uwx++jGbGJ9FLvMP33lOnzojltApFqQ4jV06I0Q1+UgUcjBbiIOJo1WoLSgGleTf6makgJzIBRLJXKPOL6/z24lyoJwNk3qd5tqKfri6Sy8vrZBCPmwd8C4qT93vu/mtIZRQbSQVL0SmtOtIcBfpli6NmvSoEb3YtJpSV04/CFdyTOvBK9bcPWXwssWmiaIv9ZvbBX0Wg0MOO0QSaYhmc2BmlJRTwYu3rQY3ewrQ1mnolUNBwitWos7Uz0b8z94X//ZeTVLYw0vH/C3pU6EVg8Q/kHzOrY1luItJIKxJeW+2mlBJa+oz/WjYxPvpmlaK6feRCL+vVDwYBXE3eY6bmLFgHQXBn8pt1ahhYv8rjNHj79Xp9M/Ui8HPc+VtaXF+T+Fdku/4uKviCLvIBFJHyYXeDTc+9FcaZycPvKoRiuPzA+tp6l1/8pfCCyOfPAhRjAqFdcvNheKpqmdnJo5r1ZrjvOawiYT8c+GQ8FdaAccHedCZR5U5MeVDiz+nUIRW6z9KpXa7Bsde1RmKCL2blleWV78R5BP5tfJ2t9tPyLm4n8nmifO8spiU6nk5yOR8AG0Z9LoZPFXDBBvEVGAv0zpYrF8M8trDGIE+oXa7Op3dl96OJCLnqlU8VcUcNZofMEzCGg/fO40ArSc4Rer7xgw63RwkE5Cn8Xa4ABoVIZA8lCPC9b2D+rW9CYgN+t14PP0wmYwBCpaw1wKL07d6zmzUG8LPLl38cRscuM4nlE2V/eHfmHi4Vfu7z+3uZ8LOyPFtBWz6n/nlUvwnpvP1Ij8+A6AYnQIdVd7r8MJVwM7CLhTsBIKwvH+AaAaF/KlFkKAy8bKgUo9LABb8Yd6XcTaH06niWs/ZvPH4Py5a3PEIwBfOmYcyD06eFs6Ukgyz+1dMa6nA1o1g0A5zRLFx/RQHxz1DhHOgwrq02v+TYimM6QVapWGuhxbsSLQT26lUqmCx26Bk94RGOhxkIwAryysQjqfJ98tJDZ9gMql8dxK1TwYsIcC7hJMKKhjtNXrcf+JXKmAFRJl1A95La2OeE0Dm7066w76jE8MWRE5+C7mP3Xp9qxLsFOLxatKLai6weGRU0ajaVROe8rl0p5/ZekxkB8r15HFX8LSL5c1t2WhHfGNHrfZbL9evx7//rnA3u7H0WKbhM7adSWeThFFbmA5RFx/RxZ/3+j4bRaLfCbxg/29v0Eb/Q3oHNfficFfytovJBFrgH6n09Vjs9t/AXhrWKlUurS0OM+lDuuUwk8JdVLkzZJu40+Sfwj/jYD0vVqtrldORdVqNbex7v9cuVzGcY9SCrduXolyXPyFln7i4m8yma0uV88vQwuhX3lxeXH+myCefUrK61AZg28hUYC/QN5ogC8lhwD93GtbfD8Crmy0kBzGLP1AqwR5BSgIIZxwZXUdTo17WwC+XW+AtUgIotkMsajX1AJNgN/nsEGvzYrAPdO8jsKTEEvS5a3vHxC/9ZX0zti9cGYbfVvJVYvqq1H/NKOqKR4KUDZ9Ze3JM7808TPXPjhy39Lfrj5xsgQVbSKbg8cvXIJ3nz1JLOEdl2Wq1i4cpT/qdMJKOIyxMqyGQjDl7pG8DBP36bRqSBdq/HdYkYElWcxjZjzoNZsJb8HWQRiSuTxx8e/T2osI9GeuRld0z4eumnDnYtBfRueP9/fC2YlRVKYWm/BR+Syx5K8GDpp+9GzT8wCXd++pY6heJ+FZwE4aOLvB+kGopc24Dbifh1xOMOg08NryOlEQ1L0XNM/vXX2QpCAg5IW1/v+XwCVWz+gOHDrzok1jvXZP/6mXzbQeKwL4GyAGmqn+2tz932riX9ugt7c2pDaJ3Qj9yCsSR1/fwH0gT9FRDeztfbFQKCRAOq5fTh5coUgx5naycLWAf6fL5Ub38QlUBOe1UE0lE5/Z3Fifh+6WfoXIShFFblCRGdcvJPNrY/B3u3vGej2ee2VWS5jE19f8L0B7XL8QfMgl8+O3VdTaT9M04x0d/1WKoi2NhrBsZmd76/9BwAPXzye+VSyNirzpIuJpIwagO7L4u3t6xx0O51mZVbLRSPgbkXBoDaQZ/OWm7utE5idJqjk+OfVRNBbdvCaVgweBPy8WizkQ34tIKiGUMfjWETmELu8Y+djHP0HLAeR8tv5OzP3CNGXc+Z2uweJ0uYmLtjoW48AaiwaakNSvisGemlbFWKpaZ6Kvj3KWqmNFGq6ub8LGQailfFyI22yB3Xgc0qViC+jHggHmGQR0cUw8l8qOe+mxWgh5HsajyULWFCmmsKug8ULw+rSKYdRUvTQMflPVov3Fg6tDBkZT/lnvvUtaYIq4lky+AN944QK8vroB2WKxZu6WELYe0G/V6sGlN5DPMsUCBFKJ9nOhdhv4GoNOS4rF7yf6POS7cCpFznIbTSR932sra8RdX09rKu8duDPzxPZLpmcOrpgx/SB2+8f3+rPvuhXuPDoNWrWGhAJwNS1s7kE6XwBONUH6ja1Cn8MKH77rVhhwOUg/Eh9MmobnZxdr17PEbRt8PW54/+1n4ZFzp2F8wAPr+8Fm6kAuUyBTSz3IZRnA6Rr1GgNFqxhPrJy5Zy2z9xt/OffYl/584Wt/cy225oVW9386mVSRYnR6PceQL0vqzyjT4XtG+AzXrgEKj6FO5QrqIOd2AP2MGgmI58NtAf+jY5MPqFQqk5z7y2TSF3a2Ny9D58VUNpCWsMJ1WmBF3Vq1Op1ubHzqk/yFtpDPP3599uq3obNbq2jaHGWhVUSRG046uc2LzZEtoB+JEwHq9yFALcvoUywW/EsL838H7UziYmn7pMj8Du3iPzE186BWq72F1xQ2lUx+LrC3sw7Sc6Fi7VfkJyFSz7QQ9LcAf41GYxnx+h4hxE8yJJ/Pz/tXl78Hh3Px79ZeKc/DNlLNEd/oKYPB+BC/oFwu948b62vXoFXxpozBt5kowJ8nf/zpT8lKXcZXDhzWOwCf3+2aSDhEmPJLdntjAKFJQxi/TRbacVP/S9h1HCNcTJx31/FpODU6DA6TgRDcYVneCbSZQc1aHZi0WkKcV6pyt11jwMcVGtB3NEW1Xof+wMqAmaEBAlDVKjW1kFjvQ98Y5xObgxigYkDNl7n4+gAmKnNprYUPjtzjRyC7SOpB585tbsNjL74Kry6uQY6Q8LXG63NkfTVtB0tY/lV0jcR+L5mEbEmY0a52MRdXT/pbzYDP4yLWdZwa0KYzENJA/24QssUSRvhwf+9NuacClwxL6V0daQP6/24E9t997iTpB5ZXNn6fRYD/sn+9zpFQw6w6tQruO3kUzp85QQA6v8+wciMYTxDgb0e/ywfuvBnuPD4FVoMRipUSZAsFuGlqFI6ODNQ9ABww2t8LR4YG4fSYD86O+9CrF06MDMHMYB+4rSZyP6hPKJ0aPU0UNfFidO7jIHDvt1hIKkMqn8tBOp2S/ZzWn9FKt3ParwH2k5/8JCvnmnod1Q5x8WRxKpVKnDuocEPbcJ3r9fRNWqzWY3LujcSqrq3+fZ2gik+aKObm3xVId4j5k+tOR87Bm4Gjx078pkqlarjfVirl6/Nzs5+B9k2uVDydstAqosgNKBLWRjH+Ez7w4Nj7yStOH4YA9c+o1WqbnDrRXJle86/+ValUxCFG3fKGC5Wkct2L2+KK3e6ePofD0eJejNaB1xYXrn8DOrP4K15PirwpIjPERiqLRs04MT55n0ajdcqpD429zMba6v+qVCpp6ByO2InIUsrS3y2TBqNHiN/j6f914HmFozbtri4vfRY670eEhH5ElDH41hLF1V+m/Cju/1/7+tcPFV+NBweaYPBbvlt2m4s/8Ba7ezxnriwltu7Ps6VBHEM/0usmpHUnxoaJxTmeyUIilYFIOgUOk7lRFwahw3YnXN8PENf56Z7eGhFevUqa4uOxZkuwKmBioA9eXVol516NrvU5VdZykS1r8TXTg/0QSaYgEEsQyF5An+/mI9Z+rSPt1tnyvzj+Hv/jmy8O7RRCJqrejuXdPVjY2oEBtwMGnE7wIqCuRuA5hQAr5hXAvAS1eH+AMZcLFg4OMFKC9UgYjvcNNFP88Vqsw4Zi9GZ6YIC49+M0hrjtbpMJKATuL62uEZK/YxZfcSm1pVnN7GrwB3ajEc6fPQHYzb+RDpFtlkszFLw0v9zoH3zOxGAv3D4z2fi72Vk194O9UISQLN48OQZTQwMEtENd14I5GeyoTVjNcRKB+9ZrxZ8T7EGAQxAuLK6APxAk91WuFAfr5I9il7DY4l9Pj/djSzelwI8g3EPWbUPblr4PE+UMDY88KDcdVTQS/mYykQhA98W0KxutCC+BnE2u2GaXPnrs5Id0Ov3DXF+w1Wp4Y33t93O5rFSeaklLP75eWWgVUeTGEBmEYl1ZxKEW138HWgcmZFZbDR7s/y2aL7GFnQP9UllP5Lr4i/GbtChB1Wq1xusb+000nTc2K5hBfHtr408FLv6d4oo78rEooshhpJtxAjpnGyL7FOzib7c7zsisko2EQ1+LRiObIG7t75RxiBOxrAOdUgm3pO+bnJr5ebSf5KdEroRDwT9LpZIxkFa+HSrtsSI/PVGA/yFFsAh3lKnpIz9udR1BPzrKaFEs3eI88tTTwdd/IVMoUBcX/XBuegxq5P8AFoMeHQbiMi7AxwS8jthtCEBHwR8JwYS7hwDVegY/oIR+Ajx1hK+vB9b3Q5ApZFT+zLYLKw2wouG4b4goG/YuXql5D7BVmE9t9CHg78fXvbB/1bmV3Tc1rOJ1PgL8934sAYFIHAHaZQT49dBjtxALeK/dSggJiWVdpQYPAsrBTBpKlSrsxGMwYLOjZlUbDcRNxMSEGByPDfSimY6GKGoTVgYY1BrY3AsSK7yB0bIVtkotJ3fVuIM8qK7zN52ABrGBkPgQHXvhOGkjVgDgv+87eQSGet2EFLHNPaJ+vRqB/n99923EG4KAfqpZBZeIsOnrQDWulQrKx2VgvQCnfKii0lxqyw8qxPVD9Pk5lMX/JyUS7NRSDLnCuH5y+EbH7tBotG459RULhVX/6so/Q/smVorQTxJIy0zbJ7XItrjUjY1PnrNYLf8BGk8QWwyFgh872A/sQHftuhLPqogiN750YuTuSubncveM9fT23iWzLhatF8+vr60+B93J/ORY+7vNgw1L49T00Q+pNZqT/LYk4rG/2A/sbUEr4Og2ZytzoCJvpHTyXukI+rFxYmTE9+5DuPjP+VeX8T5FyjghFVojbCt//An5kiT3I17f2Gmj0fQeQZueQG16GQ63F1HG4FtUFOAvQ0TAvizwf+GVV2h0bVv4gMyNOStyiIL/k86J5bnE+kKwlDwyt7UDWo0aTozWLP5U3XLMCnSB2NKOQadNbwCHIU9y2+/EYjBot3duUV0wR8DGfhjVpaM28xEL7pBhj5uAXLcFAXarBQ7iSWK5Dubj1q3sgWXY0Jsu0xU1Vc88oFGrELC3gcWgA5w+T4XAP3a1rxnKKdJGo7aWvo/EudfvZdDmgHi+RtS3n0qBw2gkCgGKd4N2swnMOj1YDXoolEqQK5dgCNWFrf2zm9sENOeqRWo+tanGIN6K+uEhBPq58ALu34b9vk6wd2nFD9jJfsjphtuPTIIWp0usiisKamVQMOB21s249X9awuP5/Apsy+dsK1tj43McqrC0E4Cl3QD5QEMxT3509KG/YmvpG0Tjvd5Ii/+bIHII/dpI/axW24DT5b5FTgVYQbazs/XFSqWMLehSqahkbSAPkbZPbIFVA4/B39PXP9LT6/k4KoZL7VNNJpN/trqydJHXrk7adSWuXxFFblB5I3KGa7U6m8839jNy4/pxxpPlpYUv1sOhpOL6xeYhAGmA1M3SSA8Nj0ybLZaPAG/BKxQKTy8uzP0THA70E1HmQkV+XOnC3yPHxV8/OjZ+l0YrzzhRrVazG+v+v8Gu/tCd0E/MK1EqJIgD9h09btA+0dLr6fsNELr4ryz+f2g+4Cv9Orn5K2PwLS4K8O8iIm52Yq+iMj01CQf7Ac4FmeWV2XIeNzg6eBO0kPpBE/w3Bt+jQ3c+9cXVJ3wVitJfXl1HYLcM56ZGidu/mHDWfPz1sN0BifweBDMZEtNur5PotV/TvAm3zQLlSpUA9RIC1Ti93QnfcKO+W46Mw3cvvE4s4elSlkpAzoE+zgzq3en56IYdo3ts1T81NkI8EvjzFtUwd7cCXrae9w4D73G3C+YC+wTA+8NhONbXB1W2aUFXqxiYHuwjyo9INkvOcxiMJP1eOJkCmqkZmPG/Bo2GZBnA90DzaC9adCWo2PmNHZJy7wN3nCMhAfheWYDWKbdNwSJ8SHhgnq279DfvDjiPBarlfH47aLi+sQ2X0G+M3RwcGsu3fn70PJ6UC9BB84pAvyz+ip+UdIiZ6wT6G1p0Cj3n3tGx8zRNa+TUl04ln90P7OHUk5y1n8/i38l61bJ4dQH93cj8WhZZi8VqHfGO/hd0L1au/Hw+9/Xr1658HZobXNl5qn/av6kiiijyxonEXCPFIs7NkS1kfmhuMUxMTb9HrdHY5dSJN/dbm5ufzedyEWh18Rdu+vlzJSfC0KduKUy597TBYDT1Dwz9Fmovl80EA449/+rSn6FXvsKha7pVUOZCRd54+VHS9+nsDuew0+W6WWYdbDQa+Va0mTZTKuOQpIGH19ZO+xKxbBqEZ2hiauY/MAzTxyurHAoefCaZSERBPuhXxuBbXBRyP4FwTOOYdRwvvEPDXjLg0WuNVa49lpfW6fV8rXbjcwT6AdqtgeRa/9oGVx6ph1vk64z+fGkMJJWKsLSL5m23qA2pm3uO/7BcqbCEOG9rG567ttAoAIAHIduGJAujThd53YxFIV8utX5NtV9mMxlwIHINpNZj493WWlgeZkOwG03g7XUTYJvOZ4DRMJhxnT5i8cZtKgOe1BAAT8NzV+chkkrW3dY5dQTVBP0tdbP1cyjiITBotxHsjF369+IJoBuXUGDWaaHXZSO4OprLgFNfA+qLWzvEs4Cq16Vl1PCeW04TRQEtMRwwFMfu9d6+Hjh/00mw6A1EoUBwu5D5T+RqrgyWKArY+g9a0wjQdZd93LZEPo/6vlw/r7XDa/0M8MrSCgH91WqlOmrp+9IvjD30WdT/eHHolNqFtVptROOAn2d+ZgmxzBO8sSA8V5anCy6Tf40wC4BwQ6vV6ci4Qc83GUMIzJMFiWYYvIgKWfzJMTg4fMpoNHnltKdSqUT9/pWvQavlih8v1zUtnli7ofviKjwaLq1qtBOfmjnyB2iRbdxDqVS6cH326p/D4UE/EUW7rogiN5x0IvTjg3694CDAf3jEe9ZisU7LrIuNxaLf3g/sXofaXNkpJEpqnpSaEyU9nzDgmJo+8u/5cyEqsoQAx5/EY7EwtDOIdyU2VeZCRX5cOYS1X5R/CO1jDF7f6ENyPW0KhcKSf2X5CWh38RfuU4Qu/p1CbOTsSYjyDYH+e/V6fUuaz2w2803/6vIFkA45FOPWIKKMwbeuKMBfIBzT+EsvPkf+3t7awC9ULBqRcl9j8rmcmDsbw3vlx9mQ4+SJ42LxzVQkTFLvNZjZecKWy2Uh8ViLEuBm59TihHVoCZ/MUDRsBkPw5Wd+CNsHYYSmKAkVXA1MGzVqcBtrwH0lFCLM+C2nCARNaiSkgKpD2fG+XuIBQNXxLwbGUwP9Nb9EBLQThSxdpMo6/PfPjt63paM1Bfw+mcvBk5euw+LmXktGAGEaQarxX3Ou85gsoMdU8uiv/XQScqVSS/twnH8inyPtcmFSP/Tfyt5BQ6egVtHw6K2nQatSA5dDjxW5WZJKj2aIN0SlngGBB98bZwm7isYeBfXQBdyGTKkIcXS/4UwaAokEbEQjcD0QgOVQEELpNOjVahI6wN0pLz6AyD9fmiUZGli2Wp60DH3hfQN3YpZjWTHqiUScNHxs1FvlZ5bAz3uHscAKzu06kXNs/fxrMBmgyLUNQr9CPk/GAHq+iUtatVolm9pqpSKWk1qHXVf7BgbuERkjog94KHTw1WwmgzeQ/AVVyn2+ZTEV8cYR4yQQI6+SSlVFNrrHTpz8NQT+G5aAarWyvrK88LFioZCDwy2yiou/IorcYNIBdAjnFkkXf6vVNtjXP3A/yAxNLBTyiytLi4+BOJmf2BrTLa5fak5scfGfmJy+R28w8NOGsZlM5ksIcLwC4grQjmFZylyoyI8rIsS9nQj92iz9+HXEO3qLXm8YlFMfy7L5rY21z/NCEcXGnhwX/048IFKGCNrd0zvodDp/BXiYELVlaWlh/n+AeMhhR2u/Mgbf2qK4+ktLy0a/XCnTvL9pwSv/fCzkoVchEIfAjJgLDFsql7iBKtTaNeoUlse7ng/6W8D/IwO3Xv7CyhN9aTZvxeARu68/e30e/PtOuPPYFGGrb40bbwJWHAOfRLgD55PH4H+qt7ejww52kU/k8iQv/fRQf9tNuKxmAnqxC34wGsppTdNlBJUps8pQPu2cjL8Smu8ljUdg+pUVP6zsB+C+U8cRwNZI1svWLfXYSR/7G4y63HB9b4/UsxYOw9G+vjqfAfYKoGE3EQeTRosAKAP+3YMaeSEA4QR45JZTOACy+SOwTZ8Dqdr5bPv4hbPYl9E9YB6BfKkERdR/xUoZvS9DAX2G0yUSKE/6giUAH7cJ8yt4HXryXbV+ZyzL/6lrao58sQg/uHQV0vkCTj8Ye1fvyc+ddUzhTVEnwqWurPQ/DREj9EOLoyqXy0rF9rdZ+31j4/eoVGqLnPoK+fz8xpr/OWiP6+/k4i/m2g/QDvqFpDlSCyx/s0thBn90z+8HTrWDftPtra3fjcdifHe6Q7H4K6KIIjeGdGER59Kb8sOg+ICfgH5GpTKPjU8+StOMVk6dOKZ43b/6WbTZ56cP4+ZLMRd/OXH93ZSgdA8GHC7XrwEPcJRKpdcX5mY/D62eT7JS+CmAQ5E3UA6bvq+hADCaTAhLe+6UWQ8bj8f+KRQKrkLnuH6+0r9TO7uNwRbgr9FodF7f2O8IMmlkdne2P432ZSloHYOdFIDKfuRtIgrwF4jIRp9s8tHC2ObiDzxLPYgA9TqIE2qlyXsESDj0Leay01I3tGvsxQj/yKGi6OIHfXdf/Pu1J++tsCy2LhJguhOOwLdfugS3T0/AQI+zTu7XHp6OXf5xujxsPd+MRsHncLbxBJBK0WcWox4B/xz0O+2gVquIlb/Z+hoJnd1sJC79sUJSy7LE1k49GbjomUtsOvEfOG1fvpgHmlFBLJ2Dbz5/gZDmTdTj84VC8VuBitPQDPSZLRBIJSGPwHY4W3Prx/eN7h9ShSIMO2rhjesHIfK5QaeFh86cIMSBwk7n3yOnEsGAnCapDikSBoEP3D+YRwG/ZtGBlRf4HIZuPg41rwmWZBIwo7qMWg1YdXrSL/g7TslQbdTZ+vPjtm7uh+CFuSWiYNCwzNqHfef/0qE174K0RYa/QLyVJ+TGQoUWF/y3rNh+h9Pltdsdp+RUQOJVtza+hAlzoJ2gqhPol4qb67bA8hdVDYho1ienZu6xWK18Bv9CKHTwsd2dLT/IZ/BXWPwVUeTGlk7uxfw5krMwNtL24dexsYm7dXp9v8y62HAo+BVe+jAxHhQxryh+O8WymogBfh7g0OpGaoCjocRlq9XI5sbaHxWLxSx0T933Vl7fFHmbikwXf87bRpzQb3TiAYZh9HLqK5WK2/6VpW9Dq8JNytNG+LzLAf1SRghy3syR4z+vVqtneE1ik8nEX+1sby1Be9ihmNJNcfF/m4kC/HkikaKLDKhioSAcVHz3fSH4JwOzUsupxwfnwvdCq6xwwLQoF2iaxgoI4NchKIcMSKfGkrp/7NbISzuv92QK+doNIbCZLxXh6WtzcHRkEE6Pj9QhbavlH7ua91utxBU9ikC0CQFWp8HYaBCXDQCDVCNJsQfg63G3g3S2phzoQWVh4B8qJDA1P3OQj+qvRdccjIohlnk1qIrvGrh575nAa4MsRakwwv3hwjJsBsNwz6kj/Kh/aNV/UA1wPmCzkfR+GHzvxhLgRu3F34XTaVBh/gHUTvzddigMFqMB3n3TyZpXAedOX89fiC3yGGxja32mWCSgHns/YCs+eV+pkDABhuIHHbAE8FMMTe4Xh1hgkK/TqNGrDowI9ANF1YF+sw+h7U6g2R504EwEryyuwsZ+iLTLzBivf8T34N9oGTWOBeG0wkKLjJRlmMhPe0LuQOgntGSRTS0m8EN91dCk45i5Ea/vQQo/JzIklUw8HQoerEJ317lORDkA8hbXjlp1fPhGx087Xe7fg+a8W00kEp9ZXV7ix9AdhkDnp/6bKqKIIm+cHJJFnJsbW0C/u6d3As0zcgnFIJfLvl5PHyaWM1yMzE+4VznMvNjYP00fOfpzCHAc5ZVTikTCfxo82OfSmHay9iuAQ5E3XCQMf2Ju82KWfnL09Q/g7BRTcupD+5vy7s72F4rFYgKa409I5tdp7AnbKcfFvzEOxyem7jCaTO+D1kwaTy3MzT4G4uOvo/JNGYNvD1GAf7uILroqJFwMMrTG7wvBPyd8UC90za8yDIMVA2Iu2ZLgHwEfmgf8gXd+NVhKOF8PLZwK5hNjsULKU4aKBselYyDbxJk1VvyF7V1MeAZnJkcJiG0WVYPZvSYTxLJZAni3Y1Himo6t1gT08+4QW+sxsR5O4yfajeh/m7GRIYAK5qO6a1G/GSswuLvMlHOaWD5F/+LYo9e+v3PBu5sLORhGBbvRGHz12ZfhXUemSfnkvnkuCk1H+Box3pDdBuuRKJSrZZKa0K7XQxTdA071hy9d3d0Ht80M5286gdqtJiXgZhTLZUgVCpBDQD9TPwi7PwLw3L3WmPkRqMccBHUOgzI6B3sbGDVaokTAKQdNGg0hCcSZDDilBKE/rP8ANRJ/oQqj3fEjmc3BlbVNCERihKtAz2hCDw/d/hgC/TH0NbaEyHUHeytaQ6RSzQgtWTr0vLUsrINDI6flxsyh5zvi9698Azpr0OX01WE06kIrf2OOGBr2Tnv6+j+FlRncD5/NZj4/N3v1Mejs0irZPmWRVUSRG0e6uPhLgY6WuH6NRmv1ekcfkZszvFqtJNdWV/5GJHVfJ+4YTjoRnEpZGUlc/9j45K0mk/lDwDOWoPnwy8tLC8+CfMCvAA5F3gzplHGoE6Ef2iqrzQODw/eDTP60dCr1L3u7O7PQTjws1zjRjVdDuDdp7El6ejyD7p6e/xN4OBDtmzZWlhY+w8ukobj434CiAP+6dIjlJQMKG3NBPB2GGPjnDwb+oG0MmjroJ5/TDMNWm3+LadNJHeVymd82TqpptmD9wsoTv4mAIUPQKjqbqjCYHh30CJTieHbs3m4x6MGIXrFVGqNQDKaZBqFe07Edy7jLBfP7+yQ+H5PPHfP0kfLwNdh7AJ+Jy3GYTKBTq0Xd8rE4rGaooO9UCMzvZEL6xcSmlSPtJ3RvqIwr8ZW+23qO7XzYd9/VtfSe9aX9WV+wmLCVUWOevnYdPDs2uH1mkqT9Y1ta2bT6Y6+E/XgCCqgbsaVfje4Lx9q7jSZCGhjNpOHuE0dAq9aQ8ARMKhjNZck5NN3cb5HOppsZGPF9kX5UafCuiig7DFgRgnkDiJUfGueS9lTrr2yVxP0nsllMTw92s6lBDMid3ayx2f+lSpkoHcY8PRCOJaFYqUKuWnT//doP/q/7+89+4qR17AB4mzOaplE1VanFodG6enYKFrPryyHpwyJ17mHKEIwvsY0tGVeYyR/dhwanc+JZ+RsLqlansyPgfJfM6thQ8OBruWw2CuI5qIUL6hsB+iW16n39A77BwaFPo3trxNAVC4Xvz169whHnSKWqktzsKhtdRRS5IaUT6Bdj8Tfw3uvHJ6fOy03dh4QNBg/+PpGI70Er6OdnPOmUuk8umV9LuJPL3dPn7un9beDtP0ul0qWFudnPgTTYeLuEsCnyNhUJQr9u6TO5fQp57/WN3aHRaJxy6kNb/rB/dRlnG5Ly4OyWQaOTpb+ji79erzd6R8d+ryXMhmWzgb2d/5JMJuIgDfglsx8pe5K3jyjAH2pAJhIO0eFwCOqs+li4Ra0+8FkykHDe8HquWU2dfVyNBozQ7Z8Mhpq1nSULFrqOKAHQNW2aMx7orykCaIZgR6puJEbfY2u/qs4zwNckknq2U0E7AuHERI3J+86MDYPdYiKWaJy6Dn9G0RwohVZuP4FwH2Ow63M6CejHye+WgkE46vFgtwMCdnERUyP94HFa21zXGwWxOO2fEcc8AKVm4KXQnKtCsXX6fH7mekr93P7l3gf6zq2Omvr3R8f7d5cyO8PPBF4/WqgUVKF4Er714itw3DcCZydHiQWfuwWuvbhNAw4H+FF7sRU/iMC/Ta8jMfcFBO4dCHiHMxl0P6H6RbUr6boFnmVrMfZ6tYp4N2BlBnbXN6lrYB97FbB1br9GbH4LQUJrh1Ik3p8mx+MXLoPdZICxPg8M9zhJuAFWoFRZPpNALYRChX97NEX32KxwaswLryytkvPUjFqznQ4PIuCPSf0aFhn+86RSq1mjwYifD/JIpdMpnB6SMvBCNSSAPM2x+3Ogvgu4pz728U9Qn/zkJxvM/Z3O59JivvzyS8yZM2cYtNHEpHtkzCDB4weDfqKVRu9bFtW6u7/WNzp+l0qlMoMMQWUvbKz7nwdxC5YwF66cmH45oF8D7Yss7Xb39I94R/8YjZvGZqBcLr02d/3apyuVMr9Nndzp3qreG4ooosgbIIeMKxZl8e8fGDxms9mPy60zl81eXvevPgutwEPK2ngY0CFl6Sdx/Wgu/09oP9NQTqC5/2BjbfVThUJBKq6fm69FQZACOBR5A+WwYTYNFn+r1dZ3iBAbNniw/+VstpFtSMipIcfS3y2dsNADkbxiLDF95Pivov3UJL89iXj8v21tblwHJZPGDS8K8IcacEELbxUNWiFzf2NQISBFBg62SkJz8HPv+ZZ/Xig327D0VzH1fesAErPs1RQB1YpwcNF10M9PCcgJO2zxhKrbCIbSLGXRa8Hr6SEWduA1BqrQZI3ngVcOcAoFf4Zj1DFx3kEqBUUEJNcjERhzuYk1G7cKg1SHxUyAaVsZdZp8DJr1Oi1JZ1eBagP0m3Q6yBYLdS94Fq5GVofv6D3p19MaPAFWpoyDSy6vLfyPW8/fmSpktTQqZ25zB7aCYbjv9FHivcCx99dmaRbsOj1oaBWxzMfzOXDrjbAXT0Aom0E/QAWofKUWb4/+wx1oROfhGHwticfXEnd9DODx91Rdc8FCk9eAoiQ0Jmxrz3H/Ys8Im9EI58Z9cNG/AZf8a/Dq8iqoVSoYdDuh326DHrsFTHotyVJAaqNrGQdyhSLsRKKNokulUvKYdRjHgottzsizkkgkoFwqNf7G10XCITYCIWzxJ5tLsQman9JPZuo+9o8//Sl8gPA6KQUATos5ONCPF7sqb6zgcSVcVFvi5TDotzucw4cg9CvtbG/+HWapBumsBz+Oe78caz/Z5KJ2u0bHJ/8YLbQermB0v/7lpcXfz+WyGegczy/pTqcssooocuPIIV38+YCjYe3X6w3OwaGR8yAzdR+aH5Nr/pXPo/lSCPo7zZWcHMbS32LtnzlyDBOJ8ZQTbCEUPPijUCgYgO5x/W2ZapS5UJE3Qg7BrSF08W8YKLy+sQexYVBOfblc7urGuv9FaPe06eZSD7z2SY3BTh6I9PTM0feiCeMBfnvyudzjC/Ozj0P7GJQK91EyabyNRQH+PMEgCVpd9jtp/LhBzykAGum6oNXdnxswZYmjAuLKALGUOVw7+OCfNVGaqEVj2M5VSiORZAqeeX0O7jmJ3dq55vCk85/1EoHzwyfEeTgGPlsqQgyB6WA6BS5sQa6ZvoEY8FvwcKsqoYIAv9NsIm74DSpB9M99Z47CZiAIV9e3iXUcAXv1SwfX+u/vOzvH9YNTZdp978DtT31/99Vz4ULCjbkB0vk8PPbDi3Da54WTmKCwCg0LPo7Nn+x1QyCRRB1FEzK+RCFP3PUxyMcp9LAVH78nIB9aifZq75tp9Ug8Pg6JgCYBH5/joIPjRPMM9P/U8AAh/3sdgX+Ok2DrIIyOEGAdD1YEOC2mOmdCFWKZLAL+BcAEiKVyqWLTmF591/C5z3lNfZh1WZL0xWa1sqVSib94NQQBb9JctMA1PvtRJ+xOSgHhdzIWVGHcaktcP15QR7y+++US+qVTqWcPDvaXodVlVU4eak7E2noYaz/Z5JotFuvE5PSnGYYZ4QrGlq3NjbX/GI9FI9C6qErF8ynWLUUUeWdIt/lRzNJIwD+aGw3jE5MPqVQqk8y62FDo4Kt1F38pvphO86RUO6XS9hHAgebDu4wm0weB56iXSqX+p391+RX4ETyflLlQkTdB5GTSaEndBzVvm6Po2R6VUwHaB+Q21/1f4indhNmGOqXN5F553sgdY/pbwg69vrGbrDb7L/HKwinH5xbmr/+/OAsSyHPxV7wP3+aiAP9WEWP1F8vdqVvPHoz88/ar/7YMJadRrU+ZVYaNcfPAzinHRKBu6cciBfzFNvzdrH5Y+JNRI6wASeX2nuPfeGrntV+nVLQuiIDvdy5cgtuPTEC/09kCxdut+yLQlecKj93Zx91umA3sERC8FYs1yP74yJejs6MENeD4fqMezY/xROO8494hsOj1cHLMh8B5FZZ39wnQXk7vjNwPZ69CM76QdWtt+x8dPf+9F4PXjr0WWTwFFM1gboGrm1uwFQnD+dMnSCpBrmYNo4JCuQwugwHsRiO4KpiDQIU+V7ekJcTKgBqwb5ANAP+GSJhGrXNr94bq5IX+C7tJZAqse1RQNfA/OdAHI70ueP7aAhyg34f0ElZ40DSJ69+Px+uZEKo4nqRoUmsPHBrLxXP9R58dMfWsQY3UTyy1S6NCth20NiZok8lMp9OpFmbIH1UJwA8NEPlOyuW/25gSWvuJYq1/YOiYwWAcARlSqVQSa2tthH5SWnSpDW030C/UoreBftRe0/TMsU/xXenQc5QM7O387n5gbxO6W7YUBn9FFHkHyI/J4k+OgcHhk2aLVRaLOJZ8Lje7trryNPxoLv5ylaF88E97PP0jLncrkRhmD5+/fu0foH0uFKYPVACHIm+aCMag0JLeNbZfo9GYEfC/D+R527DxeOy70WhkA+SRacoJseEyInUKOyRkfp6+/t9Fe9uGV0I9feYncrlsCg6nfCOi7EnenqIAf55YrTYqkYgLCT6EkwAZ/C8Frp7Psfl78dfxUgaSpewdm5l99pnA5ZxVYwo4NeadIQTYbnJPb7IVFg9sPugvSbwXUwbwJwCuLQ3Xufpn7HHr6GqmmP/qK+G5jyBAqcmXyvD01QUY9/TALTMTLZZqUWkB8fW3das3JpubcvfAQvCAxMSvhEJwxOMhbvWNszFA5rvCN+LeqyRenqqz/FfKVTjhG4Ka5bsKZyZ8EEmmERhOQL5cMl2JLntOOSb90HRhx4Wo7uw5ca3f4Io8Fbh8a7aas+Dy4ukcfPPFV+GRW06D1WAgbcEhCRj4Y34CFQLVWoYhLve1dHqUBD5vJdirWepr6f1wekH8H+b/+xfUnxqVCo6MDBAvBqw8YCWmPU7ZQgGnWEAPDeqH82dPwusrazC7uYN+PBrQPe3OmIcvV4AtIaBYsastewNGxxZ6ZjDBCt6Y8QF/ixu/4DllW9M3tLqIlytl4a/N13YcVgkgy+LfIX0f9wyT8VQn9BMyVaPHRmPpHxi4B2QuqNFI+JuZdBqTdEhlPOgE+rl+kxu7Ksrgr9Xq9EeOnfgDtVp9gte0fCh08LHNjXV+/JzslH0yfxNFFFHkbSRdXPz5wF8yrt9gNLoGBgfvB/ku/tn1df8XBCz+cmOLO7n4SxKJYUXosNf3+2iet3IFVSqV5eWl+T9Fr2Ls4WLej4oSVJE3XEQI/cQs6d0I/d6F9io2OfWVSqXdtdXl74B80M+XTnOEWFx/A/QbjSaLd3TsYzRN89rJFkOh4B8d7Ae6GSOUTBo3mCjAvykY9PM54zq63rFQJQz6DXZ5ApIRRKYpQ6qSHUvlsmP+bODufwlcKlnUlgOTWhceNQ8s3eyeXqZYCgO6ksyDP/gAWl3+GV47q7e6j1y1aYy5pwKvfajEVt14eK7u78N6MASnfSMw7R2oueaL3r3IW2L1rlHwYdd4n8NJ4vwx+F84OIDjfX01aEtAP583oPkPIbmrZwHA//s8bsI/UK02fQTOTY/Cd16+hK3f1Euh+TMI+K9CcwNA1V/ZUVP/3kdHnc98fuWJ8yWoGDCgxh4FT16ehQ/dcTMB6jgtn7HOvo/L9+/tk3vGhHqYiLBSaeKpZnpCES+Ihv6i1geYUNBjs8LF1TVYRWVajXpixZ8c6idZAxohB2zzumbJfIUCwInRERI+gd39dzPh/nHL4Pxp2/gVqKfqQ6Afv3KbMTFWZf7mq/FZuVwWs46Q9/lcTpg3kM/8f1glAF1vk6R0yIfLB/1ShFUkhGbEN3obWlBlMVQXi8X1Nf8qtmKJ5aEWWpDeKNDPD/FhENjXHDtx8vc0Gg2f4KcUi0b/aHV56WUQt2x1jJ8DZYFVRJEbWaTmHaF7cVvqMOziPzY++RDDqAwy62Kj0ci3YtEI3uiLufhL5Q3n5vJODOJiB4NTEE8fOfprKpVqotEIlo1vb23+YSqZjEO7AaSbi78C+hV5o+WwHjeNw2qzDTicrrMy66nuB/b+Hu1VktCd0E8srr9biI0o6EdjT4PG4G+jV34oAptKpT67uiK6L5HyQOxEhqzI20gU4C8Qu91Bl0olMrDQAKWrbJWpVioMZu7nsferevWu3VAyTcy6HrsFzt90EqLJNASiMYhlMrAXjkI6XwA05tQZNj+YKeYG98OxUxdCsxmvqX/2gf6zrxgZHfZ/bww6iqKreaqk1VYZzPQppglk6VruOYS1WdIO9Nri9j9tHdmesXn/+ns7L9+xmNg+h5qnw2nkLq6uw2sItI729cKQ0wnDvS6Sxk4qDR8nNct/DQg79AbImAoQSqfJd5jpf6bX03BnZ+vGXs6yzu0WVCqmRqqH6hr39Dbq5NQEmHHfY7dCMJGCQrVofzk0573NffQ6NMElB6sZPaNNPzJ8x2uPb71wRxX1AQbuWdTPYXSt02qGLAL+dsyaj0MHtgJwyb9OlA/lSgX0GjVMDfaDz9NDwg9kmUi4+6GqCOT3wWYoBOh3hxSq87J/Ay4u+WEI9SW+L0zYh1n8K5xCQcS9QEXSDJYbfvlYi7KdCXoQ8O+2ADQmfdR/Ghz/j9VMLFvFxI8VNKmzhUKRZRhayFhPXnU6He6DKnqlIpFo1elwVNUaDeRy2Uo+lxPTLsPU9BHq69/8R+p973sfX0kgemec4DAA/JpMxOlcLkfhzALFQgGPKQa9F3OfI5tadCs6VLABPc9oU0sZTCZTr8vlksuQWw3s7Xy5UikLCf24/pTizRAuqp0W1o65qdHmW338xOnf0mp1d/Ee/WoymfhvC/PXvw/iSj0lbZ8iirwDRcQbSsq9mAP9euExODh8ymy2TMits1AorPpXlr8H7aCfr2AWUzJzr91yhbeR+U0fOfZ+nU5/nteMUjQS/uO93W3s1dfN80mxMirypsmPQejHKd70Xu/YAzgVsZz6spnMqzvbm5fhcNZ+4fiTw+DfMg6PHDvxc2hfchu/LYV8/gdzs1eFYTalDm1RPG5uIFGAf1MIqInFohzIxA89SY0GtdR8LQvf3QOnNy+HF1idVk+VyxVygd1kJAcWDPAyhQKs7uzD4s4epHM5nLsMx4obN3MHt/7PlW/fNGYenH9k4NYX1cBkMtWc+n8tf/cXcpWC3awx7Z+1Tz52i+sIP96dDMZqtSWJHGcZ4NynsVQxs/m7B2599a6+0/6ndy+e9ad3Zygao2+A9f0grAWCUJ2tQq/NCkMuF1EC4HRzJGVd3RJfq6GVuA+/HbI7IFcqQRoB7Dx6XQ2HYAIz/YuSBtas5VqVingJYMXAiMdNCP9Y3vcIKcPJUS88+fp14pa/lTsYvQ2OXoMm8OdIF0k/eA09+zaNKRYtpFwcwi4TF/8icem3aHWE2A+z6HNx+jiWHqf1u7axBa/7N8Fk0MH0QB9MDHlq6Q67qAEw6z6u6r5Tx+DJS7MQIcoPQkoIu+EYbIcipIQhBP4dJhMYEdDGbP0qtYoQ+GHSRcy9cBBLACYoxBkRuPALg84gBKhiln1V/VnECpsyWyVZEir176pl9BAi0F/lnddy5PN58poulVicxQADcl6/cmCeH1LCLi3Os26nrfrSi8+RxsiZ7HHsf31BrfDK5kSUsIqk8GNZLdvY5LLqYa/vbppmtHIGLl5Q93Z38FjplIdaKhc1v5/FNt/ChbXNxR89W8zxk6d+RafXP8Qrs5rJpP/6+rUrXwFpq5aStk8RRd7ZIgb6xQBHC5O/wWBw9g8O3gsyXfwxcdf21sbnK5UyXrjEvKLkpu6TDfq9vrGTVqvtl3ltZNGc+LdoXfkX6M5zImrtV0SRN0GkFG8drf11Qj+fnApwlqGNDf8/8EJsuindxMafVHiNGOgn505OzdxvMpn/FbSS+c0vLsx9BrVJLMym0xgkooD+t78owF+mCHLV0wjSZa06836BLfdH01kSB1+lKo3hgcGtVqWGI95BODk2ApFUGha392Bpdw9oFhPFqdRrqb2Tf738He+7B255tlgulRGqd+hVOihXy30vBK/9SrScevJhzy18a6GYNpA/EbSAOAOtzfzM0J0XY8X05kvh2aOLsa1BFRKclo6hGAilUhBGgPTS6hrJAOC2WaDXaiUWeIfFBHqtBjgWen4/YLK/uUAASgh3phCI3YxFYcThrBPm8fqs3hi3zQwMTYHP00tY6/nfclQAHqcNAfCaNTySS/ZAE4hy0mIdVVF0mVALAEtS9ZmNOkgX8iSOHv8Wz169TrqDrRfBonNw2xkE8rH+BbPmX1pdh6WdAAHr3l43WE16zNQi4QVRU4jgEILzZ4/Dayvr4N89aJIa1sM+dsIxcrB1t37uOtwm7pdR11Mt4vYYVZrwWdvE8/xnC1rdPVmRz/kxkFWJoyLyviLxfQvgF/R7owOk0gFKiNA9VE7cHDlcLrfPYrHOyBuX1dzm5vpXBQy53Vz8u5HldHOha4B+9Lszx0+c/iWDwfh+3j2zuVzua9euXP5cvQ1ibLmKVl0RRd6B0oH7RMq9uCWuHx+j45Pn0VpmlFklm0jEvx+sZTuRsjY2vAqhM+joFtdPznG63B5PXz+O628ob0vF4vNzs1f/GuSDfmU+VORNkS7Wfm7vJaV806s1mH9ItuKNjcei343HYrsgDvrlKt2kMg2IkgwPDY/MoHH46/VriCCwH95Y9//fmUwahxsI9yZd0wkrY/DGEAX4S0uLOzBheW8FwOyA3v3qWm7//djK7N/dh5E+d9vFGA5isIvJ526ZGoezEz54eX4F1gIHxFpcYMvWx3deevjWnqOzNMM0rOxqlZpGQP28idHn3+U+cRHEtfJYhBMC3/pPBqtdY0q9p/+22Yf7b928Gl0d2M2FXNu5sK1YLpFphWYoYiHfi8YhgA4M9DExHvYCGHQ5YXpogLiwU1QzM8CMxwPz+wEoI5AczqQJ6V2f2SJqTnVazEQJ4nW72r6tJ88jHgEudN4+toiXs6YSVdWpWboErRMP2RCgdlRjhaSNa43dbAKjVgfFShnMOj1c8W9AEKcPxGAbXaWnVbFbe49dROC7EszFnLv54PBBLt6jYdR0pliAhe09mN/eIV4BvVYLjKB2evt7SWgADpPg7plrsYpWwW3TE1AqlWEzGCb94tHbszpQp6L5pDFcjBvUjIbG9bNsnSUAkwBUKRJeUa6UEPhXFyatw1fP9597gWKpFDRj34VEjvyJXsxSLAX+KzKOKohrdyleO1qUAt3AfweGXCFBpjB2lUvfpxsa9t6HAbWcQZpIJH4Qi0a24PBx/XLiVqUY/Bug/9iJUz9nNJn+N155bKGQ/y4C/X8ukR5HlmVLWWAVUeTGExEyMSl2bkkmf5zpxHIIFv9yuRTwryx9C1pd/IXAXzjfS7WxK5mfTqfTj45N/Ge0njY2RJVKZX15efHT5XI5Dwp7uCI/RelCqtkpfV+D0M/nG7tDLv9QqVTaW/OvPAHy+Yc4OYynTQvod7nc/QODw/8ZhyNwhaH9SD54sP9JdGyBtPKtI7+GIjeGKMC/VaSIz6r1FH0tg+CO3lNXVvzf+RmGUTOzm9swNsC3aAulZkzF7v7vOjFNvACeu7YA8UwGFcpqLgTnb+LOMuq1kMrm0bk0dTmy9B6H1lo+ahnB2no+s3tVkEtOSJzGEf817gNB99Jpx0TIUrY6i1EWdmIHPMt0TeGAnfCxVduk14HZaEDgV0Os9U0qvppgwr7Jnl4E/vcJ8A0kEjXgbDRx1HnAzauYgM9pNsKg2wHC7uHAO8bX2D0eqASoaRWzmth2z1hGUiK/C7ufj1oLbFnLUDVuu8n+PgLQsXIhlsrA8k6goaTQUkzy34w99E9mRp8iJ9thA72+nixnLa8FF0bXMoHxaDllR9fSWK+DU+0F40l4ZckPTqsJvD1u8DjtYDHoQa1iiDcA2rxANJmBYqlUN+qzEMsmVb8y9f4F/LtUoMqsJ/cM4WLCECukdflqUYt6rkxTTNbAaDIz9pG9AYM7hJ6qTN0lgUuPwP2O3AZQOBl3A/1CMF+RuFYIPoWa3gZhpKD/yXuZlv+WRRU99yq0+euWE1c7MDh0XG8wDMoZrJVyOYwW1MehtpBKWbHEFq9Omn4pN7oWIj98zdFjJ3/WbLZ8lDfOoFgsPDN79cqfVCpl4eIulaNXAf2KKPLOEilrfyfAQQ6tVmcbHBqSzeKPpLK3u/ulQqGAifTEUvcJFZAA4t5acrhOMJkfM3P0+K+q1epjXAPQ3im1t7vzh4l4LAKdyfwUK6MiPynplklDLMVwjdDPaus7DKHfwUHgy8ViEfN5deMfEu5R5KYTbjFImExmy+j45B/wFW+4/EQ8/udov3QR2q38ssIOlXF444gC/KVF6HrbBrAcGmPcpbWux0qZ8WgqTWK4cXx3Q+qO0zUIzDZKxQDTrNfDe2+9CX5w6SocIKCJ8R+xDSNgec/JGVje3ofl3QDmBFA9Gbj48IihN21S6bB7Dhmgr8QWbr0cXjqBvdLR58GT9rFLp+wT69Bu/ecmOHY5teN64eDqZKKUMTA00/BgwG7+2MLPEHZ6Ftx2C4z29IDbYaux47O1LhDuNLSMCibdPbAcCpKUdduxKHHXt+v0tcxydXJ8fP3EQB9URKYNLu0ddtdniWUcx+MzkCymjdAag80dcCWyMsRgNwWsqKjgsj3kJA0C5i+vb0IJaxHQd+VqqfrQwG1PIdAfAYEl3aIylO/rvyl9H8BSuJBwojJHV5LbQ5lK3oQt+hQqPpbKQiy9CVX/ek0pwtb2RVW25vJP000vALfeHueeD/RNZdwymB+HQa5ebnLnJtoi1MIJ1Lz7436zblZ64QQtBv6FgJ8/wZc6fCZUAnDSGp8hof3tRFiFQH8npmpyqFRqs6dvgE+O13F8hsOhb+VzuRhIu/hLaawPC/r56XLIuUePnXifxWr9d9D0rsGurD+cm736SQT+s9DZlVVJU6WIIu8wkUEmxk/fx3fz57n4T9yH5kmL3Doz6fRLO9ubl6DdxZ/vZnyY1H2SoB9qZH4f0OsNj/DKKcdi0f+6vbWxCOLpirsqQhVR5I0SmaSa/ExDLeE2hNDPRwj9NHLqy+WyV7Y3NzDYPiyvhhzOoTa+IbVao52eOfqfVCrVGK8sNpvNfGVhfvZx6E7mJ9oeZV9yY4kC/AVitdqgntavBfSjgc5Wq9U2YDVo8MzFE/5x7Aq/sLULdx6dboYENFK7iQt2qX/wphPwnQuXIJ7JES//qYF+sOCwgJlxSOXyEIjFMTA2fGf7xfs+4nvgWVzvVibo+mFg9o46wz/EymnLU3uXxuLF9HP39J7GpHgt4D9eyli+t/3ymb1cqJdhNBS2lGOg34sAvlpV0w30220I8NvAZtJDzUpfrSsp2I73gFPnjblcsILAP/YC2AxHgHG7wazVAZ8Z0GWzCJbxpkcAPx6+Fi9P6m3mp291G6f2cuEB3Cx8nq/PTe6hjNq7G4xBKJFqlD5k6lmcto5sQHNzw90K50ZO+smltSYe6D+7gI41VLb7cnh5aDcXdqTLWa1arUYn04SYkK5fxnLcBOjAIRJ2rSHzUP/NfuApJ3hthzJVVV2P+B2xfFI3ZPZExq0DB0TP0wr4NcC32NMUcyWy7FlN7Y6g63rQ81W9s/fU85PmwXXobPHnP598YM8/ioL3Kt7f/HtoeVyhNeVfJ6v/YTa2jWN4xHtWo9E45IxTBK7XNtbXMOugmOvcYRlyuY2rmFt/G2HOzNHjj1pt9l/lPUfYne/i3Ny1j+VyuTRIL65i7Wr4wCiLqyKK3JjSIb2pFIt/i6UfHz09nnGbzX5cbp3VSiXh9y9j5m4pFv9OoL+baz9fGUrmT9/o+FmbzfbvgOdpiADH3y3OX/9nkJcnXFGEKvKTksMy+ZM9Sl8/IfQblVMBdq3f2tz4hzr/kBToF9uj8PeGYmSDYmn7MMmw6ujxE/9eo9We47ejWCy+ODd79b/XQw/Fwg+VdMLvMFGAf13ww+1f26C2tzZErfw41R7UWNRb3KVPOEZXXo8sVVUqNe0PBEkcv4rh8AA/qZ2EoFPec+40fOfV10lVR7wDmD+eWN7vPXEEvv7iK4Sxfj8XG3w1unjyZsf06quh+WMqFUNh8HtkaAC2w2FIQYG6HF25W8/oqre4ZtagPpklSmnr36587zxLU6hZamKZxwR45yZ8UCiXwG4yQ6/dCpxPAj/PfcdG86j+MYv+mNMFa5Ewiav3h0Iw2dsDRnWTlB2z2DcuIJfXbeXVWsQCDjGIp7Pke5wlwaW3YwTPQCvwp9OVvCmUSzjwPWDFyTHvUC0bAVuF2fUtEmpRmzWr+Yf6b3kBmhsMvis9P4a9ZaPRr3el+odcfoqidoK5mGktFbCE8lFDrJjRF9gig7qxinqxSLMUa9WYcsedYxGvqS+OJtUyr2xSXqgQN/wwODu8mt7tVdHoB0NfXUn6QbOnKt7Ze/LqSdvYCggm3YXYRt/VxOrEbi4ygiZyLc3pD9AZ39t92RftOfr0Lc6js+jHb7OSYE+JnVzIli8V2Anr4F6lUuFcOou815YD1YGJHorVaiUPTX4IMfDf+NGHhr00Gid8j4CGJr3X08cc7Ae4fhbb2Iq40FF6vV5nd/f03AbypBrY2/uKjPR9Yg/zjxw3h6+ZOXLsYbvd8X8Ab+4sl0uvo83t72UzGY4wR4w0p1OOXmVxVUSRG186WRqF7sUtoF+lUpmGRrwPUoS4RpZgj6hvpFOpA2i39ovNR1z7AFqt/N3APzmnp9cz6PH0/R4qgk/m98O52Wufhe5KUMXKqMibLjJINcVIhxugX61WWwbkE/pBMpl4OhIObYA8az8nnUC/lGGCEHujvckHDAbje/jtq5TLS0uL839UKpVyIC+uv21PrMiNJwrw50kd9HPSAv4RyMADhbPKNgaMS2MNunXW1XglM4kJ6ha3duHY6DBxdRdNEVeHhQ3TKUXSs8F7bztDmOYNGs5Sjr38Kbh1ahyev76ICfioC8HrR07bJ2LhYqIXf49Z6M9M+uDU+Ah864ev4lmFuhCevdumMVJTlmGMvui52MYQw9CqMme5Ry++XjeMeHqIVV9FXP47pWZnWxveeN/8Fv9l0xtgxOGAzWiM3PdyMATTPT2Y/lRwJlV374fGPRI3+mqFxNbjcINytVwdsw4mocJywL8xQV+L+b0alYpsfmxGIyEOxBkUlrYCkMjlGxkIp03ei1aVMQWtk5kYoZvUQWnVGqpHb6+oGaagV+uoZCmrylVyqkqpStFqhj3rno559M4MAv0ctwKpZz27b3s9vOTZyh44aVpFqSlVo/8Y9L7MVjVbmYMBBPz3oEZWyL4anhu8FFmezpZLZhqrF+j60GRZnp2a1j67e/mRPq0rP2LsCeJvt3Nh55XI8sRBLtafLKUdZaiqGaI6grxdZ95GfbD2gZG7nqFYCmtVuIWHW4Ty9ZQufLcy/kMr5Logf2ezmYbVX/i0ZEiaQ9HFi1uk2uL6UbGaEe/onQyjMsgZp7ls9tLe7jb2bOmWFofPKCHUpPP5MIQLa5sLHT5/euboQ3aH4zehBfSXry3Oz/1uKpXEoR6dAL+iUVdEkXegSBD6SQEO/tzIAX+d1zd2h1ardcmts5DPL635V54GcRZ/sVAoTrqFP7W5+BtNJovPN/ZxiqYb3lqVSmVjdWUJAY6iEHDIiilW5kRF3kQRWvtlpe9DY/A2tUYeoR96/qPr/tV/hMO5+EuBfmH4YRuD//jE1J1Wm+0Xgbd/Q3u74Pq6/w9SyUQMWg0jnTxuFL6hd4AowJ8nQ8NebPHHb6Xi+8VcqMvnnDMXnth7dQIBRGpuawcB/6EG6G+D1K1RAHUlQA2t1kA/d1UNIvv6ewATB2JrOMLnqovRxfFUMavHaecMmHivnibugVPH4fFXLmGCPeYH+6/eqWG0P/QZe6NT9uHYy8HrFVqlYognAUL+W+EIUTaMeNxg0ukII39TSSH0UpB4z1NgcJe5DCZC5Lcdj5PZdCEYhJmeXgT+VS3XUrycf6ReqtYbFZxuD72a1IYUVWH5pHcNy8hKameMcCGwOCzCQ5QXWJGA+4gwBhAHgmrywcFz1zj9CTTjsPmu9e3WC4rShgpx21Ji2+VP77jDubgOW9FxKr5a+EH9LnCTSxRcT24UEfDP1ctnQ/mY7smDS8MH2aiZQc8CTZQqVaLcYFnuF63FKGhoNb4/Y7SUNn5n64WZaCllw8YcdBnpD+wIoUW/i8NkAKNBB5sHYdK36JzKoMmteXb/ys1z8bXxQrVkZmgV6UYGnc+ROqDLdclybiKST0zMxzZ3j9q8+MHmk+DhV7yA5KC50LSSQTIM1njxmZ6JU0i5VGrwRggeDgotNp1yzvJdWRuLq8Vi9djsjpNyxih2V9va2vhqF/c54WaW/xx029RKgf4HHU7nb6Ni+KD/+vLi/O8kk4kIKKBfEUUUkZZOsf1ivCcNa7/Faut3uXtulltRfY78W5w7HOSlOOW3r1tMfwvoV6vVmumZY/8RrT3jvPqTe7s7H4/FoiHoDPoVMj9FfiIig19DKn0fGYtmi8XjdLnljkE2Eg49ls1m8L5AjHT4MEo3frvEXPwZhFuOuHt6f4u/N0FjMLMf2P14ncG/E8mwkj7zHSgK8BcXvqVTijitAf5nbN61l8Nze6lKbqBUqcL19W045hsmSLGdEq8dMUmPLoqQ1532jcDT1+YIa/56Ys+lYlQUhmNGnbYOfAFsJiOc8nnh6sYmBpbq7+++fO4Xxx9+yam2FD7oveu1H+y9djRXLZgwQszkizC/tQfRVAYm+j0w1ONs+sFTFMiSxnahyeKH3/WYzcT1fjdRA/9LwX2Y8fQRIkBxWrja9TqNuoae0bV9BgfOd9o0k9cnw0gxaQ/nYi4EdEkoxDgC/rj65Z39mos/CRmows2u6csMS+Hfi4sv4Mf0t2l219KBvtno6vB2LthbqJQ0akZNKlWRV5bcj06tBoteB4VSGTKFAmH3T1AFu0ani+Xz2eKF0JzjUnipl2he0L1iIkCcwpFcZ9TD+kGQF0ZBwZneqeLl2NLYhcjCcLFUwloCcu/4ebEb9OR3wekhtWoNhONJWN0Lkt/GoNZRf7X4zYcqdWJAQtKI21iugM1shF6bDYxaLVzb3CblYe6DMlXuuRRe0KsYTcmmNWWGTb17NEsl0fecq2ZLiAL3vFcrFa4PucWBLJo6vR7zYAgfafKKFju5G9uGxX94xHe3XLKcdCr5rMB9TiwXtdiC2kkhIQX6a4RVM0fPI9D/O6gIjowRg/655aWF347XmKrlxvQroF8RRd5B8iMAjhYXf0wm5hslZGJqmVWyyUTiyVDwYBXErf1SLv5yQX/DxR+nMz1y9MS/1Wq1t/PqL8WikT/hkfmJHQqZnyI/MZHJr9Epm4bO6x27T+4epVgsbqyv+Z8B+S7+3TiRpBj8mV5P3/DA4NAfoLFobLaALUcj4T9BjbgK0qBfTAGhhNm8Q0QB/jwZGh5h6xZ/PggiQEilVrPlUkkM+BPwf3vPiRee2Pnhh1UqNXVtYwsmh/qIJZ2IYAgdakShlng9PaBdWIZSuQzhclJL19n3MbDkGov/OT3uJfH+sXQGzTQV42NbL5z6N94HrvpM/ZlfmX7vpYvBRc9Kars3kI1YMCfBfjwB+7EE6FdUMDnYD26LmZDwEfd/qIfhsxJ4nd9Awc31WazkzV4iST5aONiHI70e0DCqtivZ+r/BWKrm9o9k1NS/D7UJrsw7lXkttDCOwDiNz+91WHHuIAKGF7Z3Gy7+GopO3tFzwo/+4BQHLUR+UJ9Mw4UkAuqLkyvpbW+JrejoempADNqx5wH+7XpsZrChPsap/HC/4OwHS1t7ML+9RwrcCG8zFzSzjpcCs9YKzapwJgAMtnF4Q5/dCqN9PdDntMN+JA6bwTB6cCqkU3VqLXxl9alRzN2AvR9wpIUZgfWJ/l7wOOwkfIFueAmwcIAJHutLQ7UWVkDj+67W23nCNwzTQ/2E5BB7BTz9+ix28yI3r1fr4Nn9K49yKRZxneVquWzRGiMujXVhyNh7+daeE9eoaoWv5OI/4/zwBwL+cTrD9h++tnhptFq6WCh0WlT54F/rdLpGzBaLrJzU6J5S6+v+x6C5mHIcBvxc1HLZqaXY+/mgn5meOYZAv0MI+q8T0B+LhqF7TL+kRl0RRRR5x4hUXL+UezEBHGhTf8JoNPnkVoLmprDfv/wtaCf06xZX3Al0iClEmamZo+82mkz/CnieYplM+guLC3NPgULmp8hbS6Qy+fBJfUVJh3t6PeNojzIhs57qfmCX4x86TFy/WNiBlLWfjEGbze72+sb+kOaF2OByk8nkf19anH8Kulv6FYPEO1QU4M8TjYpi69pBoas/Bv14wOBBJwr+py1Dm4umgYWtfPAIBuUvXFuEB87UCHhbR1GduR667f6b52Hm+DEE/hd3A41vMWA0aLXNczH/G1uBB1Gd33zxIgJ3FTjIxVyvR5eHTjsmg2ho0+dc01F0xC9E5gcvhOcHKIQ4y5Uy5NB0MLexQ1j+bdEEDHuc4DCaGgR8bdKl8cRqb6kRBnKW/8XgAQL/fSSbANdmzhsC38vCzh4B8ql8hj3hmkwhVMtZo7nYA+agEOuDeso/b4+bWN1xKsRkNgf/P3vvAeVIdp6H/lXIOTXQQKPReTpN98zsbA7cXWaKtEhTkh8tyU+WzPOkY0k+z+9JFKMYLT3p2Xqy/WxJPrLlJ1nmESlSYhbzkrvcMLuzO6lzzt1AowNyLNS7/62AQqGAxizJ3eVu/XNqCkBX1Q1V99b9/vD9YoIDuOA7N0cJ+OvEQ1KNCVZmTPOnm73XjxfHtnPJiMVoZhF0C3xJvJxasL+7C0Z7wuAkgB/72CC67BcrZTglZdVEvgSDwQA/iN8M8GKTsG0+pwMGu0MwQLMNGOmxuWKRegrQOpLvxXJRqBJpt8tmhemBGIz0hilYB6FCwNddMGDr8EhMi1hfYWGd7hoigL8/SsMC8A9V0h+31jZhJ3kiemAwcipG4VIMecZN5A1iMlZ4rnu/dNK9m08+8mTiZjZgcT993j30rXtDk1dF9ld5gQeNhH9MqVhUxs6D4m8sefZbuappvlR7+/ofRctRJ+OTAO2vZTMZ5DbADlTGrClfZu3S9hlVmxZzfx30T069ze/3/2sV6L+J7v0KS78WS67uRqeLLq9x6TB9Xysro81isXh7or2P3kaRtUT84G9UKU7VwEOtHO3E0tjk4k8Axx0+n//XQZHOtFwufXf21o2/AJ3MT5dXiKj4NbTGoRpgN6xPCKi29cb6Xw+K57ydFPL567s729eh7m1zlov/WaBfcwzaHQ7XubGJD5M1aK+ieJ6U/7dkDH4aOnfv10H/a1B04E+kXOVlhPunf/on7MXp83ygK8jmclngqhxUKmXeZDIxlUqlweWfABZOZHOn29t673v6vy1/uZ9jwLF3fArXVjaoFb5RpMzv5I1crQJG3iNgRIDIKP4uHycOw2jAD3Pbu9TdX/qr026Rj5VgNFqAH50eh29dm6FmYQJMB6f9IxkjsFhnCuCuHy13Cdidh7u6xuMmxsAtpDb8W4eH1u3kMSwSEN7lcULQ7QaH1QouuxXcGGtOQDCCR1RE1O312soBCv5dHvp5j4B/DEmYj+9T8G9glRxyPPUw2IgnBOs36V4DMMYa8Bao55Jn8lzJniicdJkIcEXAP9QTQkwMC7tCn2BbyFVzD3ZfwJgmMyiI3RBYPpec779xsjqRKmf9CNjNmBVAVCLgFusKUMCOYQ9o2UfLeb0twqVWtg/gKJNR3EmhDQjokdxwMNwFse4gOG0WAcCTS6CF/ZmllXoIhUgW4LJa4L6Jc/S+ImAHIX5f2YO0hJ34ESkzK/IM8LRVkwTsXxoeoL8JnAbCtnd4DEs7+2AizxSmhOzyuKDL5QIHqQ/2bblcgXy5DEWyz5ZKcJTKQCqXx/yJrixXfMuTR7fe/MzR3Nq4p+8/viVy92NQj/uXWf4tVitj2txgPUPDPLr7ezxehuM4pspV2VoNs16yhkqFBjyQlxRvIn1rJmVT6z75u0X8bMPoiXAkMupwONUDRFMI4Eaimq9D44JWbe3XIsrphCG3yb1/8vz0P/L6fP9KFdP/wuL87PtIu49BB/266KJLC9EAHO2ynKgZxOl+cGjkYaPR5Oq0zEKhMLO5sfYkCNZ+9RypFdcP0DnoV7oX94cjPR8U53IqHFddWFyY+30yRxahszlRBxy6vFSiReqslWLYCqqxSED/HVarNdJJIWgw2d7eVPIPaRknbjfERmnxF3k1zJaJyenfJphkXFl+uVT6/uzMjf8kGm4qGuXrDP66UNGBPwiWfukzeWFT++lR8hAHBw5EOkAqgpt/Q7w/L6RUkzcrayq8OXr3M1/ZevoNBgNLXf7dNhsBqd2a5VqMBtg6OQa/0wlOReo7pUjG9UiXD+wWMxQrVflv6IKuPE76P0pA7LloGDC9IMfUzI8fXO99Q/gy+qczFeBMp6WM2Wa2UXXB1cOF0EPhC7vvPffTCyvpXdeN42XfVj7u2U4eGfZPUgJPgQhgEeC6SHsCbif1CAh53RAO+AiQZxqAsiQIxiNuN/20c5qi5S0kDmC8OyyQEop1RqVHjasJ5HSsAfLVst3KGpWLA+bK4dyQyWimJyE4x5SJCNiR9I4qQ8jnS/7RNYMA1GQEfVg6dX9958qlZCUdQnJDg5hqUQplmIz1wvmBXrCZzbKSRastyVQa1uIJyJfKMjkhgm6HzUz5FfA64YBHsMqLGQsR7P9gZkH0EBDOwewFg5FueGRqQo7BV3RYw51HpdC1tQ2qKEHFSY/fCw9OjqEpqO4HIZ6DgB4VFPdPniN1soHHYaMKEkaMgZC8GXiq7hA8AVBBgNwIi9t7sHqQgFNUAgA//MLhwh++sf/OtxnK7B40pvZDaz9fCgRqIMb4a8T642Yk7ZRfYqQsaZFrJZ/xQTeTe2bt6el9WHHtdoJkOV8gZZMHsomoqpUVC+BFLGrx+PPTF3/W4/H+GjSm7Ht2fnbm/S3Y+3XQr4suuqhFax7SynKitvhbfT5/zOcPdER4iiLkDF//HwrQofSKkuamdqCjI0u/2+P1ie7FMrs5X6sdbm6sfziTludGLTI/HXDo8pKKRjaNdik01ePQYjab3eFI5KFOy8tmMo8nDxOYSvt24vpbEU5rufcb0aAyNX3x1y0WSwPRIFmfXJ+fu/Wpcrmch9brE53BXxcqOvBXCT78iglDfjkRwMhzXEMctJLsT95GnbHd8/791YXU1ggCth/ML0LA65Lj8ZWCACzq8cIGAf9ZAjzDLo/SAV6ugPCBh5FwGGa3dymydBLwh8z+QpWk4wU0iEDzgfOjsH14BGUy3G+drgbvD06e2gzW6szJmtdisjDSlQnYZp5KzEQPC8e2fxR7cGvY1YNugsxO+dj/7a1nw/HCkRWPx/hxFASY+eQxdSevbdSoe3o3xrOHuykgt1nMDSkLEPPWLf9pKBOgOXewDxME/KOlX2pjyOuhlm2bycYsnG4ELvlHKlC32jOr2d1egfwOqBs+tnFl90AE4TwYeLb0UOgCAlWL1BFXj5Z6n0hcm0K6PcGbQPCgQIv+JYyL74vKYJ9vMeUJrPwszG7uQKZYEjMwCCDa67TRdo/39VDru1RbwdiPvAVpQA8KwUuDp7wMD4yPwmish35ufBZU2RTIx/2jEzhKZ8ButcAj4xPQ191Fwbx8txWXwL4MkftgFHkUBE8ARj5I9szghU/oXYA6B1S0TPb30h57YXWDakNYA2vazhw6ByzaCitoqKW8b8dIq9amWyM90fNWm60jTXqlXN7a3Fh7HNqn73sxoN+o2FOyqqnpS+9xud3vhXqYCHr8PDE3e+sjuWwWFQ8visgPr6O/WHXR5dUvHQAOpZWxyc2fzEP2/sGhN5J9p+sz9L765lHycB0aXYyVc6SWR5QW0WDLuH4CNmxjYxMfIGuhfrlgni8mEvGPHezvbUJ9LjwrbZ8OOHR5qeSsUJuWsf39A0P3GY0mdyeFIP/QxvoqcmtorVGkMdAqrXSrmP4GMj+cD85PX/hFm93+FsU1MHXg+vLSwkdyuVwaWqfta5dJQx+DrzHRgb+2qHPaaeUzV7/I5EH11vA986fVfCieP3Kj1fd7N+fg3Q/cLYM2SaiqjwCvAX8ANo+PqPW/z+uX09uB6mhM7Yes/Qjuwn6vTP6mBP3SHoHlPaPD8MTcIgJXw7PJheCj4TuSN46Xgwj90BUcrfg5AmYJMGWWM3uBv9v8PvxM3yOosaz1mv3JXx5523GOK1rnT9Y9K9k931b2wG42WsTsg4JrutHAEMCeg2RqFa4srEDA5YSwzwshjxsiQZ9MFIgx/7jfJ+AfueLn43EY7+4GEysQ0g10hyjwx6avZHZ7CPA/FfsV9gpHznQ570JFCnoXxAgAxovNI8meeJfOe/t3WcHaT93Tnzyc6X8mMTOMZIu86NKPLvjnY70U8NdET4azHgNUGKztHsDO0bHc31iPqN8HF0f6BYWObFWvPyV4zDOLy3SP9x35E143NQ4Wk4la7xkxE0L9pEbDN4Yx3FrfhumBPrjj3AD1kKhJQf58o5kE24bhIox0XxTXEqrMCGECijIZxbnIP7B5mJSvaWSMi4PW8A5fJwhQPv/ND6a2S31LQj+ycLSHI9GHoENrfzx+8PlqVSbL6WRBK9VFK25O05KFsQlTFy79c6fT9c+g7jHCl8vlb8/euvGJQiGfBR3066KLLp3J7aYOk9z8rdFobMpud/R1WhAS+q2tLEk5wztl8dfiPWmZ0hRT1UxOXfhNk9l8WVE0l06l/nh1Zek56Cxtnz4v6vKSSJvY/o74hxwOZzDQ1XVXh8Xxp6cn/5DJpONwNq+Gsl6dZNCQOYcmzk+/y+Vyv0dxDVQ4JDY31j5wcnwch868EJX4RR+Dr1HRgX/HwqgBfwML+lopce6pvev3FqsVp91oMVSZmkkgagNI5QqwshuHwUhQzH6nBH08dQkfDHTBSvIQ1o6TMBAIKJhE6ugQieOcVisUKmUKrGu8lGENNPeY7u7phWUKPG+crPpirnD1uJSxsAYjDHYH4dLIAHzr+VuwdyxYpTdzCf+14+XUHf5zh+JFeIfBWr6ra+KEbNkcV7I9kbzVvXC6aWWU9eMFgj5k5T/J5+mGfARo/b97ZBC6A17K6I+Wf6zLYTYjxvwfUMu/yWCAib4eeG55lYYTbOUPAslS2tdlcSPY458/WogZjJQyH0Z6BBK8+HEaUnn8MwvVWqV2T2gaydZw8ma+sPn48EY+3m00Ghkpb8A9oyME8EfIJQTiPMkFvpXw4h8xHv7q8rr8q91khssEiKO7Pi+58GtkjN+OJ+E4m6Mg/E7SB0jgx/Eq/NymfMykNz3YB0GvoHBWYP7mJ1NK66C4+9IbRuJykLInyAoHELgJkBPgqfklKXyBZzh+8519D31Q5K5ox0SvtmppseSqF7d03xvru2ixWIKdjLpSsbiws72JC8uzFrTKkAQtrb765SqDfoPRaJq+cOlfksX2u5VdWCoVv3TrxvU/KJdLBWjN3K8zVeuiiy5UOiT0k+bGBvd+3BNg7Y5Eex+5jSL5w0T8M8ViERXlt5u6ryOlKHpCnZ+68As2G7U0yuXm87lPz83e/AK0Voi2Av1U9HlRlx+zvCjQj9/7BgYfYlmDtZNCuGo1ubG2gvxDt5u6Tyu7R5OlH48bG598k9fr+xegCGMla7TU3u72Bw7299ahMaZfvU7RWp9Q0cfga1M6Yqp8jUpDHBrHVdULehn07xaT3i+uffcXDkup8Uy10JsopSLHxbSNF02z5M0JTxNwdXiaJsiKqV+dSt0+O9wVpGz8S4kEAYk1aDyQp2CwN+gHzLwW8gus+eIlmgVZ3snxE709FBlyUGO/u3c1gHH0CFi7vR4Kvt90eQo8DrsADVmGeSJxLVaqVZQ5g2l7N/Nx+2fWvhOeO1qzMo32ZuEALK/K0WtbzSYCWDE1oIsSARpEN3u0WEc9HuhyOOlZqARYJOBfcnu/c2SInm9gDcxjB8/HyE9W0g+O1fR2l0CUV4OxWA9t3MLuHmAKPuzOPmd32mnA8AWwfmvv6vB67iAsselh777t7ovCeTzT2Kqm263sPuHfY9dnaRuwryb7euHdD90NAxT0Q8usB9gGtPYjB8M7778TJgd76flSGTTGvu1jJ7TV47KJyh1e8Zfmx5NXfBd0SkyD4ogqZZSPCSOA/ivzq/DU3JJAEkguY2FML/zC0Jt/c8QZ3YUzFm31K7UkzNEE/QRjO0Oh8APQmXD7+7ufq9VqCLxbEeVI9dByp9V6qTZo0s1ms+XipcvvU4H+WqGQ//SNay/8PgH9eTjbfa4GugudLrroUpd2MfRagEPMFz50v8lk8nRaSLFYmNtYX0VCPy0Wf+UcrqxXOzKxJmvj6PjkW1wu9y+C4hVC5sXvzd668WcKIrHbSt2nz4u6/LikDbGmllt9E/D3eL1Rr9c71WFx/NFR8kui4u2s8dcK9JuhTYjN8MjoA/5A12+CwlCLXB6J+MFHtzY3ZqD1+kRP26eLpugWf5Ugw/9TP/g+BLqCSGTGVKoVBonnMNa7Wq0qQb88qOaTG36GNZkkb2qnzQyFchWkPO3CBnBtZR3unxwFl92uwup1YDZCwP8iAf5oDcfPVmMdg+N1fAQ0U5I9qw2kmPd2luNzBPDeWN+ipHb5WlkOAO/p8lFiOQTdb73zInzm8aeFRO2kIU8mbnW/IXwZcwcyZb5q/ub+1dhyatuDFn2D0UC9FiTFBJIXdvs90E0AfcDjounpMBQBSexky3oD4OUh5vXRuh8XClAle2wruv1PD8ZgZW8PMoUyeh94t/IJ33ExZWAMQox+mJTjdQghCluJJAWsWM60dwRjry0vHC/5ZlJr3axBgL2Y4eCn7r5ECQnP6CZo0J7wVAkCX796HY6yWdJGKzx6YZKS+NWz4/GNigTpVBrbn4K+YBfcPTYi/EgdMxqvjwoeyoJHQyEY8c9imAaGExhY2kcSN4HkGYLfURlQ5qrkWeXoPayS7xIhIT6nWEf0isBreC02msKvDvoFIsVv35iDA1JP7EOO/OAx2b/9K6Pv+PdsjUGOhyaLDVmMIsFlK9Z85UKSvrxIPS1I5Ef2NpHQj4L/3ljfHSaz2QcdSCGfv7G/tzsL2gzVypfY7TD4y65zNoL2z09d+BDB/g8oHgAul83++a2b1/6C9KGyzIqqfN2NVRdddJHlDGu/NCe1BP1OpytE1h2duhfj+6GyvbX5P0VCv1bWfjWDfzsysSZr/+DQyJ1+f+A3QMF5QtZBcwvzs/+GvA8kT6iz8oTrZH66vNSitT5Rp/JVp9Kkn/v6Bl/HMGxH2KhSKW9vrK9+D1pb+7W4h9SekS0NE/2DQ5dC3eHfJusoc71UvnJ8fPR/ra4sPQP1cdcJmZ8O+nWhogN/oGCfNRuZGoJ+ZPjHF/hR8lAJ8lmL1Upj2jmOwCwiZCDyEqv/nd0TWzeXV4oGg8mKwGyir5eARIHMr1iqkOtX4ZgASD8BjpgeTwJ0WoJA7FwwSPPeLx4mYNAfAI/FKlP+dfvd1N0fQR1a2FuJ5P2NQBld7stVcQ5Csj2/T4gXFyETAuTLwwNwbXWDnjd/uh58Y+SuRAUqpi/uPjWym4pbEUwL5Hg8BNwuGAwHqRs6WvetJjONQZcI6jgCzHmQQKsUc87Xzalki/n9AMfHcJTPQVn0chgPh+Gtd98Bn3/iWRqz/rWdp6JGMv+ylAegBuPRHrrHsAlq0EeSQ5OtNOnpL23lE94n4td7kK8Ay0DW/7ffc4n0la2ljzz1OkAPA6bR8QXb+p3rs5BMZeCec8MwOdALgvKn3rc8aN8/bCv2CxIeagsv3meGPk88I/WORMLH0/j+CgHyBUy9RwA+3mdM/Vgk/YqAn3oPMEDrLT1H+L/DbAY72eie3BMMoaAKGlEBg2XuHB7BE7ML1KMATy1XK7VBd+Rvf67v0b/iazzGsWuR0tTEVJZyL1ptNgbT95HBYCB/Y01EyH03kQPM5Ddk8qekOZjOD+osua5gqPu+TsYkhhrs7m4jWU6J3NMyKUutRb9dMj/lS5/1eLy+0fHJj5NqX6hfg6+k0+k/nrl5/TOgvaBttbDVQb8uuugiiZYnlNrKqHbztw4MDr+ezHXmTgvJZNLfO0zEl6E5xemLietXz5VsT7R3KByJfECZto/Mw/sE6Hwom8moGfzb5QnXyfx0eUnkjDSaSuWbprU/0BUccLpcox0WxycE/iFcN3Xq4q/l/aMJ+qO9fWM9PVFMm2lTlMmlTk//eHF+9pvQ3rVfuemKN10aRAf+QNP51Vr8SfazLxWLDYNJjIGmlj+fyXE06Ip8cyMb/2kCUpnlvX14xz13CHnZeQkOK6KvVUOPAj8FOEXCu9FQiFr+V4+S0OP2QNjlosDTbbPD66bHCBisqQjepBTxIuAW/4hKh2iXH9YPDmXLcSTgk4kGpeOmBvoocz0qCMpQM187WvR7bS5+N5uwMoZ6fDheGzMGuAmgVoLOeht5kdqAaSCZU4aEC4z0PPT5/PS843yegNoKrCYPabjDPeeG4OnFZTKTckYEvniG1WSCAeRIIP+WSP8KOe95uOQdyabLOftXdp4MU/p9EIj1Xn9hUgD9yi4XG4vAWfJYoKDfoOhH8m92fYeGJ/z8ow8K5Hxc4+OhpFFs+hEE5Y3W/Co9CQbSnwayx74ulCtQIPeoXCEgvyoAe0zZiAoJ1GGwKgURXgF/x/SPNosJrEYB6FuNxqZHq8bz8rOFHgZPzi7BZjxBFSm0NlytfKlr5L+8qfuub5D7gS7t0gJSK/dzw0usWCgobywF/yAwz2qR+tGtN9Z/JwHaHbHk5vO558hLdQnrROqmXtAqX2DtWLOVC1vZ0t8VDIWHR0Y/ZTAYRurjhy+enhx/an5u5uvQOmZVB/266KJLk2hY+7XmJC0rI926ukJDbo+nU8CByvXU+urK56CR0E/LIwpa1Kete78/0NUd6xv4GHnPyhpsMkem9/d2PkTm5R1oPT/q7OG6vNxyFrGmVrYh9E5E/qHXMQzTUQh0qVRc2trceBa0Xfw74dVoBfqN3eFIf6yv/3dJVZTrJT6TSf/57MzNv4NmC3+rMBslkZ8+BnWhogP/s6UVk7/k7ksH27tjj37tz5e/NJnnyyOnuQJ87oln4Q2XzkOXy6mIwRbHv8y+DgBSvDffWKDJYITRLgL+D+Own05BsVyGwUCAFux3OhUWYqlyNZqeDUFho0cBAwFy/DpzSIEvuoCjIqCpkQQI3zE8AM8sLFOwefVoMfTPR9++hSkMjQSp1p3QGUoIeGmgH0Zi3cKvDdMIo6hTG9p2XujEfr+flneYy0KmWIT9kxMY6+uhaQuz5Duej67t6JGA5WRLRTjJ5GjoAvm5dsE/UvnM2re7y7Wq/CxfHOqDsN9HCxHqxtDwBvyYLRcp2HZazGBijRTYK2F8vlyiFvvzg720Pxtbpgb99RZKfA6SZR37Cfu6UK0QQF+FCieEfiCDfp78hhZ8FJYR2fgVfYj3EDu8JiqN7CYTAfcW6rnhInvMDEAbz9cVSsrz6/UT6oIEfs8tr1FPDAH04yPCHz/cc+k/X/aMXiXfC+KmTAOlxUir7o5WL9UmJn+zxeImgPse6EAwbnRne4ta+6E9mZ/0gm4X2y+7reLWE40N9/UPfIpl2YiivHTyMPHh5aWFJ6G1lV8n8tNFF13OkrMI/ZqsjGjRi/X3Pwqdcy7xx0fJL+Ry2SS0jytWW/vbhUDJoN/pdLlHzo19lLxjFelW+dJR8vCTmxvrM9Ca6FRLGaqzh+vykkiH1v6WKYaDoe4Rh8M50GFxtYP9vc+jwQAax4KWR2KruH4l4Jc2NEz0DAwOf4ysUQKK8vh8LvfpmZvX/xIaLf3K9ZGeOlOXjkQH/q1FScGuBv8S6Jc2Mvj4wv8y/Ma//Oz6Y/86VykEipUKfPXKNZjsi8Ll0UHZpF+3krfPZIbAz2I0wlioGxbjcTgpFqCcSMC5YEgOF1danQUrNg9mJLwDAfyDGF+PQP/Z5VUxtRxAl9tJQGAzjhvr7YGrCBDJQalKzhbPJW1vjFyOP52Y86fKWbPFaKagFJnu0SJ/a2sLzvf1wkAkRL0UgKm3SoLDraC/1A9YTbT8GwkAPshmyJYFm9UKj1yYgK8+8wLNa+e0WuBcNEKt1ut7CdoOGnJgdXOfXvtWIMMVTLRHydQa9rihPxyUPS2kW4jFnRbykCuVCOi3In2yIj1eTa6pw2wFO9kE0F9nw687+Nc5GxB4ozs+gvsyuuFXqpQIkH6vctSrgKWKAFapHqAiKBwEEcINGOqej/fcbDSQvYl+p5Z8kJj5xeNpOkCxZ+XXi/hsMcK9Pzg5ha14Elb345QHQLozBPxzYWvgiXfE7v+0x2THFDB5cUPgr+UuqnYVY05TaYPXQxXRTYtJ0cW/6cUai/XfZTQaXZ0MvFw28xRZZG5C44utnRZdy31V2kv1YweGhi9Gwj0fY1hW5hjga7XD/f29922sr96Eztz7ddCviy66yNIitl8LbGi6+WP6PpvNHu20vEq5vLW2uvwtqFv7W5GeAtxeXL/BbLZYxyfPf4DM1UrvAy6VSv3HpcX570Oza/FZ4U9U9LlRl5dIbsfaL49FtPaTcdhpimEoFAq39nZ3bkGj4k3LxV89/pSeP+oxiJ426I34iUalG/DFQuELt25e+5MWZJqdhCDqY1AXWXTgryE4QBTaQxQta7/S4k814B7WfvSegdf/xdf2rrz3IHfkR4K4he092Dk8hvsmRqiLfd0yq7Sht55rLAbB7R9j/rMEZC7ED2Csu7sB9OM1ENxhmr+a0UQJAQUmdwEsuhxW8NhtkCmWIOhztcxfjwB0nID/2a1dCkxvnqx63x69P3HJdy5fgZrpbzce6z4snZipJZm0LVcqw5WlVXL8Dpzr6YGhSJBmCKiIfAJ1Sj+1rbwx6RyWG/F66NS4n0rDxlESJiMRuDQ0AC+sbcB0f4yCaIzb30wcipfh4aiYklnrEOzaLBa4ODwADrJXtzGHAJ1sGAPvs9llsE3PlUzuIicBBevIVUB+klzvi6RvEdTjhhb8QqUCVZ6joN4gA25FwDleA5UhouUeVQtmUn+Mu7eR+2M2GSgJosMk3C/8vUY9FPiGrpJT8Ym/NSbtEz5SosRMBg5PMrB5mITEaYqewyqUTBaDCQZ90dlha/jLI44oWm0wLg3zIWqBfi1yGLlHQ6EglEulTl6q9MVqtlhcga7g3Z2MPdSgb21tfgmaQb8WO67afU4N/CVLPzs6NvE6UgeMV7XLz3uttrW9tfnbuztby9De0q+Dfl100aVJzmAQPzN1mMFodIZ7og/dRpG1/f29v+E4DuduCXC0IxTTYjPXtPQbDEbT+emLv0nAv3Ku5nO53F/Pzdz8HLR3LVZ6h+lEYrq8pPIirP0Nbv7hSM+4zW7v7aQsDPPd293+O5FUsx2vhjIMUWv8NaTs83p9XedGxz5OBqKyHphW+JsE9P8/ZMwrPTLVln49xEaXjkUH/mfLWa7+DeDfbbDHf7b/0b/+zsHVdy4ebkQJujMhIP/ujTmIBf1w+dwgjT3nRf/+syzj+DsCQ8nyj/HgcwcHMBoMUbBYP52HCjLpV3lK1meQU8YJLuchnwcy+wno8fmoRb+VsmG8LwozG9s0XH4tu+cgQMlIJjgmVcoY97OHJrI2oGEBrGixxuvkimW4vrYOL6ysgtVihv5QF0yQ63gdDlq21I7GfWObsT8iLi8F0runp7BA2nphsJcC/eEeQdGRKRTgKJ2lxIbCpQTrNm7oeXB5dEBIZKdSrpS5CpzkcuC2W8FptlJrvZH8hxkFkAMB+7QkkuiVxc8I7CWmfAHYS60V2QzIb2aR+JVi9ZqgOEDlBFrpLQTUI7g30e8mCvapp4IcfiBmBRC7AMtShn8oHesZsa3ajyZD78XB0SlcXVoXsi6IHgaYMcBpsCZCVt/qQ7FLz7tr1kXSV8janxU3ydrfynKkfpEJ1eH5TtNU0c+xWP/dRrLA7WSwZTOZJ09Pjnehfeq+VnH9StBvADEH9cT56Xd6vd5fJ6fIxFkcV51fW135rcNEfB/aL2alBa20oNZfqrroootS1ASj7ebGhtj+vr6Bu8xms7/Tggr5/PWd7c0XoJnFX2uubuUN1WTpx3ny/PSFX7bZbG9RnI/cRl+buXlNK21fK6WoTiSmy8slnVj71dxDVrJ+skUi0QehU2t/Pv98/GB/AdqnGFaGIbZLLUz/5vZ4/Ug2bDAYB5RllculJ2Zu3fh9MYOGFplfKy4mPcRGl5aiA3+FIKO/xOz/wEOPwPbWJtk2wG53MBwB1eQl2JTKD5rBf8VUY47fFrr7i490XQx/f/+FO5ayO0MESBt3jk5g9/AEBsJBCrAD1OVeYubXAP+yuz5NgC4T/qHVee5gH86R7+gOjocgYEagV+EwfrxCXdkZXnBJ50XlAYLwsM+r3XjRwuywWihr/zEByvlyyZCp5q0uo7369Z1n/AaTiekL+mF6qA+Wdw5gcXtXsGqLAByVBZUKR1n3l8jfY11+GI9FoZecgx4JjcsAocCaaNXG2TFdKEHQ4aQu84fZLGweH8PDF8blsIC13UQd9IOQ1g6t+w9OjgqEhTKRIsh9gn2VL5XBSABxvlyGk1yBWuzRik/TGTKS5V8ysUshGQicGZA8EniRKI8CeZORuuKbyDXRio/u+VYC9BH0S34WNSEAvx6DT/5xYi5AGdwzynvO0/uF9Wlk+ZdCIupZEup2f+lvNZga7IP+SAienl2Cg9MU/VuF56DAlUz9rsisi7PMkXPT0Gjp1wL9WtprWhmrzWYoFgqM2WIxlstldeo8KY2fVUzjZyUn2Sxmi7vTFFWkHQUy3r5Czq1gqirQBv1aeXm1NgPK+emLv+R0uv4ZNKSjqlxZnJ/7UCp1egTtXftbxa3qoF8XXV7jorIytiMZ1QT9FovFE+ruvrfT8hB8b21tYMaREnTmYnwWmZ88V06cn34XmSf/CSgWIZVK+ZnZmRt/QNYoWmlNO/GG0udHXX7scpvW/qYUfmjtJ2ubSCdl4bpkZ2fr7+FsTxs1i79S4dYA+p0ul2dsfPKjRqNxRFkWjr+5mVufILgjB9pkfu0Ub1T08aeLlujAXyUI+qU9mVDob/l8TqnF07L4N4F/3GysOfO26H03Xs9X9h+P35xYSG0ECThmNhJJWIsnqPt9byBAQKsX/G4ntdRLbPtUGKYOZEGIAR/vJuCfnIsVQKv4EDnfa7PTGHun2QLZEi9a9Otx9CxTJxD0ux0qa79YguimjmneYgE/HGWyYDabYSO9b62xPJOspC2oFHhkeoIef9/4CPT4vPDYrTnSKazook4AL4JlUeGAio6twySYTSboIcA86HaB0yakM8QwgXyxRMn00vkCnObylLQOFRxvujwtpKwjlXLa7CAAcRb2T09AAuhhnxsuDPZD2O+l16Pu92L6u3K5SrMEUHd8sS9Yhm0MrsB0eAZG8BAA0R2fF1LpobXehnUxm2i/Uou9ySR7WPCigkG6N1KGAPyFU9w/uZ95+XYK1n4F8SJPyxU4BvDe43fsZ/wNv+OeYernSHH9csy/4la6rFa4b+IcvLC8DtvJY9qyUq3qe/zg2ruGXT3XLGDEF4i0SWR+LUG/3e7AZ1/J5E+TCmQzGdxLVvWGxa2Yvk/am3pjfXd1au3PpNM/OD09QQu80n1OHddvUOzV1n7Z0k+eXcvU9KV/RV7o71D0El8ulb45N3vrU6RdWWhv6T/TkqW/VHXR5TUvrayMUgq/ptAnaesbGLrPYDA6Oi2IzI+PHSUP16GRxV/NxdIKdGgCfhDCoB71er2/CgpywWq1OrM4P/fRYh10tCIS00G/Lq8EaZdRo1UYogWt/WHB2t+R5HLZK8nDBI7BVkq3VoYJTdBvdzhcE5NTHzGZTOPKciqVyvPzszO/S9YpKTibzE9znaKPP11aiQ78OxMtgr9OFAD0u9VgLjwQOr816R/M3Uyt9Kyn9i0IRDOFIizs7MH89i7NW9/lcUGsKwB93UEwGtmmhHgoaMmXLP8I6NeOkhDzEVDtcBGQCuC0WKCmRoRiExB0S4R/za734q/k7x6nXcwOAJCopCyb2X3qVoCs/3LEPpLydXfBHbkBuLG+CQ7WWnx95PLyaTnN7OQOXfuFo1CRK9tYApaRzX4rkYTtxFE99l62dtdJ64olAtYLJZhZ34bzA71COAEF1YK7fvw4BW67XeZLQGC8dXQEyXwecxpQBYTMfSB60RvE1Hr0xomx9ibSFuxHBPNGMe4eCfVo7L3BCIIngqQQqXtd1Pg63JdSEuarZUiR8itcjd5DiwmVBhaqxDHKLAsAyjwOvOzmL/yNFbPH8ORRQjK+lb0DqvjAtoY8buj2eSHodcmEgox4nqSskSMHyA7v8YNTY3BzbRPmtvboYQWu3HUlMRd5OHQB0+NJMf1SfJr0MmlihSUvHfmxUDws7RhqG0j9CPhGa/+dnQywWq1W2Nra+CpoZxSQypas9gZotvbLJH4Op5O8TKc/SMq/X1H3WqFQ+MzMzev/oVIpF6C9pb+V65zUH/qiVhddXsOiYWVUk/qp3XobQL/d7ggEAl2XOy2vhun71lbQ0qh28W9lbezIxX9waPhOMkf/H+QUeS3Icdza6vLi+9Pp1DG0D4HSY4p1eVnlh4jtF6390Umr1RrupCxMK7zTzD90Fq+GWvFQB/12h3Py/IUPmUzmaWU51Wr11sL87Aez2cwJdB7Tr4N+XToWHfi3EZHkDz8qA9PV7P5ql395e+F4MTp/unUpUTqJVLiqkRLBIbmb2SxYd0HIr86LaBgt1hwvuJk3eIFLIqI8yfK/FE9QoL59ckpBabfTTc5jwcQySqOycA4p89JQPwWn7UKZqDs7Aa0IutH6f+tk1UYbTIDoUE+3EMuuSCE3NRQjwH8L8rWidTeXsD4avmP+7sBEgdSrvJLe8ZD2Rw9Lxz1prugvVUtGlmcNLLrr8wILPy1TdHGn0Jj8bUOM63fbbSAheGTzH4mG4YHJUQHA1wTPBrT0Y5MIhKdhAAj0WUaIwTeQfjBI5HvkGEylh1Zxr81GwyIEF35FbzAg9L8S6zJaN6GuJEFvgIrFInIC1CBfrkAFQTu+VxD8s4b68ZIaQORkQMFQBKneGDow2d9L+3lpexeur23D3jG5t6vrtCwM00DFUKw7QI9FhYXBYKTlCsoEnuoT4uSc40wWpJtkNVgO7wqNY1xoOwb/lmR+ioa3ip1TLm7lrTfWf7lTJv9sJv1EOpVKwNlx/VrWfuk76yer2JFzY58g5U4qLl8lL9E/w1Q4tVqtlcuc0r1fKx0O7U39haqLLrqI0i6muJ2bv6VvYPAB8o61dFgOf3xy9BVF+r52/CetrJ1KSz+dM6O9faME+HwI0wlKBZH58WBzY+13jo6SB3A2g786bR8VfY7U5SUWtbVfDfrbWPt77uu0ELKGePr4+GgLmo0TyvAaaa9m8W8YgxT0T134sNlsvkNZBgH9c0sLc+/PCEo3rfF3lou/vkbR5UzRgX8bUaTpoXH+ottzq/R+MvhPV3KWv1n/zi9kudIQS1AoQ8CfSczXHvS4qcs7WnPRpdtpt9I9zc2O7PxVVfJ4JQiVhzMDNqOZsvujuz+CyL1UigLeLodTdEVnGtK9mQhA9DhtBAwbtK8NdXCKoN9IgT8npOgjf8C4f8p0r6odgvZRAsiX9vbh+snKwN3ByQWHwVJCdvZhV/SUbCvYNwhcOb5mOSiddBVqZX+5VrEmssfu41ImUOCKtiJfsZZqJVuZq5oKBDzvJ0/B2++Q6fSCPjeci0UoWMd+xDABtNaPBEO05izbnM8eRbLc4znxTIp6WeTIuXaLmYZICEoCtqEveF6hOGnJuygS65ED3VYbeMjGUYVEjfY/EvkxWkoDhaeDxAeAwJ01MHIaRuQPuDA0QM43wPOra1RZhGfEU2mIn6bgmcUVqswQlEjotcDSdqPyoVQqU64FsWzearDu/cL4Wz5q58xS6j7JYnQWg79Sgy3ttTTpmi9Vk8ns6gp2yuRPrf3fAG1+gVagX1kPWq9IT3Sgr3/wk6RfYvVr88XU6ekfzM3e/DJov0Alchw9B64uuuhypnRg7W+XL9zidLlCPp9vutPyqtXKwfrqCqbvU8f1S8BDknYuzkrgwYa6w9FYX//HyXvCLZ3M12onuzvb7zvY39uAs8OgdMWoLi+rvMiMGvLWHY6MWa3WDmP7a8XtzQ1cQ5yldFOn7mtSvLUC/Vy1uri8tPC+09OTQ2gce1qky63CEHXR5UzRgb9CVCn8GkQE/WrLv2aKv7/ffvxn83x5WMrVHu3ywsXBAej2eYDjajRuW/ZFF4dqtaok+QNoxFtqEY5Ba/NkOExT/eF1t05OKHDsdjWn7DObjOCwWlVAtvHaUhQ5HmsiYLJUqbPLo8IC3dmFNIHQ4AJ/rofUYXsXgajpmfhM7xt77kSQiQsUKX68SurFEzha6LH40RSNPujWCUcMLQ0YxE/3LxwtDzyevDGKbXDRsIR6W71OBwXZ11c2aLrBKlel5Y9GI3D53ACZ2Y2yNV0iNJT93xnBQyDkcEPeXIZ0oQDFcgWybJF6T6ADAlUcSJ0mefiDRLyvdQ/q90f6lMrlIHGSgmjQTz0LeM2jpcAD4ROGFvBiPSViP6F7efLM9IHPYYfHbs4LnINirD8CfXzi8J5nikUp4QCw5CBk9S9VKjWnybobswe/+FO9933dwBnQZaxVTH9bchjQtmopLUctrP19dxiNJjd0IJlM5ul0KhVX1EfLgtUK+FNL/8Dg8IVIpOdjDMvKDNmkD1PJw8RHyMv0SWgE+q0IqpQKBx3066KLLq3kLGu/el6UwX9f/+BDDMOaOiyHT8Tjn69UKhlotvbfTuow2dLv8/m7BodGPsmybFAuhOdzBwf7H9ze2piH9mn7dEujLq8kaWftb0nqh+TD4Uj0/k4LyWC2odMTXLe2yqKhHn9q4N8e9HPcElmn/PbJ8VEC2sf0tyMc1tcpunQkr2ngrwH06fdAV5A5Sh42xMxZbTYWGc0Vx6rBvwz8K9WKSXII9xHA+pY7L9Lc9mWyKfnYFThTBoP1CHK18NQSjVHqLFOPZUfgOBHqhrn4AUWp6PaPv4edHkV8OYDP7RDi1xleBsWMlDauwaGAB5vFRME/QcdyzZB/QD6HVrquAwl4BNI+dHNfze8OvBHuvAJ1TSUuVqpQL8ko9leDdaLCc/zTyZk+iZQQ3dnrvPYCo/2V+RVY3N2nCgBK1kcOXt49gJW9ONw/dg5GeruhJpH3yeR3AoqXrO8Y8oAs/CUMEZDT9Cl0MI36GHXWPc37Iv3V53BA4jgFX7tyHXq7/DAa7YFwQFD2CEoJMYyjsQThe4MyRvgbehDEQgF41wN3wjeev0luR1kusd8R3jIyTIYlQJ/jqqkyWRhWoVYOWNw7Q+7o6ogruoyLOai79sug32AwVMiLpmI0mWpVTMPQAvR7PF42lTqVKqUVO6cV2281Go32rmDHTP7F7a3Nb4A2M7X0IuehWZsvxfmzY+OTj/oDXe8j99guXbdWq+3t7+2+f3NjbQa0Ab/S0l8D/WWqiy66nCG3Ye1Xpg6T3fzdHk+YzKuTnZZXKhWXyRz2NDSHZrWK61fyCzSBfofT6T43NvEx8g7oq5fCF8l652PrayvPQ/29fRbg0EG/Li+btBmHrWLr1db+czabraeTsmi2oU2Zf0iLTLOVi39DeE0b0L+yQkD/8fGRMrymFZGf5vjD6+hjUJdO5TUJ/FWAn4n1DbD/46/+P/49//Tn2fjBfo28BPH3et44hMs8r5xgqLDUpZplCPCSBiIdoI/23PXZL2w9PmViTQZkx59Z24bx/qhMVIeiHKHyyFUAVOl7TWZ95wXAz9RJ6mgdMDacAPrJcAQW43GokL/tnArgP+LyCK7xgKR/NpByyOO+wlVpjDi14PMKEjpysNVkpm700ryG1vWI3yvWTe34ILinh7we2Ign4aSY8pagYrWAKQ2NpGlS4yVrrjRB0mNunCx1ccDh4giGI91KCj168Pp+ghIhYp/TdqgA+5PzizSV4UR/r8iZwMgKFaXLPf6JFWPzpfR4yVQG8qUidLld4LLbG+5Da8Bfb7/8IKEHQixClT3fvTkLqwcJsJtNcGGwj/zeA+RRoaEAypR+grVeHU8g1RzvPQMumw1+9sF74JvP34BEOkMfzO38QfinYw89OegII8NsVrFR1n7SB0oSPyUhVJm8aOhLBEE/WYTy5DufzWb4QFcQlAovAvqVgFvWphNgbyYXsho4ziyx+NdqjBUzHWKkQk80dtFkMvs6GYuZTOZK6vQkDi3i+hkpZkEYf0rgT4Nozk9d+DmymP7fyOGyBY20Z3FjffV9ZCxvQ2sSv7NYqfWXqS666KIlnVj7LVpbLDbwIIMxXJ0Jt7e781ky90mcLEovrdtJ3UdBv9VqtU1OTn+IzN8TijIqpycn//fS4vz3QTueWO3WLAEe3b1Yl5db1GGIZ5H60Q2t/ZFI9AE4a3knSiadeYqshSSPRKXSTell0MraT8deW9C/vPhbR0dJzGakBvxneSXq6xRdXpR0+gJ61YiWpjCdOoWBgQEml6WEaEqXHXlC4arVphgi9F7n+Zpaw2j0m12FtexeqFAr9SNQ3U4eUTdsZKLnG3zw60BasvoyoACcorW6ynOQLSN7fAFypRLNR1/CtHXVqpC6jwBKjMkPOJxwnM9TwJhGF3Dyu9siuZzzDdZsjucoCDYwLCgYAegB+NvqQZym3ONFhvt7xkZE7/466Fd+T+dycHCaRg4BxsFYVyP2gEROonZLVMch0v1349cu57mSAzkOHr04ARaTWT48mcrCd2/MUuI/FFSE2A2WtAGYKukHE0WApM47R8fUoh8QvRMEU73S5V9qotjXIhEgfrm+ug7PL2/A4Uma4nCfywlnvxe0iQAcNguNs8d4fLT27ySP4cbKBk1ZaEROAIe9rtRgpMdQmeWAAabxSaC7kZ4wnGRz9Dq4eFxJ7fSe9w8/bWYMaJaXQT80MverWaCV7v1cqVTkyuUyfYEU8nn1w6mZlqZWq5kZsoEYooFNJs3AtFQOg8HgGhkZfafBaLTDGYJ5qddWl/57sVg8hrpniFZqKmUdROWDyXzh0h2/5nS5f0nJSF2pVJ5ZWpj7raPk4YF4PUlLfxYjrv4y1UUXXVqKYu1wViyxTdxwTnRKm8fjjfX29b+ZYSRa2/aSz+deWFla/CI0ErJqgY9WZGJSvQwmk8kyfeGO95ktlgcURdQy6fR/np258TlojiduFVOsh0Hp8rLLL//yL6vX6OpxiEYkeX0C9bHoCHWHx7vDkY6AP1nrFFdWFv9LqVSS1ijS+FAr3lqRaRocDqeLgP6PtLD0/5+3Cfr1tMK6/NDymrH4q638ik3+brFa2VKxqDxGfawShNDvBNiztVpNTfJXeVfsoc//t6WvXACDwYtA+ubGFgXTl0cGoT/cRWPOlZZlgfetmWgPKestrIla9YvGMnVRL3MclCtVkUSuQo9mTRYa+30+EoGleBzylQrsnpzSSoZFy79UECMC4RpTA/RVwDz0FoNJ/ivQBtYDDqwmEyWrq9WqEp294khBkIGfeiXg1alVu9E7AuqTZFNO9Hjp2J3InwQxPh35ELwOB3Bi9gAEuV+/el1WglS4Sm3KO/zC23rveR5z+O0UD0PPJham17N7I6SO7NPzy2C1mCAW6lLcRMmVvs5LoKyY02qBByfH4DvXZ+Hg9JRuTy+uwFAkBGO9ERrmwHEya4CqSY3NFC7PwvRADLKFIg1FoPeY3JvtwyRsJg6psqE/FIRzkW7wuZ2UaBDvgyIAQ/UIiqWR4t5w8Tw8O78C87t7UGN531c2H3/0PYNv+u+gDfqVZFBNoB9aE8O0eubpwhLjU3m+phnbH+mJTpLFZVcnYzKbzbxwenJyAI0vNIC6t41WihzGZrfbJ89feJ/FYnlE0Ul8qVT88tzMrT8sFGgewk6Y+7X6QH+Z6qKLLq3kdmP769b+vv4HOrX2k3d7ZXtrEwF5OxZ/aZ5UWzkb2PtZg8E0NX3pX5L1zSOKImr5XO6vZm5d/zQ0A/5OXfz1eVKXl1yUpNugrYRrFdtPrf09Pb0dW/uzmfSTYrahVpmGGrwhFeXT7y6X2zs+OfURk8k0pbwuAf3LBPS3s/RrKd50pZsuPxJ5TVj8W8QDKd10JKu+2l1IGUusZhKnn8kLWjnYZQs2Aeucx+zaWjndvkCQngUt0pUaB1vxJKwQMOiwWMDvdshu6XLtpIqK5HkSxEawiDH66KLuMJsJWLVSAjl04TexBoGdXjw66HJCqlCggD5FwCdasN02q8BWL2IpIQSAoXUqVio0rz0tVwT128kkZPIF4Ml3P7keEviRyYpayRus/qKXAnofYKw9V6vChdDoptvsyCGZH2gztDfEYP3D3tP352tlf42rwQMTo7RtAILy4UtXnqdKEhojUKtV3hC58yuvC124Sq6G1y67jY7TCU//qtlgSm1m9gcI9jdsJpIQcnvA5bBBozS6/EtMANgco8lIQT66/WeKJXrkSSYHC9t7sBk/pGkMsR8MNNRAan0zG4P0G143FvTTa6SohV7wVGDF/ktlc7C6n4Cb65uwuLMP+UIJY8nA6xAyDUhhGbLnhyhIQuj3uGBuc5f+fFLORvtdke+5jXaJtV9i7m+V71mZrq6Vu6aW65wct4qREiC8SB3KjbTLMXJu/J2dpPAjz311Y231rwhIP4Jmwhy5uaoxyPr8geDExNSnzGbzvYobyuVy2T+/ef3avy+XSwXoPPe0Dvp10UWXM+WHtfa70dof69zan81mHt9YX/0ONGZikeYztYt/SzI/Up5x+sKlX3I4nD8LCiVpsVj44s0bL/wHVXpTrZhiHfTr8oqSDqz9EtBXWvvp1hUMDYcjPQ9Dp9b+5cX/WiqVkBy5E+/VBqWbx+MNjE+e/zgB/Q2cHpS9f3nxt4910K/LyySvGYs/NMcDqTV2LAEshmoVx1sDizg9x2AwsAh8oXmwG6DZsk0B1oSnbyXqDP7bb+xeecdm9uBuI2s0IHBDV/3vzy7AdQL6Lg32w0BPCHiOl+PRedmqXs/7zihqz/BMQ7x9/XPdsD3eHYalRAJy5RLsZdKQr5RhOBik4B/EdHMoR9kssIbGtQiWirnlpZkt6HYLoJWmlVNqJ+qKBATOeF3WYIS/X//+T1V5rtbvCi/84sCbMUaRq9e+DuLw+2kl7yR9M2AymGnWgd5gAKqCxwBcW1lHhnr6uVzl+DdGLn/xDt+5WWhMY4TXMd3lH7vhNjsyX9166l2kXpZvXLsOIz0RuG98RExh2ByPL98tSSFCfnvTndPwpSevwmm+QI/B+5XKF+EqqcuVxRUY6O6CqcE+muWAq9Wg1ftDIk68f/IcZK8WyPXycId/dM/KmHI3j5cj6VrBYWJN+FyRNlZpOsSl3X16bsDtpGSJZvS0IHWQUz1yNerqn0ilQSJ7NLBG09Xk/Fi096Fb0Ejip5Wur5MUMGpPGHXcnJHcT7U2nW6h7vA5q9Ua7mQw5nO5maOj5C40usypx2dDnSI90f6+/sFPqNP1pVOnfzg7c/NL0BzL3y5GTgf9uuiiy+1IO2u/5pwobX23Ye0ngCO/ub72BdBm8ZdEKwxLTebHTk5d+Bmn0/XzoAD95XLpuzM3r/8RWc+ovcE6VZDq86QuL4u0sfZ3MhbNPT2990Pn1v6n0mlq7VeOBYD6Olb5uWHz+fxBJNEkmGJYeU2CL+ZbsPe3Av16eI0uP3J51QN/DRd/FrQnDFa03je584NA7icle9fSNKoVAJIbccVtsCX/Sd+jn90uHD772P4Lbzssps4ZDQbKy58mgPL7Mwt0iwZ8EPJ4IBbyU5K5Ks0HDzIkkkj5GnPD14kAmy3PPIyGQrCaPKTx/qfFAswfHMBYd1hI/QasIkKdb7oAegTQ2YbUA8EuHsCCEqGp3NzJ8SajASrkeCMB/+QfGy+cTD6euHHP64IXfqCoYsME+fjBC9Mm1kwn0fFYDwW3KEgoeGN9S0izR6TP0XXtsv/cNajHbKtJAi2jzt5lJvbA331l+6mfIeDQsn6QgNW9OEyQ6070RcGF4QgaWJ1n6q3CmPxLQwPw+OyCUpVCBQkPdw6PYZtsEZ8Hzg/ERN4G9R2pi9Vihl5yDCpYCOAP/crwO568L3h+Ybdw5Fw4XQ+s5w6ix8W0z2qysIL3BA/HmRzZsmJURT00gQdQlIUKohoSMOxcCpx7ArSt/LJrv9lsrpXL5aYFXKxvgNne2tB6ibDkHAM5pxVxVNPiNhKJ3gedvVS5vb2d70JzHmipLPVDBoNDI5fC4ciHGZaVSQPJmDw5PIz/7srS4lOgDfhbKT2UL1N6Kf1FqgtKu5SuatGfmdeGdMjkr3bzl7yiLG6PN+Jye8Y7LI5Pp06/QwAHenB1krqvlYs/Oz5x/m0ej/e9oJhTK5XKc7MzNz9J5vU8tI7rbwc89Odel1eCaI3Ftgo4r8/f63A6hzq5OGYb2tra+Ba0dvFXfm7wTAwEusIjo2OfMBiMfcprEtB/a2lh7v2npyfIHt4p6Nc9bXT5kcurGvhrvLC1AL9suec4DhnLTQTsSozihmKRAFoTBeFsi2thaDmym6NbHRKfSS9l6WVJAUjMFtz+paG3/vV2PjF4NblwOcXlek/yaQ9jYI148O7xCeyR7YXVdVpI2OcGn9NJreDopu91O2gcvWSpl9n/ecGFvMoJ84I6gh2t/BtHR3CUz0GhWoGZvT2YCHdTAj+8BFqT8fy6V4GAtTiRfd5ltUG330Nj3Bul0ckBU+R5HHYam3/nuUHYSBxS0H3rePU+AvyvQGM8Il2kFLiSYz23P44F16o1OBetG4uvrwqgX2gfV3h77P5/gHrcuhr4m8Tv/DlX7/o/jr3uc1/aeeJdNWCc2E8LO/swv71HlSrT/X0QIqCdtk+ElcrsAXh8X7gLunfdcHCaUrSTl3sXd/snKdg9OoGg1wUXBvqhNxQQlDM8r7gmUE+OWDgIy/tx5GcwfmP3ytDPDbz+StQWSJNtgxzyTIYrWq8kZvr2CsmBVCkbzJbzdrMRvQGMQjAC5WPAhjKokEFGyZzT6Hi61x56/K299zxLXlJSjudWqV9QY0QfEKfTBQaDgSGLUcZut/Of/du/hYvT59VpoehGhgLyVxikZ7tUKtEFLRkjFonNX9oCXcE+m93e8KJrJYV8fjV5mNiCxsUsQzkaGdZYrVZqpAxekvGJqTf5/P7/HePzpGuQem3t7my/f3trYwEaAX8ry5WuPddFU1qldT1DeOk8/fl5TciLtfZbbye2v1bjMuvrq/iuaxXXrwV2lBZ/Cj4I8HjIHwj8K1Cs8QjwmCPA48Nk/s1A5zH9DV5h+rOuy8slCmt/K9Df1jAR7Y3d1+k4zKTTz6ZTKQTorUA/gIbxMBjqjg4Nn/s4WWNFlderVCrXyNj7YCp1KoU26qBfl5dNXtXAX5R2RGVN2nLycpTj9/E4gospkCfgqpXWn4IjEFygG1J4IJDhhSB+2QMgZg9txfpC6OZjK9TKvscOnr+0lNoeI0eZkQnewAogNJHKwmEqK1t5MQMbfjYRgI1p+KTsAKgIsJlN4HU6IORxw2AkRI8RSO0FEr/BQIDa9w8J+K+SaszFD2A82A1mI3IGGKFcq4pBBYz8TyAfBALiB0SivXqKQWCa18lo2T7f3ws9XX5ap2qVo1wG2UoBwbdJ9JgAUAD/Jw9vTAPL0LQDQZ8bLKQdqINAksLFnV3hyqSoqC141WWw44RJ89BDM/BXuv0bB12RvV8b/cef+cbus/es5nbGWMZoxuwKu0ensHt4CkEPchZEYCgaom7+9eR/gqC3w11jw/DVK9dBCrcQmq3sB8rsCEfpLHznxiy4rBa4ONwPg+FuRZQ/I4dKBNwuqthZy+5FN7IHrgFnWALrZZfBmn5T5C5s8BOkr7hUtWjfTO85koVjM6apS5Vz7gJXYh0mWzZo92zdG7wwy/I19PcvYo5ZRZ+0JGIql0q02pi2D7+LqfqUoF85XugzX66UmarAe0HHAoa7gMBr0bTA7emJ3t9h/Cp/cLD3OM/zMuhHxI/p+oSNoykb0dOEFMhOT138eafL9YvQuIC9vra6/MHkYWIf2lv5tRax+otUF1lUymE447PWs6IrAF7FchvWfnV8Md3cHm/YfRvW/pPj468TYK7MiKPFe8K0KJ/+NjA0fDkY7P4dcphZOonjuI3VlaXfIfP+MbSP6W+V5UT3itLllSJalnYl6G9Swrlc7pDb7R7t5OJkaVLa3tpEfg112kxlGGKTITEc6envHxj6GFkndSuvV6mUn52fnfkwWXshV4A07nTQr8vLJq9a4N+Cxb8VYZk0WTSk4VBsmlkAQFv7L7+IRbCrZCiXPAAoQLGx5szbe+5//m099y6vZ/bDW9l4JF458e5nk26eYQxIBEetxwT9Go31W1XhRK4P8ju6xpcKVRqTvp44hKvLa3BppB+GIgKwx2sgaO0n4B9d1fczKUS2MJc4gInuMD3GwpjocXig4PbOwyPTE7C0vQ8D4RAltpN8rmvA1P3NFZZt3Hf7vBT042cK4qU/CH2qBP7UNX85vTcmOUcMdYdkEr+Ng0Pg0MWCtK9SrXD3BqfRY0DtjqicBPHaSstu1Wow59/V99BzZb668szBzMhibrs/U867MaY+kcpAMp2BK0srBKiHYDwWocBcCjNA8TmcNERgdnuH1qPHFig4DNbySTlnNdnM5r2TBFOrcZQ/AOucK5fhyflluLm+BUME/GPmBkzbh32O3BBTAzGabtBisrKPxa9d/Beut28hczOoXC2R9M5tsGSnfYNVwE1UGEEd1JbJDVG687eKXVeK+rmVRB0l0vBcVysV9VgxQ/NL1UoWtmGnyz0MHUipVNw9ONhfAcViVlRiNSjoLFar5fzUhd+wWm1vVtQRFRjfmJ+b+b1cLpuB1hYrPV2fLm1FA/BrjZHmCKr6Xp3kgyoA9GfqVSmdMPlbtLZYrP/BTq2MXLV6vL6++m1ontvV2U7Uhgt5vRLr65+IRKIfJmXKzLa1Wu1ga3MdU5wqycRaZTzRjOvXn2tdXk5pY+3vKAyxN9Z3D2Yj6qSsTCbzfCp1iqE2yrGn5h5S1oHpjfVPkDI+xLKsX3Epvlwu/2Bu5ubH8/kcuo9K404ag52EI+prFV1+5PKqBf6iqIlA2rGAmlWb8oXaRPYHrScgNfGf9FlpDZUGNh3sLLClYVf0kGyYhgyTvDufP1rufjY5FyLAlVUloZe/IlAWU+eB1+Wgm8NkhqhodVeehuAq6vVgdkDYo+RwAPPxAxgLhsBmEuZDXry2FFs+0R+VQb9kweZB4B5AN3x14jmzQjlRKlfoNWxGU1VsvzKLgum55PxQkSt70bqL8fxDPYKlHK87v70rKCKIuI3OzQF7cBea3bW1qA2UQo8xM8bSw5FL6w/DpYPdQrLr+eRCdDW7G+AZgwHd/Zd392FpZx9cNitNsRf2ecDvdlLAPhwNwdZhErLFEuxnDk2/MflzWwaGrTImg8k25XQuH2zWnt29Yd/Mxj3AsMjDR44tw62NbZoNwGIyCtkXHDYaCoHXxHt2Ws6E59NbsXFXbEn9LEBzznmt37TcMFuFsyjBivKzxHaglcbvrBQ5jdb+3tjdyB7dyYBMxONP8agxqdcDRM8YeTy5PV7f2Pjk75hMpouKe8yRl+dfzty68WfVSkVNXHhW+ikd9P+QonaH/0nuPw0rrvKzelOKeiw1EWSSa//Q/XM7PAOS/CTfj1eqdGjtVxoOVNZ+TzfZOrb2Hx0lv1oulSSFpjSPtZrfG7II4T7SEx2I9vZ9nMynbvmitdrJ7s72+/b3djegdYpTHfTr8pMinXjdNKxR7HaHjywppjq5OFmHlHe2NiX+IeU6UyvFMN0GBofvIGPvd8i4U2Yz4kul0ndmb934vWKxIIXWKIF/O9CvRbqsiy4/Mnm1A39JzorNk/N8KjYl+FeT/SmvqaUAaEUgqFQioEgAjG77xRPH7OlKLF449cSLJ04DpdsX5h0E7ggse3w+8DkdNPbfYjKAx+kk34UUcJSQTyQBFBwCpLRwvGj556HH46UAdPP4mMaML8TjMNYdArvJQoE3WvyFxrCyw7qQs6/OHoBpAhmebSQaVFj/8axUPk/rZDfasmIIhNJF0bSQ2ZqWPMN7AgGwms30uulcAfaOjmkGASx7wNV9BdqD3Carh6qv5fsWtXVlo7GH1is8d/BE4mZ49nQ9xEGN1hNT+M1s7cDCzi7YSF28pE/9Lgepm4+y7XMG1vhccs59X3DqiK9wxXwylY8avbV39z/Cl2oV9pnEXNfN4+VgGZ0NWBZKHI8x/TSdIhyfgNHI0nuA94hlDXBUSUUBKPBXihagaPUyaOXForb601sGksNG417rmq1c6LRiWK1Wm81LpCFdTSuplMtHe7vbCxr3Ut53hyN95EX6wWbm/tS/nZu9+UV8MUMz4NdKf6Mz978IaQE6mRbHNfXjK71v26R2ZTU+q9uuHpfKz9LfNfulwzpJ0gnnQJO3gfTllX4PfsKkE2u/psU/Fhvo2NpfqVTiG+urj0NzXL8SeKjfefI+GAxF+geGPqm0OJK5MntwsI88KPPQTOLX0ZypP0uvLjlDqdhK0dkgL/UzcQZX19mx/bG+u8m4sHRSVjaTuXl6eoKhuMqxpxx/DWvQkXNjDwZD3Q38QyCky/zyzM3r/04k0VR72UhrlrYeibro8uOS1wLw74SURwL+Ug5eKzRb/lnVtUDr82HxxHfzdG0CDKx13BlbImAzDtpAtSGV4Fd2npxaON0aMRlN1NkeXcjpipKrUeb4gVAXtYpj/Luc310ikEMOAF5SENTk6HIE+hWM3yd7i8FEwTvGTgftTjATYL16mKSXWIgnYDQYBKfF2nhd6TPDK0L7GZoa0G4yi2kAlXNjPb0gppzDcp0GW1psr3Sg4bic8cWLJ2ETa6RA+HxflJLt4Xm3NraQfE44uAanb43de4vnZFdwaRElTYxKF3SlwqYhbINnwLSU2gwupbcj6XLekuVKtnypaKT1J2UGrZ78STFlqjA1U40cnC2VIVcswU7yRFCaoHcD2c+m1v0E+B+bTGYj6WeuWq3SydpqMFcfCV/cezRyaW/xdMu9kN7ybecS/mKtbMYMBwTxC94ZDJIwcnzI7t270zd6S+wXLRcvLcB61qZ+3qXwh6r4udamHOW5rSz96n6mirJoNHaZZQ3Kl15LOTo6fJ7juIqqzvKeAP4LkUjPbzEs65XOIf1/fJiIf2RlefEZaG/llzwhdNB/m6IRFqX1WUuUCkzpWvIfX2l93caCq07vqvyuFCXgV44h9d8Y7Iez2t+i38+6F7zGd+WCVA85+BHIbVr7m8CG202t/RMdFscnDxNfIe8TiWlfnStcCTwaCInxd5/PHxgaGf0UATcR+YI8XyTX/N31tZUXoNnSr547dfDxKpUzlIqdzu8oL/cc34rUr61xwmw2u8j4uNhJARhmubOzhY3TiutvGhNjE+ffHAgEflXJpYHHFPL5z966ee3/JeMZ+ZfOUrip3yHK9spzu67Y1eVHKa8F4I/SbsKgE0W5VvF8bfvKO06qmdFitRRkWMZB8C5nZIxVs8FYsxksKZfReuo1OpJTwbEjB2vOgkZ86OPJW2/fzSenEXy/cLj45i6zZ+3h7os/GHb1HIjHNGjsMZb/85uPPbhTSPYRQEkPIJgSTASoY+z5eCxKifN4EdgjAmcU8Fymm5P+DIKl2YSx5+Q7AmoTgk+FdR4PdVtsMNbdDUuJBOJSWD48hBEK/i2CQz8vdZhk7edFIrwazUlPeoeWAU3pBQXvgu3DJFVeRGzePagDf7qovpqcHyWgny6q7WYL9HcHaXw9KiWW9w5EvoEajLijV3mOksBJfcZDHfxLv0kTvuSxISlu6PfnT5aGnknMjJV5ziaFPzDi8gmBOCobAlZ38T39b9i4cbTsWsnte7Yz+y6jycSArG8QCo65I5X98pEnbaj0HKSStZ2TAy5bzrNclWMtBhP39r4HV0c9sRTZTsl11/byR7bV7J4zV8obaqQhdpOtOODsTvY7I6gMqon1VXae8llt5TGCpJEGBX+E5jFQX9ThZ9mqYzAYsNEch+yLpA42m50pFPKcomxZi04Wkpjhogn0o3ablG8xGk1Of6Cro5cqAfz53Z3tGfEZ4UVCP8nVH0bHJ9/k9wfeSz5bFOes7WxvfWB3Z2sZtNP1nRXPr6frayFngM7bWRy2snK/okjvWliNlO8D5V6tAJDaqSRqlfbS9TioK9h4qUyttt8mv0Cr/tcK4XlF9v1PsJxl7ddShtL3zu0w+VfK5b3NjfWnoRmIS3VQphlu8Ghzudyec2MTnyTzen/9inzl5OT495aXFjCNrhaZmDokSgopeFmVpC8mxOXlqOcrXTpQ5N7O/I7ySpjjO4ntb/K8ifbGLhmNRkcnBeSy2bmT46MDaAT9ajd/nobBnp9+l9fr+1+hvh5FqZFr/CUB/f+VrJuQiLod6G9leDnzXuhzuy4/rLzagb+WtlPTlfmvVr7+G7la8U284B9PhiZDASKCcIYrkhGaoS7hCKwfS9zk3SZbtsvq24s6Anv3BqfWjcDioIZcpRhihCB5wJRsKS43/IXtJwZ77YGVN0fve8pvckoKA1o2gbuurexBzGA0Ca74Pi+MEcCPcfqi/zyNsxc/NjSpceUnKAQQ3KIrv5EV5iMba2hsfU2+EI3tHw93w2I8QX9aTh7CoD8APpudAm/aAaIyQegMnoI0rE6+XAaXxVavjUx1D7B5kASGhhbUKncFp3ahEfgbNnMHA9JpU329FPRjGcs7+7SP8dBylas8HLp0XXGvQLGX+w+0cydb90vHPd/afe7Oo3LayzLiVUn9gx4X9HV1QV84CAubOzTN33E+bTYwLH+5ayxDtmyZrxhXUju2vXzSytVqhuXcro9na7CbTzqXTredgncC6ksYo9Tvea5sWExt+SNBXwaEsmoRm79INrTi1CoEc29m9q0ZruB58vBm6LCUsnEE/5pZY9FpsB37ze7Exa7hdfKg5cV2Kd3BlLH+VdRMg/Ciq0AjQWU7qw7dOI5TunZyBPRLbv/K8UEXtuTl1Squny5uIz3R8yaTSY4nbSenJ8ezpVIpL5aLmJ/uMbXg5NSFf0oWsO8ExQu2Uqk8u7K08LtkAXvYpl1SnyjBmM7c30baAP52nkzKPQqv+qz24Hilkt61U6q1ChVSh2Upxw/+vaq4vhL8y21vUY92/a71u1K0uAa0SD1fSX3/EyO3Ye3XdPF3ud3dbk9n4U9E+EQi/uVajZPS1LZKH9YUMmi3Oxzjk1MfJcBGyVZeTZ2m/mhhbubr0Aw6WhH5vSxz5g9pjda0QL9UdX8lyhlz+1m/tZJWHEFKZcCPDYwqSP2kup6VUUPeyNrCHugKXe6kHFyP7O5uP6Fqp9Laj1JjiZyfvvjzZL3ybmj0CKum06k/mb1142/ItSQOIrWyrRMCZumzksNKV+7q8iOVVzvwV0pbV6Eiz8XQJxsRosduhYFQCIxGZGSvQbFShnypDOlcHk7IZjNbmAoB7HulozHcnk0uPNTnCG/dG5xcH3H0bD9XWuhmKbs9Cxxa741G9qCcGv3rta/3v7778hPT3qEtsXzWwDOVHntg/6CU6kFgXSXH220WkCPmRSWCtvA01d5pIQ+pQgHK5NyaSMZnEJApBeCYIpAVLfe04fQ7+d3A0CnIZTZDqlikxawdJaHX64Wwyw1iFj8hbAD/McJnhNEI/Gl6OykdHlUQCGWuHAjODUPO6IadNeOkJwP/vcJRV7qS96ILPFr4KYEgHsAaYGF3T27ZkKt7xm2y58X7g5O6NFkqY7tMqVohbGYMBhtjLovHWW6k1kYfP7h+B8/wBobUL+B2woWBGAX7qESpiXwJeyenSqO+HMphZkz8pHewQPrT/Hj8mg9Yge8gXcrK9cMEACzDi20WFCNOg1UC4nSiznMl4/XjJe9GLu7dzcbdRgNmbGRFHUp9Xpc8M35weD3zSPed353yDiDrvZZFW/mbcjHXKi/sWa7xStZoZSxpOxZ/C6bzQ6t/MNjpS7VW2d3Zvg4qkGKz2a0T56d+xWq13Q31l1ytWCx8cW7m1r8j+1ybdmjFpuokfi2kRZYT5ed2G4A2+Ow0BOVlBaBn5H9ulQtdGd4ltVdrHKr7RKlIU/6u7MNW/cxC+3ug1fdKl3AtV20d/L84aWVhbOVarLD2D3Rs7S+XS1vbWxvPQ6O1XzkXq+dlWheLxWKbnJr+oEiAKkktk0n/p9mZG5+H1in7XnYG8R+Bt5EaFDWFurwU7XilSAceRO0UjFrnoWgpF9uFGNJjf0xzTbux2DKFXyQSnTSbzf5OCsjnc6tHycM9aJyrGzYy1swE9L/Xbne8sbGv+NLJyckfzc/e+hJ0lipT/T5QKhB4jf1PimJdl58QeS0Bf6U0LQDNBMsWxD96XU64ODJAganEaY9HohIgQwD22m4CNhPI9l6gf0CX6O1CfHhjbW/Ya3FlqY2cALvJWA9liL+xtgXpPMGwDGv51v6zbyhD5bk7vWPrUtk/0//6a5/f+J7hoHTSnUxl4RvP3oQLg30wOdDb5NTf+J5jaPy91WSESs0MZjEdHdaZ4zC+n4NytQpVRTsk133acFE5gKEAbqsVsuUSPWb3NAXFcgUG/F3iefXwAvxuJOAV/y6lAWAEjQBVD1RJuVvxJFR5rva60EV00cZnTLZg3DpeGyAgn15spDciZxI4TKfhNJunSolKtco/HL7jGtSfzyZL/83T1dFnk/MPp8v5AIYfuI321Ot77rwZLxz7nz9anMR4AWTVf92lCYgEvBRYVzlO7ruD5AktDyVo9paVZSymtxxPJm4F0pU8AbiCtwCe67RZIRrwU68BTP+HmQsen12AcoUDDF3vsXfhdUy5asHwdHI2MHe6FkCWQlQ2mE1WMYRCUNYwYmuoFwkPNLyBvB1c39x95qd38/Ebb+25F10/ldZ+9Iswrqb3/PvFZKjGgs3EMUv3hqdXjTyDGgm1S6daCdDK+qNFIiUpW7Qs/XTrCoaGrTZbqJPBlkmn17PZzCkoFpxen99/bnT8V8nLdLB+JF/JpDN/Shau/5OMPWXKwlZKC525vwNpw2KvBppsi9+1FuDqBaA6xEIZaiHV4+W+J60WjpLnkNJ7RpnKFaBu7ZeUT/8/e+8B5sp1nQmeQs6hgUYDaHSOr1+/QPIxi6QoUYG0R7Ioy7K1kmV7Z7zrnW899vfNjD1rf/bOamzPymFkr7+xx/bs+huPR06SLFk5MYr5xX6dcwS6G41GaORQe8+tKvStQhWAR5GPj3x9H0GgEapu3bp16/zn/Oc/rFOAHRP2WXrdzBBX6gsoX7MPpfHHVgSRvsPSxEGlPyetSbvBaH9DlNHhdAbcNxDt343Fvk7WOlzntGqGg6IPOoPBYDx95vwvm0zm+5htIc34z69fu/I/oHmtcLW186asmW9Qikt97JhnNSr6O94BoDGe7Ty0hKqVTW2NV3t+UxyNimi/GkNLk+KPgYlAV/DuNndVi25vvQCNoLo+ZqhiPEHLC1vYIAXa+bmD+P5/WJiffQpaa2ioOYC1xult41g/aW+/9k4H/qzRpXyfbdwdnae++szOpfNGg0m3trsPff496O3yi0BZiNBiVNpjs8Ndo4Nw76lhuuHdVBqWtqMwtxUDvcEAR9WCgxMV9DEqfpqAzv6uTpjfjMLL80ug1xl0z0Sv3pMrFRwEGC+TTehMnIH7xOD7rj0dvTRwMbE4QMCg/uLyKixHY3DX8CD0hwIEDLNp2MfPGNm3myz0oeQHIX1BIgsg4JRU/6U8fLqi6QTgif0tEXA7uxul2zjI5aBc3YXhzgAzaMLWjUY9VAo1if1PKwFIbQnp+no9+PSOlNfkQPAmA/4bhVgEvQ3VCg9n+nrqZ2J+c5syE5Bl4DE5tgJmzyHIyyBS0F/ha9YvrT/z7q1cfAIL6KEQIH4ly5c8/7T14sPoOEBnQqTDC+8+d4qyLmo1xnHBC6B7amOTHjvwVb7fFcJ+6nOVouEbWy/513MxO26X0wliiMOhLjgz0AsdTgcZk5qY8gCQODqiaQrYTJyx0mnxwHN7V7suJxY6sLwfj2PM0zrK4LBaoSfQASGPB9xOG+SLZcgXSnBUKEAql4fdZAqOikUgNp3uWnLl7Ae775tHBXvc+mvx2d6FzNZQNLsfIp8b9Di/6NjX3vPKwVzmTt/otx/pOo+OAmWdWCUboIEZoNPpqqR/FeaaYIF/A+AXH+ZgKHwXtDbO6NSL7mxfBQakYNmpvr6BnyXzhFWgzpAb6GfEG2g7FNUTEb8WrYlhqFSwVxO1awb+69RHkANQFoSygkX1SPjNBv8q0f5mAm3Kcq5ShFXqvzQHi8z4qBljLN2fXZabAX6lvoBe8T22KcdbEvKsMt+VOV5uAafL26mpRRhZJpRmbn+vEO1vy64qFovrW5vryIRSo/irzRcdWTP1Z87dgQDkUWZTtVwu+1fXrl76r2LVk1ZO3psK+jXYRq3AKoD2/UUtAqoViX7HgaI2Ab/aGq/2vtZ4s+Nb03iwLCPW2fhGj/kNO+E6A10YmAi2s/F8Lre5t7e7AXJgXh8Lh8PpGp+Y/CWTySQT6yTXWnI3tvMbK8tLr0Dr601124pjlG0e5PdO5XODc/edNs9P2pvX3unAn23NKDP83d6xuZXU1vdixcPHEOo/PzMPT3a4wII17nmuTneXrs4qzUsH6HA44J6xETg32A/PT8/B9sGhWIOeg4N0BtMCaLR4pCcEYb8Hvv7qFcxf516Oz054Ta7ypGcAc5i564crXXOpjdCjwbuW4/kD22xmI5QpFPXfuzoN7qVVONvXC4PdAdpj1jpg7Typd8KKLIJ8ZhmgR0GXHY6+Tz+mqQECMEal/9PBEC3xVyZ9zhAgSsv9BQJiRF+g9aMaf6XGywQH8QmZAAs7gjaKz+JEmraBGWvYySc8mVLOaSC/D3gc4HHY6Tjix4vbu1SfoMpX4P7O01K0Xwb6C9WS7fOr3348XcmHhYoCImVeID4I5QXJ3x67Dd57xyQF/LIJIB7zfioNiUyW/mHTWatDzu7yVGrF84PYlLvIlw0oSoi/HQwH4I6hfrCbBb05wfkiHDPudyMWp8dcIrjZaDDq/3T2S/01PVIEBB1CBPwoXHhuqI/OE3QSSGfLYbEC5xEPjfyXKxbgC8+9ChzZ3rAzEiPbd1xPrXU9G70yVoSyC39nNJjouUPQbzLowag34T6clw8XnwxYPblTrn50JGkB/SLzkP4uk9+zZWXqOgxwLJjY8HC53CFyM+xv56LL53N7icQBUujIjZCrDg4N3dkVDP+4QsRva2d789c3N9anQTtSxbIfmlU/OAE40FbZOiWgaSZup2assEYIKxKmBKHSeZLA8E0D/03KQKmBfgvzLEX/WeAvzb8SyMG40hhjaZtaQE5t3PUqf7PnQWrKSD8bWWI1B5ROADgxDNtuakBDq1Z4vQwwWRM73R7P6Tb3wRPQ8E2yzrPrr9SU5SQFHz1pZ8/e8S+sVtsTzOd8Pp//h2tXLv0JU+pUi2qszOu/maC/XbZRu0wjUDkO1fsBvEOi/20A/mbsIbWHFvhXgn5p/WM1TpSvAd5A8K+RnsWuk5qVhkAITNwD6vNH2fhodPsVkFnKx83r7egcGTv1SwaDoY99n9hNu1ubG//H1ia1WZqxarQAv9o5lPUL5POatXu02F0n4P+ktdVuF+CvRUuVXVBP9j36T/95/gsXyDXlRVj/7UtT8JH7L1BqttA48fJkXQBCMxuN8L47z8EKAb7PTy8AstmL5QqNyFdBANoI9j50713w5RdfA85g5J7avTQx4o68ZuaM1dnMeijPl+3PxC4OPxA4s/rpwOPXnt292r2c3vJncnndczNz8PzcPAwGA3CqJwydbjfVDzhunOJV45pXX9Hr/5O+ydW/gKyGiWAQZmIxmiKQr5RhOhal4B9TAvCbZqwSQBkCNeoskLadzuXhMJul9HW7zoqqpgZ2t68lZgYMej2qucNIOASCzhyQMdulFH8cVavekpn0DkbJd6RceXqTKteq1r9a/uYHc3w5INEYDOQ3AY+Hlt5L0UQNngL29991tgH0C53kabnDlegeOl/ocY+4IoW/Xvl2MF5KmyQGQ8DjhPtPjYLbbtPkYWGkPnaYhAI5x0gcyFdLSPTghNW4Bh6bFR44PQp+l6CVgE4AHdfI9cIX+8k0PHNthoB5Ay3L2OMKwn9b/dZDiWLaher32E8s6xjxe2mqAaaPOGwWqjnxwswi6jhwS6ntMQL8E9AY5S+SLZSwvBMIYF96LoqfVRjjU5oUehGYo3q/VOKyXi0hFO4+124O697u7hRun9istfFTpx/zeDseAQbIlMvlK8uL87+ZSBxEoZGRUNHr9VV0GGAZApAbHOy1XJ/Vt/tNT8M41DIC9U0eWuBfzSBR5r5Lv2EXqBrz+5sJQlmqqBLIsaDfyjzje0a73e7p6x98zGazT+r0Ogdf449KpdJsLLbzpd1YdBkaDWLWGcVStdnzoDX2bF12VmiQPQfsuCv1PnTis7KxmgO39bXRqmkIibWK9tcfPX3995O1uM1of2F9e2sTS7pqAQQZMCBNN3nm/KdsdvuTzGd8oVD4x6mrl/6Tioq4Wk6/mpjfzQT9zZyPWkwjZdOKhLLORdVUI3gbA6MmY3kjzlw1x66yegm7ViidjEqhYXadZx2hwGzjh21qx6XlhKNrucfjjdjtjv52Nl4sFPbIWr4KjRiB7wx0dQ8OjfwrYoPIUhqJMbK2trr878TfqYF+ZZRfWfe6mbOLHTslTmEf7HdPwP9Ju6F2OwD/ZqBfdkEZOV1u0jP03WuJpY8h1Tt1lIPrK5swMRihIvfHxeyZa47xjyK46yfA3GIywXPTs9CBEe2a/N5jNhnhvefPwLcuXcXIrenlvemeh7vO7xRLRSPdFEFIz+1eGyzVylv/LPLASr5W3Hp1f67zenIlUKyVzasEtC4ToOwmwHIsEoaBcABsZH9VMQLPaQgB8syrY8ivyIQQv4TAfSIUgjkC/rE0IGoFzOzGYLQzQBkQtK49+RmKHhoIPsQtIv0caf6ShgD5ihQ1FlTcyZGtp2LdvJ4unDAYCtB943bW9uJ1RkXY4t0ix8EqalMhv69vv/BAtlYIcJxgSxv1OhgKd8G5wT4Cmmcp8MdUhjuH+qkThr3lsEeZL5YAUzmk/V1PrjrQGUCLOZDne8aGYbwvLBMBPE4UEE44CvTNbexAigBvHSd3s+AcuHN4ACb7eyjg5+vlFzmJK1DfEjJDlndicHlpjToiJJbAc9HL3bgPnG6YVjHWHYKJ3m7y2lDfVr5UhJdnl8hzSdBd4HSu/WKyfzG15T0oplwFvmQulMvGXDVvI5sxoOyjS29Zflfo3NcHbOFNspECp9OVeCGXngX+2LBcoJGMiZU8bORvLIeDzzaD0eB2e7xt1acmoP6I3ByXLBargYD+jxKj9RQzVBip+ubszNR/KhWL6VqNL5NrrmwwYOEBQ0VHAL9Br68Rw1bKf1UCK/bGelKuD1oa2s0AJws6ZTXCodEwxKYE/Wqik1qGu1rN4jezsQaW8pglo1EC/PjAeW72+fy9QyNjv2wwGLrYjRlNpsnBoeEPGI3Gf7W1uTHFHLdUNpN1iCnz+5Xjb4BGYUHle8rxV2oNsHoDSqO9If/5xChs2dSuG+U5aqD5E6Dh93g8k23ug49Fd74lOlyVCt86xXep73fyzLmfdDidnwDmHBeLha9eu3Lxsy3qhatRjuv7u8mgX6sErRYQVQNDaqCfPT6WacRS0d+W+dBtpGupre3tOHWbOXfZsZbGVrnG60G+zrNCpz9UilGLudNSXDMc6bmbkwzFFm13N3oJKzCBYs0Md0eGe/sGfoHYYW72++Rau760MPfrCaHsn5KR2MqJp3RyKe3cZk4XLWZXw5jDzbu3nrS3aXunA3/W8GrmQaurhb8vfOHFldT23Tko9SMYvLK2Dt1dPnBZreqgWnGJIdALdrjhibvvgHgyRYGznqrCH0fXOz1OmvePAHQhs9lJgP9BTQjsUjBo0Ou4Vw7mImWo6R4NnN94uOvc5sOhc1uv7s10zqY3uvbzSUemUOBeW1yBl+YWwW61QNjnoXRyl80GAa+LOh+kDiLF/CCVoWJ2KPZXqpRppFoAvJgDX6UlAJ3kGBGQGw0G+v6priDM7+3SqD+C0LndPRjq9IHFYKSAFynuHGcRjosg/ehhCsS6eWDQGXBxkuiytbnUhr/K1UyYc4+lColBTUEuOka29hPUmUBe8xf846vi77BRo2sxsxVcPtoZ1OsExgFWWzg/0EvTJ3C88Jjw/YivA84O9glaBuKpr1vL5FiL5TIsbO4I5QNFXYIqJzhLzDo9PHLuDAQ8biqMKKVEUPAPksNHcJusk3GIJZNUE0EyqXFPKCb4nvOTVAtAzEAA1m4Rviq4HNAp8Or8Eqzt7dMUAl5KzcD7FTkfXrsDBoOdMBwO0vPBbgSP93uXr1NNAGk/C9mtsenU+pjJaBSOTBBzEPZHmQ4cJKq54BfXnrnjU0NP/HbA7N4VQb8E/CVPNYjnzEjmMt5Q2Wi/ORSKTJBzZ23n4jtMHMwSsG8eHTv1EZPJxOTb8ZVUKvWXs9NTKOKHCotFcv6LZD6WymUdMV5rFUxBqJTLJ8r9bbY2DO0bBZxqEWepKddQFmyofV9qMk/jm0n5bxK9ZamibDoLzml0cFkJuHcPDo38SyXolxpZG12BruDHCfCfE49ZKr+pB4VDSnE+tKoIqIkLKsG/BN6lcZeAnqQ3IKs1DergH+DEKFRtLYTElKVjG2j+PX3995F5YWxnXwSwb+xsb82Adv6vDLRMTJ79cafL/dMgA/3Fb167cvl3Xifop4+bCPpZx5vauKoB0mbAX42xyZbYbEZBl7Zzy7c2HblaIF+LQaTF7GqYd9AIPJVVhJTrPKsVVJ/Xr9PR0gz0a5bws9nsPpfLPdrODkqlUjK6s70ECmcSAfyT3ZHIz5HrmbVzePL9F2dnpj6TPTo6hNbUfjZNtVl6VzPnutKxLt1flaCfPV8nDt6T1rK9Y4E/Tnpx4VQzgpRetPoNE9XE399zz1e+tPHsL+CNHEHg01en4cfuv5vSsJXWrBQV1kkRXREg2i0WsAXNslgxbZzgHDg31AsrsT1Il3KW7VzcTUCPXtgA0uCDkC9WuIux+bBFZ6rc75/YRv743f6JXfLY2ysm7a/uzQSXMlt+AoL1CGhXY/uwyu+LkWserAj8yb5yhSKlvWNOvNQ30ccgmpIiQBa7ubgdhQcnxwh4dVGwO07A/1J8j+b74++W9uMQJuDYSIAy+kml/eE+bBay9mYydHvpShaNaKkMX20ls92J+eu4t8FgFwX92JC9QPP1yTacBksyYgukQFjU6WLIc5z5md3Ld+r1BvpjEwHXd48NUceJVKnAZjaDg4z3u0i/ayLg5ep28jG3AVMRNuIJiq0lwIwo2WW3wsOT4+TZdgz04XiM2G2VCejGPh8e5eqaAngsYz1huHd8GIQyBc0aTysiIEshkTmCGhwLLqIzoK/LD0PBAKXzEwTS4GzKFgqUIZDM5hUuBY4zGDjKpnA77OAlD2Q+HJJ9HGSOmN3rrOlSJkiAP0v7L4Ec+HNwTIOWoqA2nU5n93cGzrR7DToczoDP3/lxvV5vr++erx3t7+39wdLi/Pel/WOkn/RbRvEH+c1UYiOcgH6V1iSXXc3IZnPb1R5K8M+CSnY9VTpNWWNQaUCqrcE3q6kZXkrKtgT86TwfGBh6HwH/kWYbJetRBBoNamn77Fg1M1zZfijLZ2pVF2DHXEqnUoJ+NREuNne37aZSa71pewdcj0rA0VJBHMGGx+Ntd13kd6PR75J7Jlu6D0AOvOrXyOnJsx9yuz0/x35WKhW/O3X18n8ol0voNG0X9MvWzpsM+ttxPqoxjdQi0GzOufKhlmqkRkG/5cUu22RMaIF8rYfS0cKuWcqoszRmSuduEeTniW1KR+MNOxtb6LK0rKrRHem5k9gppnb2Fd/fnapiOSbmGhkcHrm7qyv0cWJ3sdtAduI3Zq5f+4NisSBVUFK7xpTnS63/as4ZNS0XtbFnnWJq4/66xvyk3X7tHQv8Fa2dvNS68dpn69q6s2Pkqdfi8+8nBh4FjNdW1mGSgPUG3zHZ5CH5HKOvfocD7EazEE3moRH045u8QIV3Wm3Q2+mDTQJEX4xPB2wGCyQqR9SBMNYbBrfVjnRu7oW9qV4Dpyvf7RvflTYSMHtyP9LzwHq2Wth7JnolPJ9e6+B0Bo6TcsjJi3y5TPeHYFvPLCcCjhTWhJqUHkD+IaCmgn75ghCBlujv5LMRfwDWDxMQz2XpezvJFFgMBlpGUILZuJ0utws29g/oPlYyUW+xVrGZdQYcU34zt+el+6zUKEUfwa6edGx+OyqQ7nUcjHr7UFlVFu1/KnpxNFsturGPVrMRHjg1Cl0dHgq48T2MfvsJSJ7o7RFK48mI+ccxd4z4b+zFybks0O9JnwS9bnj47Ckw6vX1aDzNqa/rIIjcAU54NbuxLQg4ggCyBwhIvzAySPpm1kwvqAsCkn/Y3+evz9GKAFU6HwSnSW/AD6cHuqnGgsNiRsYEA/r5+hgn0kfUYUSPFR9UO4CjzIBevw/Cfi8d14ooPrl/mIZvX7pWd+x02jyJCseHyAGkyVym0XY4NhxZgT8pwoWgiAKiDp+/32KxtFUXF5vNbpcJ4lSrlejG+tpvR3e2p4HRGxApr6zxeqLc32ZTiVRqGUtqYJMFmSzYVBqHysibdE5YpylrxKhpAagC/zfDANdQ8lcCb9ZorOtYmMxmr7fD925oNK5krVarSuKlyiimXHtVnWmgdh7MimfpfGD1NovP748QADhgsVpDRoPRQ9Z1E7n2k4nEwddWV5aeBfV7mxQBvSHwr1FnvZ32thRRayEk1izCSNkiPX3997YLNghw2Nre3pyFRop/Q4R74vSZf+b2eH8eZKC/9NT1a1f/PQH/OP+0QH9TltRbCPqVTBd2vTEy32kF/LXSjKRrscL8VqkzIm3rloyKvo50LZY11OpZDfhrUf6l8WLBZ1HcVgEaAagWy+j1jLXasavdx2TXodFodJG1uy0HHDJltre25o+PkauNjo0/4u8M/AjI07VqR0eZ/zE9dfUviL0n6WioRfmV92Blapeac4ad78r7LBuc1GJYqN1fX5eD96TdXu0dDfzFqL/0pxpFrCHiD+JF9lDXHa8kSke9a0exMcyxu0KAP6rQ9xCAxtdp1EI+vM9mp6BucX8f3BYL9Ho76rnfdd4PDQ5z9Z7g9zEPfJ2A0fWjmK3H1VXBd1ElXhB5q1Ha+D88/yL3wv61QavBUp109x+wx2fXW8pPRO7bvlAcSz+9ezUYLyStZV5iAYlrCCeuFDzQ6HKtykPQ5yEg3U0AsxN8bgetTy+BTCwzV+NFR7m4jODv8Jgwj3/vKCPQ/Ano3TxMwXhA/C35b7QnDFfWNgT1e47Tv3RwPfRI5/no6lHUnudLFj1Z2zANAvPXUc0/eZSFg3QaDHoDlMoF/i7f2B4IxhVdNLPVgn0qtTyM6x2yAs4P9hPQ7wV2XSuUSjDcHRRK80EjI0P6ZjR+CEvbe3UAjO/3BXzw0OR4/btChF8A6LliEXLlEvhtDqkIAuzED2B6fZs6EZBxcGFsiLIN+JqSTau0lgVGxX4yA5cWV6gegSQYaTEZ4cGJUXDYrGAm592Ewonc8RYkVoOkDfDS3JJQ/YCMn9dlg4lINwx1B2UHTFMVyL9UNgvfv3pdEE4USxoky0e+b2y99NHnjdcS467eS3f6Rq/ZdOYkHANuaedsST8KirqCoUm4MSBQb6VicXpxYe6zqVRyCwTDoS4yKFYWkFgHJ8r9bTYNwKJlGCrBvrJ8HVvGrm6YkGbs8PnDHo8XyyN1E+Oqg1y/VnIWyBSsZQiQWTtMHLwWi+7MiNocaiwrpfiW9Pxmn0NlLqzaeLBUf1t3d+RucszuVhsul8pboB7Jqansl80T1zoX7MOEYxzoCo4SQ/Ruu91xmvTJCSrXXigcvoOM+2+urS4/D3IQVFH0pz4mas4WDbDfrgNAeR7flg4A0AZYmvnEVqvN6/V2nGtz+/xuLPoUOV9qucDSM31NQP+PerwdPw/HIEQE/Vd+o1DIS1HHGwb9N2kMm+VlK1MmWKcjC4jY7bQK3JRBToVuJhAoE7u8lcB/kyg/myahBJBqjkQ1p4om8CdrutnhdPntdnvAbLF4jQajk6w/OM9rlWo1k8/ldhIH8cVs9ugA5NVOABrBp3LOvZ4IdKs5xJZfra+b4e6eMwaDwd7ODsjxzJXLJUyTqRL7lT81Mfk+pfAwXnLJw+SfzM5MfZGpmNFMtV95r1ECfq2UugYtF7LeI+yoViqVAvM7pQ6A8hpnHby3PKvlpL117R0N/FWaFvhX5i6VOJ7P/1jkXV/9ZvSV4mxy/SxZCLnvX5uG+0aHYayvm4I9hikPPruDgrbNwyRcj+5At8cDZCWtLwu80hdHngNuF41WJzJZLpo7MCJYs1vMYDGaKFDDvPt3n5mE71y+pvt+7LVhm8FcG7SHUiC/oXFWo4XvdgWqeosBtpO7dceE1EHMo0eHxXCwi0aWcfmgcibiulyp1OopC+h4wC/wbEfFaHPA6YA8AcNI+weaa16G6d0oAf9dNGKO7717coIKFyJQnzpc9t3rO52cTq74dLhT8nmYAHehGgEHC5tRXODo2HRaO1IOnQV7ZRZ7rv/65osTpC8G3LeXjCVGs9m8eewj6hvoOXZg2Ti78N5OPAFYnrGu9kMOfrQ7BPedGjk+P8yvE7ksrU4QdLspaMZ346k0vDi7RJ0e77njDIR8XjomfE253+MTja+wlCMK8M1ubMHC1i6NxheLJarBMEIAOwoBotOink7A108cZYfU75xk+F6YWaAOiYFgJ4S8HvC6HeC22mjUn2NEJ/H/qL/w7YvXANPk0bmAAo1lrDJBxhsdB7lqoePS4eJjLx/MPtxnDUw9ErzjlU6z+4A5AMngrdNZnU5XU/qz1jVHDIanZqev/2mpVMTcOBnoB+2yU0plZmWk+HU5IKT2dr8hNolqs8YhawA2GErMQxZhJnPJ2Bno6g8Euu4hoHNSbzB0gAbws1qtd3k83o90d/fMbG6u/ykBNgvQaKCzIFRSOAZ4E6ITbThDtATarBynQ1bLfe3sJ5fLroK6wJYB5FF/pTicktYvOxcms9nV09P3gLfD94jJZAppjftx4wykzx8mwP9VkINApXCUalWFJoBf7TUoXrM3CbVo0y0FrNRaG0JiSlAlV/Lv7buBaH8xtr3VOtp/SgD9/wLkoP/7BPT/JgP6taj9zZhSN0PMTzoeLcDGjqEaw4WNQqtF+1mxOSkSjb8rgTx6rcYWYOcrqLx+y1ob81CLvaV0oGg5U+qA32gyWTs7A0Nk3Z6w2mzDRqMpSJ25jdT9+hhFenpKhUJhem939xvbWxuX4fhaVzIwJJHTG04xakOXRVPJH/vv7wycb2c/GGjY3t5E1iFWDeInTp95wulyX2D2jbZddn9v93eXFuefgmNcoAT9UlMD/M20dBrOi9vtIaeka9LucI6bzaYenU7vwm2SvibyudzF9fWVL6RTqSg0Xgfstc5WD7gl5vVJuzXb7QL8tXL8m0b98fHB0D0vEGBlns9sjekIQntpfgk2Dg7g0XOTYnm2Y1q/02yB06EgbCVTsHF4SMFjv88vgmlouBQx6jvRG4Hnp+dFyj2A0245jviS74d8HkrjXo7t6v9p64XRj/Y8NB+xBZDmp8vWCpYvrj/TF8sd2EwGi5RyLkTpqzVwO2ww0dMNfQQoovCcpDIPNZYSz+T443GIXS1XBTG8YrVCgGsZMoWCIGYHQEE+pgUggQGBLZb7G/D5wGOxQtDnhvGeMCzuxHCQdV/d/EHkoJiihhHmwocJYMYfGggAXozFhH2S7YzYuqVoPzbdQnrLv5nd69Qb9BR8n4qEBbV+pmH/9WIIH50bep2u4fNsqUDLK0r4HJ0pD06MQW/AJ+bzy6P0mSKWJMxRzQCHyUL7V6iUYH13n1LwMS3AajaJzhU1m/y4P0fFAuQLJaqzgIKIp/si4HM6IOB1g9NqoXT8ht9yx6+FlBFhP7g9dDL8+LvupSkP2He9Ti9zXEjTBudVMp2Fh06Pgd/jpHoT1AlRqUDsMA17ZH4eZDIQTSRRRMG0Uzy467+tfOOOTpN7/YL/1KUJdz9GM2Ulz4Kh8Di5ud7QeoF5rIeJg7+bn5v9As/XUPwhLz5YbQFN0E9uhnwqlVQz1hoHXPtvtd++XSOStLWgsrfKSa5HK0EB/BHAdEd6zgS6gu81my19oG0IKpuOAFZUu/+/LRbr76yvrbwI8sgz9octQ8QahNybFJlQgn5l1L0hguvv7Bwixx1qtWGc14nEwRI0gn4JqKkZglppFrQPBOS7+gaGHu3wdnxAbzB44QaYNeS34xaLxUUMczb/Vg0EycBQkxrrnMZvtK4trUd9P7f4ddYqLUT1OjJbLJ4On6/daD/s7UafE6P9WmsagpAPEdD/cyAD/UWk9/+mRqRfsl3eMtDf5jiy1GyJRcYKJLJsIxrxt9nspDmIWWH1GI1GK1mf9MSGyKMD+egoE0ulUnu8wBaTHF1KYcD6uCpeyxhHb/X8bEOjhXXksowJpUNXCfzrKRRk7IyhUPe4r7PzHpvNNkmG0gHtrzEoko/sljv7+gfOk/vDxZXlhT9LJZOYmsmW95NeS05e1gH6emj+7d7TzF1doVGz2exrZwep5OEqAdNpMqd0E5NnP0zm2Dg7FmSOHWxvbX5mc2PtCqjbKGpRfuU9piXod7pc/mCo+26Xy30PWcMH0OGu7Cs5b07yvb6JiTMPbWys/fud7a3rzHhX4fjeqjbvT9pJU23veOCvIfIn81Lq9foaFgonF15ZpPRIaskUnDwRuf8Va+wKXIrPjxmMei52mIIvPv8yPH7PeXCYpQC10BCnRdwE2BGQuHIQh6noDoTJ30GnE2SBePH7CMqfn56jABQ/d1utzK1aUGO/d2yYivfVOF7/DxvPjP1E/3sWwxZf4RtbL0YSpYzdZDCBFGHGbWDe+p2D/eDzuOrAUSpHyNexpQAms+UiBfkVGhGuEpBbpg8UMjRwmHagpxR/KwHdXtI3I/nbqDfQCHIsnYZSRRTpi8ehy+GAiMdLS+JtxRM00k1ApVU6blTjx/z8CtnvzkESSuUKVeUvlor8nYFxBIZmcVh0ryZme5DuhL8d7Q7CQChAI/UNjXxhP3tE9RUk54mgxi/kvj9zdYYeG+bRj4S74L7xEVGQEIBT2AZYgWGPAGJ0SnQ5hLHD49xPZ2iax/nhfgFsg/JOpsjoJ7/DfTstVvBY7cdWHtO/SpVl1as00SEiVaXBNImHzozX55CunrJwjPx5kSWAn/ndrrrwYql8vK8uj5s+hG1wtLLE/NYORBOHumQ1N/Ct6Kv9z+1fTZx2D809GJhcx6IH5DxYfT7/wI1cd+TmmSU3qT/fWF9FCjI6qvLkJob5/PQBx9UEygaDoVZBr4SCukZAP/T09tMBIDdhlZPflIqsRgN52zsA2gD9rHGoBvjrFRqYh7ErGBqN9PT+qAj4X5fxQOaqPdzd/Su57NEv7u/vLYt9YaPP0qP2evfRbleg0YBuBvrpOASDoXvb6Ve1UokeJhJxxXnAY5RABcuaURqtMjE/jFT1Dww96O8MfFSsInDD44LGocvtCRcKsSRznK0oz8prR0ktVvub/Z0y2l9TeZbaLQn+WwiJtcrtN5O16W4CoCzt7KtUKu2L0X5V2j3yegno/4jb4/1pkAv5fX/q6uXfLBaLtyzoV6xJann9akKasmox+DkKqiHTqLMzcIGA/lMGo8GPgBNUrgnUhanVqvv5XP7VWGzn23u7sRVmv/Wvic/snGSvz9dDQ38zxg5Afq0100XQSg9SAn96H7BYLE4yT+/zeDseIkA3AD/8uquzWq13j5863Ts3M/1vyT0aSwNLGi8GaCwv2paDt0m0X2seyZzY5P51Vzudx9J9OztbU2aLRUeutw9brbZ+9nMCAzZWV5b/PZlPeP9SXmtaFTjarpZDmiXc3XPW5/c/arFYz5A5b4Y2mk6v7yTn8dfT6dT/dpTJsOktalUwbohpcdJuv/aOB/6Kpgr+RWVPNtpPAf9RrWD8+vZLjxf4UpeVN2c8Vmc5U86Z8JLCaPjXXr4M5/p7YTgSpKJsEsG7Rl65zBZKgZ/f24PtVAqSuSwMdXYSMK2Xu5/JH0MY0Y/uUUE9LKl3bFGJVdt1Opjsj8DU2iYG6/Vf3fzB4KeHHl8mgFa8yYl7Rsq820kBohmdAXXauLAjQaxPAKBFAu4RuGMeuwSBMRpuIKjRTQAriv1hZN+k09NnfOi4Y717fO60O2D14AAO83kKUqOZNHQT4I9j8N47TsOXX7wolDLkBH2DSKePMgXw90vRGI3kI7L3Wlwlq86EXaA3+fn0hmc3f+jUk7Hyu+xUxb+mEmFHcL9G9h9yu8UREKLknNjH66ubcJDOUiD/HtKfsN8DfK3xvidNiBg5T9RxQ46Bo2yGGmSLBTCZDBDp8MoU9uUrqnTmxfMl0u45nvmemErB3AebTFGOEYgUPQCiE0h7YssZHLhzHprtT6gi0BPwQW+XH9K5HLw6twybBwmuUKv4Xj2Ye3DtaHvkx3sfvdgf6u8ymky2di8yAowSKytLf7i/t4uGbk585DFaA8fR/voNlTS1nFTaSQL4lTcvTuW5WUSSPV1KsFL//FYEJsrWgk6rplbPGtrKZ/o5RtOGR8Z+xCVQHfVtdkWzEUPd2ds/8L8Q4P9r0Bh9Vosgv2FjfgM0f2X00Wx3OMhy5myrDFQ2l73My3N82Gg/S3FVAkhZ2b6urtBQpLfvZ8xm82n44Qxyzm53YBrOAjSP9Gs5AJSgQ2l4S38D83u1eylbOx1A7gC4Va+xdtNCZI4ish46fT7/He3uhACJl8j6J5U7k609eL84PXn2SZfb81PMOGPJvu9cv3b5/7qVQb/GWLYC/TbxIYF/BG6j3ZHeDxGgOgRy8K6+I44jJokh7HA6PzzkGH0i3B15enlp4b9m0ul9dmxB3Sn1w+Sfv2GtiTBrM1q/zPkEjawJGuk3my2O/sGhRzwe7yN6/Q1F99tqZOy7BgaHf/rK5dc+C42CsGrpFu025RqkldpQX7s7OnwRm93e3c7Gs9mjaLlUzkyeOfdjZIyC7GelUun64vzsb6VSyRgcs36la0wN9GuJLDaAfqvVhvfFd7vdnvcR8N9GCpfamOuD/QNDT16/duUvmPFWskNYh+sJ+D9pqu22AP6MyB8b+W9G96fg/2ubP3g4VkiOIu46hAwNkx5TqoWo7WtLK7Aci8EjZ06Dw2ahEVfpikZ690QwCPO7ewRgl2FqJwqDSIlHcC9G9PG75/r7YGErSgEjUtslGjlrHZ8d6KXAH8F3gS+ZvrT+bM8joTsTf7v6PRsBiTqMDNdqVbj31DAB/UbZHU3qr/SOBAk77DbwkvuvRJnX0QoAOpqagFF++d2RB7ZXQi16DvrJ8RiTSdg/OqK/x+g6/t5Nto1OkesbW3WWQaSjg25QrxeBP0bmySdDzu40iDT/ZPnI/L3oa72kHxQ/v/vcBByXKzg+JtQJWD6IU4YELV1IQ/h8vafo2Li8vAYeux0eu3CGlsZTJQyIG94/ytC0hrDbQ504+MlRqUAnideKY6SZ/gbSfYCr/y2eNe5YKQE4yV0ingue+Z5UW1DFUStgfZ7ZNnsexbMpOnVYxwQneyF3WHD1D0RnAXkTHU6P3XkGdhMp+O7V6/TjRPkosJjeCt0XfKDtaH+1Wk0vLc5/7uAgvggM6IdGej8rRqUK+pnNtktJlh+sfDttUZLxxS0ITppFhrRAPwv0WSO7HiXpjvRMEmP7SWKIeN7IvhKD6u5QuHswurM9A9q1it+siL9a1EgtgisXhgpHsAxUO3XYa/t7u6/A8aXEqvlzKu83UD1NJrNtdGwca7N/WCviQ8DeLlJSvR2+CVSrbtUpslEfNFfpVgP+WtRiZc1ptTrTAI16OWzeKQfyqgLYbkXw32y+aLFDLJGe3ruIId6WM7RcLiW3tzYwp7hh7cE1m4CQj5O58CTTFwL6C1+funrltzXU+28Z0N9GBQ0t4I8ibEjft4+MnXqcgLf3k7F4XfYoOgFsNvv7Jk6fndxYX/0MWXfmoHFuss9S1L9u4txsIbQ2QX+rdC0L8zedp2ROWvoGBu/r7Oz6AHntghtYZ2u1Gq3AJAr7tWxWm+1+o9FkI/NbKiv6uhy8LapqtCzhF+qOXIA209JMpL+nz5z9MOm3l3mbz+dzz81OX/9coZBH1hRL75euL6n/LLVfq6rCMeC32ZwDA0MfcLk9j5Nx9bbRxabNbne8W683/FW1SkX/tNJb6uf8FlxvT9ot0G4L4M80FvRLBkkd/DM0fwr848Vk3SOIYNbjsNGybRajkQqmYc45vva67GC3mlVXN/wd5v3P7e1CgYB/pMQHHA7o8XbUwT86DHo7/bB1kGBKzSk7zlEgfWVtnf4uVkw4VtM7xQ+G74l/c+flTvwZgvbvXZ6GD144R5X6gVdZ9UWKuxTFx0ZBI3B1RsAxHD7OgedlABVAkrrH7yFYRjFDpMrj8fJizgFS4+e2ozTKj8c1GA7QqgKr0X0RcGJJvDJMegYQGJp2CwnzP64/Gy7zVQNG+N91epyK4DVqI9ToOOLxhpwuIX+fP/bpYCrBxcVVGOkJwb1jQ4wLRaLFcyLeFv7OV0q0ZKPLZgUn5sPzQPuM+7GbzGA0KLUF2C4pwboc/vNi1F5iAeh0EuwW2RP0T50gFAhCTj8eDzpQMFcfxwE/q4mMjvpeueOt4LatyPDgpD1zwOR0yM4o68ZRzrSry+uwQM4XajEIfecrD43cbbTZ7S1VzqXvb26s/78E9CPtUg30K/P62ZuqmuCVcpDVjMxW4F9N30OLkgzQxEB5q5qG8BNbg1mtvBFLp2UjbBZiONhHx0897vV2PAjt5/HzpWJx5zCZuHyYSKxjvjHm3/YPDH1EpJCyTe/vDDwiGuDN8szfMEqiiiHdju4BNSQNBoPN29Fxtp39ECC2ToD/BvMWG5mqKfbfUL4pGAoP9vT2/+9kzIahcXlGwLdBxu35WHQnSq5Dy9ip0w6fzz/Zql9kLbRDa8CvNv5aZcKalftiryfWeS49c+IzgLyWOrwR5/qNaK9zvtBrCwG/3x+4s9197e/tvYaphKBQ4EZH+eTZ859yOJyPM33hybX1lWtXLv1HLDkGrdX7b7VIf7NUiXppWPKwI+g/dfrMT7jdngdAxVS50UbOS6ivf/C3yH3yV2PRbaZUm6oQ2g2Lz71Rrcnc04pwK8G+WsqWqbMzMNDbP/ik2WzuaXc80ebNZbOz8fjeVHx/f4f8bejrH7inM9D1rla/JXaHtcPn69mNRVFwupnDEdoc52YUf9XcfrvDgaLDI+2OPZZrVbxVS6dTX56dnvpLco0is0bNRlFjd6mVpmQp/eah4dH3knvsR3V6fVvaA6BQ5VdrOMc9Xm/nQXw/A81tn5No/0nTbLcb8MemRk9khajq+f0Dju4XZw7Xhg16vQ7Ltp0f7IVOAnApQCagTMeqsQOnmsMvgauJriCsxA8gWcjDfjYLOSxDF+jEQnUU3CGdPf5ymoBMgyoxG/+eHOiF6c0tWi4P+/BaYtb700NPxD4QujfxregrHbgzLG/3pRdehfvHRmC8N0zz96XesLFilpIu/Mcx35GvIXWQKEWUJUzJ8bCbTEM2X6TigW67lZYilI6bHtfwAPxgbhFGI2EKKLH2PDIkODEijjn+2/m448X9ad/K0ZaN4/RUaXAkHIShcJcM7NIKBaQvi/E9uvoO+n11YF0VgTM6GA5SGRjtDkOXx9WgC0CPhJPo8BxNrzg4ytJSegG7sw608WOvzU5ZDDo4do6AuC88FnQMVMjvsbQePlcoUK9RPQGcH1iSEb+DzzWxukJV/A62muggoZOQr9XTMKTIPScOtLB/HXMMQPtt1hsEx5PNChacN7xwv+VUbh1y5wdX/xuPL5ZIwlPXrkMJ55XYF4/BmfpA5J7Vgb7B4XYvrFTy8Omd7U0UxNEC/WqGqxroZ6e9GtBXUpCVTgCt651l+qhRkt+S6E+z1kL4Scu4ZsG+jFaLlPax8YlPWCzWvja7wJfLpd3o9vY3tne25vlaTcpj54jBmCKGzRUC8t+v/JHJZB4EbQAK0MS4+SGbGm1bLdpfNyIJGJ8wGIxtObcODxMo0KZmCLLRfmXECsW1DKPjEz9CxuvT5PpuiBRXK5W9WCz6tc2NtXmytpjFc4bOlqO2DloQhlK7LtSuIYDGMWqn1rQyf1qNMceeY4naju2WEVNTDp3GOGiCDSwb1g4Lgw5ApZLdEqL9LDCvEWCgO33m3M9iBI8ZL76Qz3/h6pWLv8fUDL9lQf8PkdtP1yQCjN7XJuhHZ8hi8vDwZfIct9rsfo/bc7fZYhlT/hajqn39/b+WyaR+KXt0tA9yh5SW1gi9dm/GvLwBh5O0RinBvjJty4yOy+HR8feTteXhdlkTCPgz6dQLG+trTxHgmwFGNHBxYe4HTpdrkNwjwi02gylG+J0ZUF9zbmQ81KL9LbUNurt77rxR0WF2DA4O4n+5OD/7VfIa7RUl6FfS+7VSMGQlE8n6MNYd6fmfNZy77P6LxUJhMZNJzySThxtkvmY4HWfy+wPD5J70hFjCVdn0TqczRID/Gqiv8SftpLVstw3w16D7K40XGdX/ifB93+JqoJ/LrP9ktlAwPH99AR45OwFdXjfUNIOTEqyWN7QVB/1+2E4ewu7REWRF6v9YIEDBG0bo33f3GRGSqV+/uI27CJB+aW5Z+Jug5u9svdTxsYH3HnZaPQj+3fFi2oC/foGA7dnNbTjT3wODoQDVCeCl6DHa7jodBa+cKAhX5asCyG1AjY2RYfz75bklmCPbx7/0OgHkI9jtcDng/tMj0GF30M2g/sGz0/PQ7RMqgmFKwWY8QQE/pf1zenh292oHDVBzAgOhq8MND0yMNirnk98u7e/R/fQS0M8xOj06MQJOtQcI4EcRvlo9PeG459RyxTQGXlDJTxcLtDyhy2KmIoFYDYGCcxDAfalWpbn+eHzIJKjxx6kSHN0vB2w1BTq56uwD7cax8AdPB6cTHQ4cLe+nE8cVWRkI8ClDg4B71CuwkL+RbaIXRQqlyhIS6K87oORYv2GuYqrKSzPzsLKzS889Pc81vvxw4PzKBf/YXk9vf8RqtTnaub4IcEmuLC99BRqV+5X0fqXR2iB0Ba0Bv1pumxYdWenkk+jHrMq85AB4O4CTZqXplKDfzry2+vydA8TY/iQxFNtlcFSJQfL9pYW5b5VJg0YDX0cM8T3VDh+DWzWg/4YaKG3k9qvVYq8/Oju72hKGImAss7W5cREajUGWOdIAgmx2u3N8/PQvWKzWdyuPXTTAv7m4MP8tYgXy4vmTlJpr5XIp107fRIO/VZRfKWymlU+sFsViKaWsA429b6qVYOMV+5Q+e8tak/nSUkgMo5yBrq4L7e6LGOhXK+VyEZg1yGgy6ScJ6Cdr6z3smORy2b+5duXSH5H7juQkvdVBP4D6NceWrlRdmzp8/gF/Z+f7ofVaUN3f2/3K8tLCUyIVnR4zOQ/P9PUP3BEMhj+p0+tl65leb+gdHhn/9NXLr/0hyCuLSOBfWV1EOo6bDfqV16Ayj10J+JWiiBYC9iODw6MfN5vNbeW4A3WiFGbWVpc/nziIx5j9G4G5/2XS6eU2gD9G0P0q4wjM63ZZFa2cRw36BiaTyent6GjJhlJrZC4dRXe2/3h9beUFEIIUrPYQy86RzhU7TkqxVjrfyXVtGRuf+JjT6fqwmkK/NP7VaiWaTqWe2trafIms/UeK7RmyR0eXKpVyvq9/8NOgcn0YDEb76znmk3bSpHbbAH+mSUaITOAPRANGVPbHBQAXAtPjkfu+Z4mZuSuppZ8olMvGb752lQqiYc59p9tFo71KcKm+zAkK60iJR/YAiuIhYJvejUG/1wt+hxM8NjuNCmuJv2EkeCQShqnVLciWivS99VzcHC+lzH6LhxbYkxjeCONSuTw8R4Dd09dnybatApuACvtVCZDUgdNmAYvJDP0BPy0bSCPVKjBfGjSM0M+tb8PV1XUKhhEsCmKGYo45WRaT2Rx8i4zRE/fcAW6yTx0B4N0dHggSMI/bWI3uic4FYYBqohgfOh9w/31dfloyTwL91FHBC3XqN5NJClaxSoLNYDrmMTDmJHUAoN4B+U2eYJVCuUKV+fE8YSpCkfyNufw1XqDRY1/wEc+2sK/FFAypZGB9EonUfOFgBOBu0JOHziBqJXBUMBEj9jpOdD3ohPMjsAkEgI+A3kQAvV7UV5AOSCdpLfCN98066Jei/FK/6ieQ8UYwJ5UAGLiysg7T5FzSygFk/+Vaie+xdu2/P3z3stfkLGMNmXB3d2+7F9Vh8vApAgIP4Rj0szn9Jb1eXxHprqwnXXZQDodTd3SUkSadmkGuBHM6aKQjKz1XyhxkqQ/S96SSB1Ikm2UBvKWtBaBtB/RLwN8aCkcmiaH8cTLn2lIhx6oMBOT+5dbm+hQzFg3jT4zIpNrvxQjKzW7NQL9qKT0UhrLabG0ZzcQYfrVIJjnI8/jZuQmK93VdwVAvMeB+xWAwDCi3Vy6Xl8j4/hkxQDfg+DxK55XO10qlUmynb6hWDep0T6U4n7KPatRi9ll6qAF/CfRLLDkt0M+C/7f8utIYh7a0IAJdwWGz2dLZzsbJelck5/c6MGuQxWIxnZ489zNmi4UFLDVi7P/l1LXLf06uuwLIhcVuOdCvGD/lOt2MhVSP+Pf09j1O7ommVjtIJA6+t7gw9304rqNOWWJ4P1xbXXmVAKiN4dHxXybXl0yozWazPU6uvS/vxqKLIHdeaUX9bwbol5oyT1xLo4Vd09ln+hlZV1BL5UPtrulkzPLx/b2/EZ0oFaYv0v7r9elzuVy0nW2KTuTXNXYajBGtaH9DFQNk3uj1hrZFh6WG7KrV1eU/2NuNofgwrufN6P1a6yTrANB7O3yh4eHRXyTg/xSoO7N4spZvJBLxL66vrb5cLpUqzHYb7CHSt0VyjWTFsovK88j276SdtBtutyPwx6ZJ9xfz/HFcJPBvfjR4x3OdVk/mmdjln6jo+I7teAJiB0nwuRzQ10lAs99LI/aIuqmqPKO+roTwiA2x3j0q/i9i9Jr8W0scQiZfhH6/r14ujheY8A0No9APnh6Fb168SkGhnqDGV/ZnbfcHJot7Rwd6AwoK9nTD9Y1NCroRrqJY3VGxBFyxLFLJyYGRbWfyBdrBxa0oeB0YqR8Gv9MJautWtpiH716chiNq9wprtTyd4fhIMbvg2soGPDQ5TgE31q/nROC8srtXLzNHfyu+tpoMcNfIAAwGgzJ6PgW25Dt72Qw5hgL47HbooEFongLkQrkEWfJA/QQE9VilAAF+mWwDP+eYe3rdpcEJwFup0i/9RZ0C5J9OjOjTqLvBAEYyjlT8UK+jYy8AfD0F+PgbqmVAfoMpAlLOfsMp5JkXDKVf4omwGgvCGMm3oAyZKSn8IDI4eE7+fXzeO0yT8d+F+c0oBfuc6IAxc4bs+0MXFiY8/Qnyhp4YttaRsfExMn/aUnlHY3V7a+NZaAT90g21IlbOUOZYyoaeAf1qImNKsR+D4m8l+Je2zYJ+VhhLJz6D4rv1376VUX8NBX81Q5Gti80KZ9Wj/ZGevjuJEfHRJlEIWSMGSnxlaeGP4/H9DWBSIEBuAOH7evJdVYCPxhUoxBOZZzWWxw8zTq0ox1oGpCkY7m5LGAr1K3Z2Nn8A7KXXSPNn3+cGh0bu7QoGf4kAHAUtnC9lMpkvzM/N/H2pWJRqMQMzvnUDtCbUKW/ZsH+Kt7Qi/dJ+lPoQJmhMg2DLg0l0fxb4s6BfD43AX7rOlbRquAXSaVpF+1UBRzAYbjvaf5g4mC0Wi3h9UIejzW63TJw+83NiGozUqpl0+k+vT1357+Qcvi1Av8Y1p+U0aYhad/h8/TabvWVedqlUiiLbCJj7CCjWo0TiIEqA7OdGRsd/Dcta1k8ux5kIKH6SAP/fB3W9CjWn6psyfhrCrGoaLZppEcCka5H7sn381MSPeLwd90Ob7Klyuby5trr8x/t7u6i/I80jgOM1hwX+fKVcTrSzXVHgUjkfX++YtHK+1QUNsQyq39/ZdlUNqZH1dmlhYfZz6VRqCxpFh28E9Ncj/eT+OhmJ9PyyVi4/sX12k4eJz68sLz1dJogf5CkNasxHnpyvWrlciZvNjcCfbCMN8vTEN/SeetLe+e22Av4M3R8ba5xI9F9lBAMXHCo8N+kemB1z9f3J17dfeM9qOnqB1/NGzG8/SGfAREA2Rv97CHAPdLgpdV8vlffj5ZBOWu2sJlT8D8ECAf8IVA8LOchGSzDaGQCTQS9+/dhWY4uzBb0eiPg7IJpIUo2ApfS22WV16lCEzmGzwr0Tw2A1m+DVxRUaVRaCvhwx6MuU8q9DVCiJzInANuh1gcNiAfY+wouR/FQ2CxfJto4KhfrnFBzXquA227MRiz+q5/SVeCnVEcsfdurJj7A+fICMyVgkBF0dHtp7BMjbB4d1sIrbxkpup3q74cLoEGYfiGX7hCOlf1cFxX0sPajXCdHvzcMErZKArAdeivIzzAR8ZeQYzCpVBeBEME3+wzx9vXjsNqMJzFjK0IjlCw00Xx6Bvl7M7xdT8Rto/nW2A7IVoEZTAfYyGTjM5SDs8aDEbl1kj5OEEZUcf7HpRLDOFkwU8vpZe51rcCXwzP+ROYBOF3SQZLI5mrOPooVJ0p+9wxTVlaDpCXqOpjSQMcpNuAfWHw3duSGeE73JZDKOT0xOIPhv97rK53JXxXxKFuyzHnSler8sT4YYgbpcLisNihbgb1kjF47BhwTklBoe0rWtTAng4bgc260UndQCJ1qGojKv3x7p6b2DgP4fbzf3kxgVm/OzM3+YTqd2QW6UsOr1PNPBqtp2CoX8KvNdLaPwjTRWtCJHWsDWZLVavS6Xe6ydjZP5OZ88PNwHdaq8zPgma67u1MTkh90ez6fJRzJnCzECt2PRnd9fX1uZYrYhOcHYyBsL8lo2MSecHQfl3JHGm+23VoksmWiY+KDXl9fbEegMdJ0m12y/HqN9PJ/L5XOXVleWvlLI55WONum6Z50Pb2lrg0WjGe13uT1hu8PRFgsKI6pbmxvXxDGouN0e1+j4xKeNRmPo+Ft8JZlM/uHM9Wv/AI3rJgv6taqfvNWgv1WOOuuUrIPZrq7QXRzHtXIq8/H93e+iRoJiXNiUGrrPg/j+dkeH7+/JvPxZYK5Fcn0/RObpn5FrtwTq0X4lO+wNX/ObAFwWcLPjpSbKapfeM5nN7omJMz9ls9vbKj2KjdyfX56duf4nomK9Mn+d7Ud9npHzU2hn22IFAC1nVAMgVTjT20m1UY32B0PhMTIWHTdwKvhcNvsqGYc/KxYLB3CsQfRDgf7RsVPv9fk7f16tOgs68o6OMl9aXlr4O7LvI5A7raT5y0b8pTGhP69WK2nhcGWtepTJRKE16H8rGEAn7W3Sbivgr2jKqASbr4jjgosBLn5SVC1v5HSpD0fe9VSycrT0VOzKw4liKpAt503ZalGfK8ZhbS9OI76oDo8Pr90OAQKozQSEI6g2iVR7Ye88BcITwS5YjScgkSdArVqF6VgU+jo6oMNmF5jjTG9rongdAtCJ3ghsxQ+pwCBPUOPM4aoJgXSn20mp/KcHeiBPgB6W08PotEtvq31s9D3pRDlt+Pr6i/ZCtUQDvggW33P+NAQ8rmNfAwiU9jgB20gH3yTHVSagltLceUG0zmG07N/nn7x81jOISrA4RtQb+6XN5+7cyO6G8LsXl1ZhpDsoOB9IS2SywNcoVAaP0w49vg4YiYTA67RBsVQh/RUi9oVSmdL0EdzjfkUfBQXW6AA4blz9s+N3BEcL9hH3iiUVsdyfAZ0M5L1soQhGgx56vF5wmMwUiAuCfseguz7kvALVULOATeo4VhlAdoHdaIacsQSZUhHWDg6gy+UEl9kqROCl7fLiq7qWggjdOdlOgAX78inbOI1z5JjiKYzm78Nh+qiuSUAZCDR3X7zDi7oOZjDk7gqMzd7jn9gWJyQ1iiwWi5WA/jPEWFITldG8jvb3d58GbeV+NdAvA/4i6G8H8BubPJRRf1Bc15LxqBaZZNcC2Yl5K6L+bYhmSfmzatGherQ/FO6e7Ontbxv0YzRkZmbqc8RISYC8fjEb7ZfOFR1Dk8msRjOtJZOHLMVZ0xB8A8YJQBv0q+Uas2WgzrVZuorf241pRfulv+n3CLAznp4898+JYc4qtdPPiMH59OLCHEabUiAH4dJr3J7smtHplCuceiPAP6t4SzkebLRfbR6pKYfT95BK3B3pOUOA1cNms2VAOZ/MFstdjrN3PDB19fK/JuCCFcqVtApYB8at4lBTGyMt4CoKiUXuhDarYKRSyRWyruHNqkKAQefwyNgn9Hp9vWwmMgsPEwe/Ozc7/TU4XpukdVMCIrci6GfHsFmOumpJUVTydzhdLZ1tWBZ2Z3vrMjBiy9DoSDJIY7C6svSct8P3uFgjXeggp3OTNfA8UttBHmHXFEV7k9b7dpxMStZWg0aL3eEIjJ+a/KTZbG6Zey82PpVM/uPszNTnyX0/B8dzrFXEH3Uo2lp3OE4nBcy02CjKceCfbl4CUiuNrf4g64+lKxi+5wbGv5Y8THxzbm7m72pkXoE8p591KClz+jVBP5Z+nTh99uMut/tjcHwfqI97uVy+vrmx9kex6M4KNKY3SsfNVoJhHUPSGqlkceF1sZ9OpxOK8X5T7q8n7Z3bbjvg3yTqrwT/uCDgRV7P9wfRAPAYHHsfibzru2QB8tQ48G7zyTNPbb3cmc7laBm2VD5PI60b8QPgV3mwWczgtdtoHj3Wt8dofAXBJsdTYDhAALAlY4AoBbUcrBDQiNvo94nMITFaXKNZ/DoKwMP+DvA6bHQ/CCXz1SIFkx6bjUbSMV8eKwWgcN3GbhyS/JHuO1svW3+s5+GU22gzke+bkFFf46vw3cvXIYx5+F4P3XaKHMdWPAHpbB50ep2YO88JYoB87ej+ztPP3ts5OcvxvE4E/WZxHOFu/6nVpcxWyISBLvKbaPwQugPkOMjO9g9TcH6wD84P9dNoNo7V4t4eLCfiVFCP5ptzYk66uBzqZXR8qbqAELWnJw4dEqSPVgT4RiOYjAYB7BuMtNIA/R5lvwtOE2QJLJPxXdqPQ7fXDV6LTUXQkGmi4B6N7pNjMOj1dGylFAKE/hIPAHP5fU47lFMV6sTB6D+mB9jQwSA6F1DDoVyt0O0Y9Qbt/TJHrfkdOhQcPWcXF9eoo0dgNYAo3CicX4GRwIOR0xUnO4a33h04P6XjoSyqEFJD1uVye0bHTt1pMptvKGeO3OB2YrHoDGhH++nNiWwXFcqVXm068CaTSV8qlZRGkZJ2qxa5VeYis3RkYK7pMtM/pTK5MuWHvTlL37lprYVx3YxGK4v2E7Ax2Nc/+LE2QT8BpcWF6amrf8DUMVZGhVg2Rb0+OwG4DfRGMveSBCivK8a1gc74Bg1Zu1EjGZAjIMza0eE/384OyLyNkTm+onJOWNDOk7GwnZo480vEML8bWJ8tzxcz6dSfzc5c/4KY8qKMWgIcG5qysm8Gg6KWqEYj509yJijHhN2+Ml2DnUfKyCydW+HuyNlQOPKEKB6muVihv2NoeOTHpq9f++8gZ9ZoRVdvelOIqzUDHA3RRpMJA/6eU+3sB/UWtrc2r+I4BMng9Q8MPUmAgo35PLe/t/tbS4vzT4O6AOqtDPrbBbGqwnQej7eXzJWW4qLZ7NE0uSdI0X4W+LPsmHoEtVKplI6OMi+Q7X+U3Y7T6ULhzmehcR4qQf+bFe1vF9yqgf468CfHFSH3508ZjMa2asFj6k88vvf/Lc7PfQOOI9uSeF0z4E/nW7VaaYvqT/YklZxUgv9W63y7aTZKZyQB/aFRq9UagvZaldyL/n55aeGbZEwwl1AC/VJajTQeyki/lv2BS7J58sy5nyfrvYo4JYq1Zj4/N3v9r4ltVIBGh4h07HqQOxpYRgqdi3iPUh5MuVyarlSoWGjTdaHF2J+027zddsCfacpIn5LuL0X967n+cLxgFAiQqjwXvdK9lTsYTpRTXpqXzoJUTqRvEzCIJfZ2iiWIpdI0/97vdtCdWQgwlVTYQ04hRQAjxQhEE7ksHBHQPtbVRcEjxwvK7xjJphoCBFheGB6E71yZqivkI/Hc63TUtQGQzv7o2Qn4xxdeA3RKrGZi5pf3rlvfH7on9Ter3+socVU99hhBN7IHEOxzrLCcXojw00Gq8tlRd+TVR0N3vWzTmfIiaJSMx3pUsMPkOqpUK7xJb+IQIBv0+jpIH4p01V+jIwB/MNjph910hh4rzZ8X8+Ux4l9lVPQF/M0REG2k1HwE+BTsk7+RUi+UyxMp76IgnlQu7zjYzpPfmqm+wvL+PuymMlTZ32O1idoKKnYpJ+TCb+7GYW5rBzK5PAyHg1TckdINxH5JB2YmfQq63BDPHkGpXIGDbJaCbmQD4OZRH4An6zseWyKTpIKLHQ5JpJWN9isxssYMxnlkMsFjF87AzNoWLFPxRDKf7P7DQUf3vlVvKpL9Vy0649GIOxInnSkCL78BkRtpmBind5EbTVsgg22pVPIHxErIQwt6PwFPSspy/cZPzp00+Frq4lr5x2p5yKii7na53H6bzd5BjEybDoUwSN8qWDItuvODdDq1I46ekpLcUOLpRsfjDWrt5KprgX6MDHUNDY9+ol3RJwIaF6enrvyeKNTHRoWk49czz7Ja5GRfQ8rtkXN9ScxNVxqCquD/9YCXFlEjpcHWEL0NdAVHTSZTW0Z0PL7/Cl+rsfNXCfxrxDD3jYyd+rdkvskouORnxO6MfmZ1ZekiaBuA0tg2RMyMRlNbKTeFfE5pqKtpEDQThpSBNLfbE+kfHPqI3e44DW1Guc0WywTI2TfSvpUA662O+mvRrtUoxvQ5HEF2iL6lGB02AkC306nkXm9f/0h3pPcDrLYGmQ/p6M7W/7m+tvoqyB2l0uOWA/2KcWvlMFGbT/X8dEwTgTYcQCmBMcRWNmCdkUxo4NgRmTxMXCfX4ZPs9k1m8ymQr6Vqjqg33CHVRAfhRoRZKfDv6PD1jYyNf0qvN7TFxMPoPpljf0Tm2EvQWGGHnVfA9EsG3Ml98mp3pGeOrD/jzfZVLpUXoLFij1pKn5rTvx0tFnYuIfvIGu6OPNDmaeAP4vtfX1qc/zZ5nQW5BhEL+tl7PrsWNKQSYgrk6TNnf9lisTboK5Bxj5Fx++za6vIlaO4MYdO72EoT0gOzxVCvy688oEw6/Qyoa36cRP1PWtvttgT+YtRfMj5k4J8srnpBIZnHoHwZWTvk/ZIovEPB/2Jq2/v16Is/SS57N+aIozo+llfjmVrsZaRbE1sRI/xeAuysBKw6rGbwe900f1yiorP12b0EgFq7jLAU3ye/56ka/dTODowQcOyyWEGP+Kh2XO4Pqws4LGbIFcvUgYD7M5kMYkRcAKXokPjghXPwt8++SB0Kz8ennE6jvfLpoQ/ufnnjeW+sELce4z2hrj0+E/AOhUqhFrJ1bA85I1ceCp6/puM59JZKtZlpKj0ce47p4k1we/FY1o6HoN9bLy+HeeVXVzcoLd3ndFJHAFYy6HZ7BJE/ETxTxgLpR6ZQgHQhT9kP2KuJYJCq5SsV7tEkPw7RHoNwDjhV+IyOlOHOTupkiaUzFIR7rHaa50+3wx2L7eE47qdSNG3hCMUQCYScWtuEK6vr8OCpURjuDgoMAImpIIL/gMMJh5i+QcD/YTYHeWOJOhhQDBDnDJ6LDqcD1ghQX93ZhYn+CAXw8poKjfaIlsWM8+N+0p9zQ31wcX4FRRS960cxT9jZmRtxRtYnXYMxMqgyQId5lgTwnyK4/wzHTsQ2G5krxej21vOgHrGiNyWD0cjTkoc6HVcsFFia27ExxKNzW2/gcT3i+boRKbJJTNIzNBoE9G80BohBOezz+c/Z7I5RAr58THkzWevw+f+n9bWVX4nubM8wfW1WFeCmtTZqGrfM6yfj7RofP/1TBoOhrTrjpVJxZeb61d8noP8Q1EW0pHnBRiiw1ZDmb7PZzyqnRTqT+gE0GiZaOYmvF/QDaIN+NRq7TByKAP82S/hVMjvbm9PMW0pKpo7MvdDg0Mivkjksqw5QqVRm1laWf2NvL7YFcmONNQClVBs1Aw5TKVoa+0gbz+Wyyoi/NB7Kc6gmDFmPpmFkmhzLe/2dgR9lo9TtNGKr+qAR9LMMnLc04s/0QQ2MaelBmDF/1+/rPNPm9nmytlwdHhk7R+bYA8zYYxg1vrGx9hs721sIaiXwoZYadUuB/jZArFrKiAzw4wMj/W6Pt2VuOpnP5UTiYAXk5ZXZ3HSOea7T99OpVAzZNUgFl7ZFrsmQ1Waz5XO5ArSO+L8hDqk2nZJKDQRlqhYF/cjcInPpk+Q42irhRuZYcm1t5bMEgOKapSytywJ0dg1SAn8UFa0sLsx9ZmT01K+T86bKdOFrtf3trY2vggrDD5pru2g5kFpG+8PdPZMEdAehjVYo5JfIMWD/pHx+aSzYnH4l1V4z0o+ljScmz/4bs9l8F8jXMr5cKl1cWpz/j4eHiV3QTnOU9sOysFhneh34ezxej16vkzmm0bGwubn+EjRfI07aSWvZbkvgzzRlbi9SnKQyG2oLNS4a+ZcT199F8KAbpd9cNht0iWAeAY6ZAG8s12c2G8FOQLlJpHMLFHUQQTBfL9kmEcaPI8YGmOgKEvAfpyJtCCgX9uMQIkA54vGgdVUHvpjDPRQKwvX1Tfq3GSPhBr0sDx33gNoC940Nw4tzi6SPevj2zquenx76YPETg4/FdvIHhm9EXw4dlfOUF+8y2I8mPYPzTqNlf9jVu20ADiNJOfKRFNVly8CwtDt6859JrDlsRguNgfcHO0UALpSl+9rFK3CQydJj3UtmYH47RiP4j911Buz1VGGhzB6Ol8tqpY9OZwU2EwmY3d2FEQLYzSqBaemOXaoIIth4zMIHXJ2uz551ZBf0dnghSkD9XuaIVh/odDmF88IL9yVMD0BHiNNuhfvGh2F2awd24od0Z/i9H8wuwG4yBQ+eHqs7N6R0BAT4PtRpwBz8Uok6cTDNAOeDjQB8ZBjoyI+GuoPwwswCfPmF1+BMfy9MDvSAUNSAUzWTq2IJQvkUFv7GeYGskXedGYfxvjB878o0t5dN2uO51MSV/YXgpwY/8G2r3oxzGHORTaPjE/cTS2xA2gC5UWJe5frA4PDpdhwB+Xx+KpNJ74MGvR8flXJZjT7PRl4MBCCpefzpsyiaw4KUuvgYirNFevre5fF67yOH0wVtAAsCZvzh7sg/J8b5rzJ9VuZ9KqfVm940qLRaxrUajZYYjZxt/NTpj5gtlrZyQDFNY3b6+u+R84hiR5JxqBQ5AjgGkLLx7RsYuI9V0sZG5uDR9tbmq6AelfihVYjbzOvXVIPGh9vjCdts9rZE2pKHh1OlUklTOC8U7saUin9DxoFNecC0lqdnZ67/djZ7lIJGQ41lUnDMeLNjQo+TGJkeaNEwb7VQLOaZt9gxAWZ7atHZ+jVF1oLQ0PDoz1qsVq2SVE2beK2qRVbh9WzvjWwqNH+1aL9qfn9nZ2DQZDb72twVHw5HTjmczkH2mIldsb2ytPQb+/u7y3AcfVU6TNWiprcC6Jea1vWmvNbUBOqsvX0DdxoMhpYAltwPDnPZbBLk5VclJqZUJYJlsOD39ORaSxMwmuX0+jrwJ3PS4XA4vQT4HzL9V1vnb9Z4KVO1tEC/vaPD109A/6dE5fyWrVqtxpeXFn4nvr+3BHKw2265Ona9rpC1b+PKpdd+cXB45FGX0/WY3mAYIuNpQ0FPco6uxWI7/08icRCDY6dCKz0faUxagX4W7LOOI1coHH6wzVNR3drc+CKWpYXG8sKsE4k9T2oiwtSRSUC//fSZc//OZDIp08NqZK5+cWb62n8h94kcqFfiYB3myjx+NZ2haqAreJZ8RYbP0unU5wv5fAbk64RmlY+TdtK02m0L/BVRf9aDzOb6K1X+Ke2fgLdDTgSG2UIBJvpPC6Xe9JxQ0o/uQWkn86KivPA7ADYifXydUhcBAXajBODGMhnYIcAUgR6+PiLAESPVnJiTjr8e7wnB1ZV1Sst32yw0x18SqxOwo9CHsZ4wzG9FqcI7vvnlrec6fmb4iR2XyV5JFtI6PQGk+N1kKePYyccdH/Y9iDmKR8zxs1REbGwUSVrkKitHO2HcAQLpyf4e4ZhIf6dW12GfAOx6IgEn5LtjmcFvXbwGT1w4DxaziX7ASWMiOjDMpG89BKRvHCRgfm8Phvz+OnVeUiSUVPeRIYAlUq1mI7jECLvAwqjVx1bC1EadAcJuD3nOQJyMS7FagYDTSdkZFPjXBJcM0hg6PW7o8npgJbYLlxbWoFirUOfBcmwPssUifOCus0zuv3DMOhCqAjjNFnrua2LaBKYkYBaFVOLwwYkxMgZX4draBsxubsPdI0MwEA4IugfAM0iA0wT97PzBt5FN8J6zE/CdS9cpeyJfK3c8t3916P3Bey46nS736NipxwhArNejPsqkd+dmp6+43B5/m9F//iAefw4ajVc1+hmABuiH45u+Wn4tRvsbaNoWi9XbPzD4PrfH+25iFDngBg03g8HYT35nFpXQlbl17OOtptI2o2YrDWvL4NDwgy6Xu63IJDn2w8X52d8lxjI6blijSEkDVfaNjjWK2BHD9IPK7RLD5BliZGdAnkKhFgW64dYiz7gduih9hEKRO9uZ42TNKG9vbV5WGQP6OtLTdyrS0/vLCucHn8tl/3Z66up/LpfLUv6r8roAZjuSU4VX2Q9ntrQGnOVKeY+A/6rit6yzRnpo0tn7BgbvCYXCP6vT6WVMEWS/YclGcrodrfoh0sWUFTMA3kBg9Qa0dh1G9UcgGGpLC0JsOgL6ZekvZB4sLczPfiaVPEQPPXutaYF+LfruW6XS3W70WrMM3eDQyP0EzLRVCrFcKsXE8pTs+qEWPZWNFc5VchkkFGXVOLvdHiCL3Co0On7eUHZXixJ1WuAWx8qufHi83t7h0fFPtg/6K/uL83O/RYA4HmcO5Kr1LJOLZXMBcz5loB+E+Wgsl0uF+dnpr5DX/0RuvCaj0aSvVMp5ss5LIFfL6a+2prFj06xKjZoDydI/MIQO/pb6ENgKhfzi3m5sDhpBf6tIvzLVEEG/Qx3086VkMvkns9NTXxTLgKtV4lDaQEq7QmnQIf2Rc7ndj8jPb3VtZWnha9DIDJKl3jHb5m9nRX/WAXc7j4NWu22BP9OUtFMtob+6yN+4vf/ZzexrDxp0BkOhXIGvvXQZHpoco8DwuHifBF95EaJzzC5EeNgALQRwWKpUqAJ7l8NJQKMZluNx0hkesqjSvx2Fka4AzW/HbVrJ5z2dPthKHNIoN8eUrgNm8wiy30X6+JUXXwMsz54sZ01P7VzyGPX6GgH9Oh0natqT/S5ltkcvHsxv3eUbuwbym4G0mEmbZm+8VfJj2C7s9+LOUak/4HYTo7RKj+fi8ppQgYCAWYvenHPpLYX9UsrDk3fzhSK8OLMAj915lirvM8MEktI+Rsr7/T7YPkzC0v4+9Hqx8oFNPHnHI+4nY4YR9q39AyiVq9DpEuxYQTgQgIHmNCUCwXuIgH9kaWwlk7B+kAA/Ac2YdoEsBdbJgm0oHAS3zQ7PTM1AvlSmn0RJny4vrsH54QEmDUGg//OiBwaPXc8DwzxgnD3krYfOjsFXX7xCS/A9Nz0Hry4sUy2BsM8LQZ9HECjkJd8Uz8winnlP2DY6KjLZPLwyvwxSScZqlQcDZywFQ93dff0DjzHCMfxh4mCZGKZT5OaiR9pyOxdNtVI5iO5sXwN1USqll1uNvs6Cfi3xPhk4QUo/ufk/RPr4EdL/Dnj9RhtWnDRB6/JON6XdIMVfNeLv7wwMdwVDj7WzPzKP8sSK+FwyebgN6urG0jmTnhuEsQaGRh4m60anYtO1/f1d1jhpGb28wTGS+nMjkX5ZKTGMoLs9nvF29plJZ5aPjjJptc/6+gfPhrsj/5LMIzYHv5JJp//L9akrfy0agpKhyeaSKg1uZSmn+jhbbTaHwdA6r7dYLG4rfi+NCQ9yANIA/Mn2sZLHT7lc7idAoU5NAGtqfXX5+UKhUJk8e/5D0OLaqNVqRyCfN7dEuwEV8QZhP6vV6nE6XYOvc9d8sVC4MjMz9dl8Lsc62NSij7cc6G9SXUTNgaQK+jFCPDI6/ihZny5Am3OiVCruQyP9mR0bHcjXlPraQu5hKSUfkIBFD7wJQF9lrAAa51kz0TrVvH6H0xUaHZv4JLk2WzvbgILCAw3QrzXPlGXldCBfp1nbt+4UJ3M5Sx5qJXLZZ/Z8KFszpk1TUUgChEM+f2db6VkgBCWeAjnoVx4/2ye1dYD2y2Q2Wycmz/5rAvrvkO2A53Px/b3fXlyYewbkKSla7C4l+0nL5uCJjXPBYDD2se8RG+0vyDp8BNqMgts24q9g2TT9/MQJILTbGvgrov7YJGSlFPqTFP5peb+zvqGZ3XLir68mlj9lJKA5XyrCdy9PwXgkDGcHe0W1dqjnrGOEv14qTozy8rykUH/cH/xGpVqlkX0EzOgEwHxxjHBvE1B6VC5RYDwdxZJ/XppHjlHmga5O2CHAH0F7lSkXSKEhJ+T5Y/PY7bQM4Nz2DgW1M0frLqfRVsV+YLlBt8MGGwQwG/R67pndKw8MObuXPSZHBuSLChsNlBknL+1O9ZHdWvG4J3t76DHg8V1d3hAF93jwGhx7PzPyxMvk+Llnd68MXUouncIvoeMiX0YqvHjb5lhQKzTM7+/p6ABzOg3riQTkikWIeL3iGBNgzenpseIYum1WWESGgysLoz0hcXwFDX7pNT0IMfCH+fcoGrh5eEjz/lFfAEX6bEajmKghnDscVr/bCR+4cJZWQzjKF2lc/+raBq1ScH5oQIjKc8el/iTXgdzkYO8BPNjNVrh7ZBBeXlgi55GDQrkM0xtbcG1tnfaxJ+CnlRcCXjd4yHmi2xRZBTgOWCoxnc1RPYHYYRLiBK8YdUYoVPI1n9kd7/EENv/Xhz+hJzfPJ6Qayhgh2Y1FX11dWVogr83k5mYhAEAJ5lQbAUSvVCrlLChuRP8/e+8BJstZnQmfzjlO93RPzvkmJZBASAQBYi0wOGCvI/aaXT9rs7DrXYz9r8P+6/Xa68deex1+24/T2sbGOALrJQghgQQocHV10+ScezrMTKfp3P85X1X1fFVd1V0j6SIh6RNFz+1Q9eXvvCe8B8E58aCpWfqVoL8hPOK8teKPWgF/qz8Q7B4eGf1Ru91xHl648IZVrEl1UVr6+Trf8tKCxV9NwFazhCCYtfuHhke/QyeDf213Z+ePYrH9BWgWDCULhVLQl7EOO50uckN9j/LGpVLpue2tTeJO4AVBLTBDRZdV4gygX81VlO8vihG9YOJcgVv1097eznNqHwwNj9wR7er5MXnu5nrp6PDwN2ZvXv8UgGpaNjVrv5pyrNE2n88fNRiMbcc0n8ttqNyDJ/XjhduGUOvxejvGJ6Y+jPPnAijmfCadnl1cmPtqsVgwIGgbAB1rolwpJ/ix5T56uQijrSzXvMt6Q9lI80VvOkxFqedyucdnb1z9nXK5TG7rSmIxNS8pVdD/UgirOlL3qYE1KW1fI7Z/ZHT8vrOAfiq4jxyCuiWTf1UlNKvWqhnl/UzN4QW3SgGgRympBP2ymH67w9ExOTXzfXo5Wmq1anplefFXEfSvgxz08y7+Sku3EvhLdeYVLRL3DU/QCVz/qxmEWu31rVz8tUJF2Dwi5dHQ8NgDlEJPT59UKpXkzvbmZdD2RpSK2hg13PtxDKznzl+UsrQ0CspKx3u7Oz+/vrZyGbQNH3w4hZa3Q1NIlM1ut4XC4fdzv6H18KSYAUSNB0Srv1/xRQXwt1vTEt571SsAXtXAnyu8sMJvbNLmJ6UDawCWt0fv+mKhWvEvHG++24zgn0A6gWYCYf2dYRiIhFisNttdJa91iWEeX04QxFPOegKJ+WKJpX+jPPXsFS8CdWSNthqL4C7bYKorCrvHaQZM6TebCJSP8ycwEg5DGMEg8ZYHENg3tBji81hj8LVYKbM0d6SY2E6mIFsoEkg2HhWzFGoODqsZxro6IY7PKJYrpERwfG73qXu/d/Btfw/qrnFN763mdkYNokV7rLeLERiSByq5r9PblWqt9rbeO58R06qY7omcX76cWhzFZ1noVxv7CRjrkUA65xkBpzZ3anvE42UW9Fgmw/pwJBRuAHh6vsduh0KhBIVSmZEJrh8k4I7RYYh2+Jjng/CAeuM5EpkfeUyMhEOQyOfgAPthJREHv90BEa9X8KaAU0nahc94EMH/Fy5fZykVaazmtvZgJ34Id0+PQcDjYnWmVIP8JFPfmQTPgJGeCAL+ElxZ2WDvhZ2BEnZgbisX923FE0a8oFapUT4ZcNosLGtBEb/PFCxGIQyA7oPzp9zl7NjqcYSW3hg9v+x3+GBicvpBxGsNF1QEvoXN9bUv7u5uk7WQDtxauDPaqYfZH59Rje3vk5t/k5sf3lcZH942nlYE/Xx6vgZTP4Gr4ZGx+8KdkR/Gg1/VAlIqFQ8T8fiC1+vtc3u8PdCmkDVWJGm/pVagMxQtK5Eea78dwdt7LPrSPJHl4FMb66tfB233Ry1g1FCSjI5PfBeOhVIwrScTBx8HOehvRUCk6+BtAfrbpRJrcjc2my1eBCG63LZP8vlYMhHfV7YR5+LrItGuHxA9RoQ36/ViKpn4lYX52c+Bej52LWs/P/7Kdhm9Xp8eHoL60WFqQ3EfydqvJJRq9Fe0q3t0YHDooyaTWebhQ4Sd+3t7D6NQO4ftYnPM4XDqYhMvFotboB63+nIoeuaPbP+hMQ4Eg+eex7Pqx8dH/zx38/qfE4s/yEG/Hku/NG4vtbtuKyWJ1nprgLa+/sE7OiPRJvbzdqVcLmVAmwRUKavJLjrXlPczclkVzloXPeWMafu04vqdRH44PX3+e61Wqy7lO67Vwsb62q8n4gdLIAf8yvR9aiF4si6CZqVKYx8CdeCv5pGhlbq1VZiIVnaRxlzqHxi6w+XSx8lCJX18/ASCfykVpHKt8W1WyyLEzjo838wz5y/+mN3ueBPXdppgqZ2drZ/d3Fi/Ds3Ek1qgX2tuKMMMAc/y9+Ge3Hc6xvX87s7W7+C8Lmo8S9Wb7pUMbFWUkvyrnvKqVwC86oE/Z/WnwhP98VZ/WnD8QmWbw7t77vkHj8mWRPD6A7hYrRkE/YVkGSwWM6QQlPZHwixVW53fAuoC2LSJ6ZmJ9M1sFmRAYnu3I6gj0j5Kg0dp6igHPBHgIWiGqMeDoNYKywhkSUmQxudd29mB0c4w8zaYGuhuPEuyMNfqQv75zEkBzC7hnnchCH7k2k0WTiA0usZCBgJeDyMBfPTqLAPWW/n4RKx42BGxBU5A7j4KoLAC5qsF524uNUjp6cZ6oyBlv7q2usks2GQE7nIEV3qd4W2xJ7AHTKVhd/fWRn5/mCzw6wdxGO/tarjHN5za66fx8Az84/06EfwT2N5DgD4X24eRjpDQpwbBit/VEWCvzywuw1EuB4/fnIPecBDGe7pY/HtNaoZEhCiicqpHh8PFAH8ik4XjwglTAAQdTqZYsRgFb1jqO7vFCm+9dA4evnyNhReQciNdKMDnLl+Fgc4QIzckIj+v0wFWrJvB0GpvErwJZob62Fhf39iC/WzC8q7eu9fe23d/7Jn4XCheOg5v5fa7cpWctVAxGaqUB89oqtpMpqrX6jmO2APb3c7Q9jn/8IYJDDRmlUgk2jcwNPJus9ncIAlDwSq5vLTwqcNUiojHbOKcr4dCYV2Ha6lUWk0m4xvQPrZPGeuodO2ztHi1IOLwjk9O/4jL5b4fVFKKkZB3ENt/CoHsYrVatUxMTgfcOiAKfjfL1e8lA/1ndF9Xtfb3Dwze6fF6p/U87+Qkf3V+7uY/QmuyJzXlQ2Od9/T2T7ndnjcr710ulZ5dX1u9DOpC0POySrRwn23nJqrqdtw3MHA7Cte6QGwstndT8RaB/tcj6P8e3gJM2V4Sifh/W1qYewTkXCi8FUjJ6sx7mWmNu8nl9vRBm1KtVI7S6XSKu690DwC5d1ZjTIeGR+5C4P8fDAY5MWO5XI6triz9TTIRPxT7jtURhW5daQ/Tx0eLoCGIwkukDGhD6tcqvt/SEQoPWq224BkfWcP++9vFhTmK+6V9ppXbdUsOjJdKKFUBslqhR5pW2mBHaLCnt+/toDMVJF8QtJ2ovK3mgdBUxBCbb2Y/8fVpN6/ULP1SSIR7cvrc++wOR9s1L7a0sruz83t7uzsEQNXc+3nQr3Y+83aI03jBUyWA5P6vVI7zxjHeSKb0xFCOlZrHSLu4fofH443iXnWv3jEhJSwCc3K/V6bHVAupUrP0s713aub8d6Hc8RDIQf/h9vbmx7Y2N6RUk/ylxeCv1m7Zs8TPDYNDwxc9Hs/7+L7OZjN/truzvazxrFedtV+x5pSvWrJcXes9ut+rEfy/6oE/lb7+QTZh8vkcFBG4UR76WrVK2uMaWTexSOCf14Kyxfrm6O1fCdr9+Uf2vvEjBqPRVUGAu7izz2LNCchTnnkHgncJwFJhjuP4awKODoOQiq1R2PYr2beFeSzRuzHLvNkKM11dsHRwAHnKdY9vzu/HmIcB3a+uMoWJJK6MQLwmstv3IADuQWC8d3gsPBIrQzHudLkjdpalIJHOkJXb9Njelbu/Z/Ct5L4qxf9Ki0tmCfzawY1Ji9VsrVRqMN3fw2pMOesXdvZYC6q1SvUN4RlKRZIT78E23Hs6z11dWd0eNJksxr3kERwi2PZRXnvRS0LwWKgx0kRSIBi54yrk8mCbzbCD7ViKHzBW/k58jwA/NZXc4t90cQq+9OwNRiK4EUtCKp2F7mAQhns6WcYA/gRsOGQYqFFGiPh8eE83nGA/k1U9WyqA22oXCQOFUA3K3HD/xWn47DNXQRpgUgrsJFKwHU+xVI4UikHWfCvjZZCCDOR7lDTepCC5NDrAYv3nt3cNX9h5+vxbu+9I3xe9SIdNBQWEaqZ64jwu5c1Re+DYbDCesC7CeQqcFp5c7kfHJt6IwuubOaBSP8nnFxH8fQpBII1nA/QjmCMPbl3M1Sjgf00is6H60PPwld1H4BNginVKREvAhFIqmfE9BtZEdz1Zij7820zWtbqQyo/eMyPAIrb0D5vN5n5o3tDJjXZhdWXx0Uw6TYIOCU9Gu93RlgGdrYdKJSndB176A1Nqmx7QLxOMUDAJd3X3vhN0KC+wzQkc9z8S05KquX9KddESUkwOh8Pd29f3r0ARC47dV97d3f79FgRHZ7ZKaAjVWu7GreJm2d84tzs7O6O36xmQUqmUie3vSVZ0tgUNj469DiVQFMpkoL8oxnl+CeSgX0shxo9zK6HQhHPZY7PZOtvVtVAsbODxVIVmpYgBVDw4Jian34Gg7Md5jwUQ9oUrOD8+iftCDTjQT68OZ/t9gSzbiThTBqrGXuvp91tczhrfb40wZu0zFcob/vcL87OkXKNzTgv0t4vRfalBP99fTd4i0CYe22qz+YdHxt6De731jI9nBc8KCbyrcTOovX8q9Kv0Gh6OZX6MXqT+0apfK9CvFdfvHJ+YejuC3Cmd1aAY9r/ZWF/9Gsit/Gqp+1ox7auRzkkAXi0Eju/DuuJ+avduFVrTytrPLpw/rpGx8QeJiFfv+KAM/1wmfUwp9fSCfuVlHBufvN/n8/8A327c69M7O9s/w4F+vZb+VuEEDfm5oyOEIk/PR/AnjTVTqZSvL87PfgKaz9RXpbVfZW/i/24H/HnlFv/+q7K8BvyxjAwP1rhJVdP4mhYJmOGCf/gbnfbAwWP7lx/aPUncjjjHnMplIb6ShsXdfRgIC/HZAZ9HcFlHIEvgkF0Gg0gCp3ycoTFNlbndEf/CVLQLNpJJiONz6Pfrh4dQQJBFMfD1muTGfqo0oL8oHEC61z3T4/B3X3mK1YHep7SEEvP8XRMj8H+eepbVbefkYLpUr3zJajBLbP7SK0/MZl7Px2aoDVEE22QZZ6EPsQQC5gqrX8ju2xp0dW3BqTDKBIhOm3+/1965tlc+HCFL/pPzy/COOy40rONCRwsu7AYxll96j4rb6oDRThsksR/Itf8YcbAPAb3E4O+zO+F1Y6Pw6PVZKFcrkMxWmPdD7OgIejqCMNgVZqkETx3/uXj8OjDeALcVgb5F7ElRO8CyN4hf6/C44Q2To/DVuaXGKNWFL0Eqm8MrC08vLkPQ64Go3w+dfi8j7KNwAQLJdGeBt0+oBQ3fHeNDkDhKQzyTsXxx55n7jorp2r3hi9cI4LuN9rTbbmcbf11g/JO53iGId49NTH6Hw+Gc4OZp7fAw9SU8SB4RQXgD9NPVGYkO6GQ6L+zt7lC6Nnbw1QWhqsIpHhqqGQSb7OAj0kBxvC215lh+SRHQOBRFMqgPstRBilKrVTP7e3ufRqFngXgJQBCgSHlFDOh6c9fvgbYLqfLvW1JaMEBrMR0rierso2MTD3EkjS3GrF7d2Fj7IzGlFR/Pz8f0AzTzCjSEE+KFmJia+WHc25pyKOfzJ/+8s721AK1Bv24li073fi2rYxNZFtbdNTI6fr9eARLB26Ko7BVA/8jYndFo97tBpvCol/B7/6MN6FfzpgDub01LUCDY0acHOGUzmSWV+/FKBvYZre3pmQvf6fP7f0jeDqgeHR5+en7uxufEtWnnx8pitVpsNltbJu1C4WS2XC6dwIucvvGFFA0Qq2bta+IWsVgsLo/XN3aGx9WPjw6/sLgwR0pyLQusmov/ywb0c+Us605GngnCvvQOq9Uaev4PN2gpaZQKyibSUYquaxqYWq0Ezfu7llXagPNG6Qmq7Jum37TpJ7XQo4ZSsn9g6HUdofDdevsnm818BefZZ0CYX2dRLrVagzwwUioNtYC/WjiGVly7Fh+LZO13KC/cd+91Ol29evuF6nwQ2/8SyK3jamSGmtb33r7+SZQ9PgQcNiJ3+9j+3i9ubqxdg7OBfrVQIv5ioN/lcrtHxsY/RqmGuWemtzY3f7lYLOZB29qvZ1y/5YuGlb/VxZd250/91Wj1fw34i0Xc6KV/Kl3+eeFcdaJF7YHN7x184M/3iqnHHt555t3x4tGE2Wg25gpFmN3ahRubO4xtndy+KS+8x2oDh83KwB/KVmAxGxkpIMWS220W9l2JFZ7i0k9d+IX/p/cHELg67VZGdEfKgFg2w1zOxzo7BQwpAlOTaNGvc2uCyPy6QwHYPzxm9ycyPGnfJyb8kMfDQKvJaLZ/Zf+5cw903fk0nG5mIPYHAwd7hWT4sJDutpgtMN4dFTwLsCzs7rE20L9HnD30+xM43YCl/Lvwzt7Xf/1/r3yuFz+wHRxlYH0/DkNdEWYFF3QY5LFQAWNd6CPhBnWRIN/A2hd2eaDqrAkKAsPp+qfv9nR2wP0XphohDBRKkUxn4TiXx2cdQG9nCIa7I4wbACTPDH77qJ/2O3kdSPtHwx8L/znUE2FeEvPbe42Ue9SvjHugTnwNJva8dDYPC9u7jMfBhuNOGQQc+FwHjjspBoJeF3hdLuYtQV4ccRxTlNmNX4vduG/aNzQftHqTwGdSUFjX+voHp7p7et+PIKcBgimXLYL1v0SwfB1OD1yz+Js63t6IQGNQzzo5OSnMouBBJF6tXPyN3Ktk6bdiPZQCETsAxc9MKCwSw/gH3G7Pu7h7NEbh5OTkueWl+b/LpNM0j+ziPdiznS6nE0GpLmCXz+d5y6TSWvHNPADO6sLeEK57+wZuQ3lBFzA5PEz93/29XUptpCSb0xJULIpX0/jE1DtRCHuD8t4IkPeXF+f/CNoTlunq4xcY06+aD3twaPguj8c7oKevyNq4u7O1ItaxNjQ8eina1f0uUIDlVDL52yh8Pwzq7v1aDNJKi6Um8PcHAqM6qltLJOIr0Aw8ZMosQv0z5y9+j9fr+z6uDrRXnqCg/Psry4uXxb7kuQHYOAUCwZAeUq3j46OnQD3tmqoC4JsoaLWyyKqx07Mr2tUzje3Wa2ms53LZy3OzN/4a+1TN0q9mgX3ZgX6N7Aft3NZlVlrqN78/cPGF1MNssThAPR6al8v4+OiGAgDP2yZlGa5pyctQKmpAQfYqyoLK32j9XouwTi1uXbY3hULhETyv3wHNgEW1UJjd/OyNP9GYZ2reRmd1B+cBMqi8ailQ1O6rdbZJwFczS01nJDoW7oy8Xk+fcH2zhefcHKjLJmpKPxno9+Ne19Pb/zG5waFeSSUTv7q6svQUtLa8q4VuKfcXHvSzZ9psNvvU9Ln/ZDZbxrmm1I6ODn9rb3d7BQDaedG9HPlUbkVp5QHIv/LfVfaNkkNFKq868P8a8G8u/AJqgH+T2Vwht+V2pcsW3Pqh4Xf+xUYuNvxM/Obrt/OJ0XK94rBarCzunVjXj3L5xvclxv1TQC/OSQSPNosZLwt0+DwsvZzH4UCQGiTXaQGf4hVyuhkbPbm6E8DOlUtwY28PpiIRZq2mGxPYdVttYBaZ9Q3MpbwGd0+Owqe+/iz72+mwNupAgPW2kQH44nM3GIhey+0RIdZVaAb+bFN7JjF3zmqxGAjMjvREWb3Iur4Ri7O6Gur1o3u7Lt7AD4pc35rFv40+iyt1V3DimacSs280mYyGy8ur0OEnPgMH6x8WNoDAmZjucRDEWH5itD/Na09tou9IHAqyAcUKUcrDt5yfhi9dv8m4AaiXy9Uai8mf39qB5d195pI/3tcNTpuVfacui4Tj/S5U5AG84esmRhkp4GE2x8bxzvDk5nEhU4/lDwPJ4pEbx8NIxHz0mRnHltz6Y8cZgHRGqPfOLlknRMWJ4NlBmRpoxCxmq3nheCtwT3iGOBKUwL9qtdosE5NT7/Z4fbJ4+HK5TKT9f5hMJg7g1AVYsp6wjiLhXo9Vj75/mEp+FdQPIamn+GQGDUFIw9LfOAR9/kDH2PjkTyH4P6foYAZQkon4J5aXFp4QlQc2kGvZa16PL6DHYwGY50NyFV7CWGQd+eiVVjWZcGTFsUJh8e2gQ1gsFovri/Oz/wfUXR+VB6dSMGP16R8YuhjsCP3L5ufVKwgcfy2bzfCeBO0EFFbUDlkdoL+Ve78qSzYCkSm87gKd5egwtYl9xsJnBoeGZ7q6e94OctBfOz46+pP5uZtSn7Zy8T+rtZ/1O85ji9vtHmpX13KplEinj1PcGErKVD7Gvz5z7sL7laAf11Fya3P9f+xsMyWHBTTWA+4NbS1uuJ/l93ZZBoQXzOvwYpUWKfy08qor4vtDukn9SqXixtzNG38spjPkSda03K6/VUC/lmeEasYMPIO8ff3974Q2cf3YT8xDTMsDx+FwhEF9jQA0A3+ZAsBoMjZ5ieF6PuL+2Q7Aq6UzBZX3WoF+JahVWvrZ3uR0ujqHR8fep5etnubXytLCbyPApRhNfo4pw7dagn5+nimyWkmFN320cp/WKq0UbVqgv3E5Xa7w4NDIQ1L2IZ2FZJPHxHAzLbmEP+dkafssFit5qvxHnJMR/p7pdPoPF+Znib+llau9UrGgdpY2gX58qG3m/MUP43l+J9+QwsnJP87P3pDS4mplDOB5FVqeq9/KRSPVsXI/VwP/AHLAL61rPh0oKL77qimvAX+utEjvx/Cz+F4rF5PGRBxwRTbwSuHm5d3JxXv3T5KRZPG446B4HNzNxb240RildGx8ob1O2kUImJYrRcbAvyFass3zJrg43A8D0TBTCtB7BPzPd3Uz8J8jcFyrspR/o52d4LYIILnGEcuJuBJcCKzPD/Ux0GsUme0leNvTGQKf08nS2mVKJ5H13N7goKtrE05d/QVnAoPBup7Zm6wjSu0NdQhu+fjf7MYOmM0mBrq7HB03EfyfiL/lNcTUeLap3dN5bnb3JNm9XUwMU1aBJ67Nw4N3XWqw9VNKROJMIKv5cSXP4vfBYGxY/xuj1ATST9vcF+mAS7kBxvRPoJrtCgi+q/htItSb29qF5b0YRPw+sGLd6bU/2smeW2+kSQTNo5A+evPFGfinr13Gf+AYJJc7PjD60BfsRksGH1jfyh24lo+3wrsnid6jci6crxY8VpPVIOd+MOIpaeA6qU6xXsWoLXh9wtdPJC90yPPAvxrt6u7vHxj8YbPZwgvptVw2+8j83I2/RMFHyscLoAD9VCKR6Kh2q7gbVqvpvb2dq6AdvyytAQD1w08J+kWG8Z7xvv6BjyoOXVYq5fLq+vrq7yLA3BF/A3DqrdA4eD1ery4m5Eqlsp8RyNBe6hy4rYRsqc9UhaORkbG36cnvTmEY66vLf1kTXF15YUFNUGl48HCXCefWSE9v74dUUprVs5nsx9dWl8mTp1VKI11WCRUStnbs60pCKN59lgnXkWjXFIL3t+kVIClsRiRSquF6Gu/q7n0LyEE/kS394+zNa38DcgubWvvVhEK+bWptYn/7/YFuPB/aKuKwLkt1IXWmmsWf9TMKlu/1+vzfDxwYq1YqayvLi/81kYgn4BQ0qYIEXFdtCT9PTgo3UFhNQ3tw+1JYpfQAWdnlcrk79LoY12rV3OLC3O8j+JdS9n1LxfRTaUNSp1xzqnH9dCGIfSvO27ZkiNtbm08VCifHY+OTD6opa7H/x1Ser3RB51NTNhQAJqOpKdvIyUn+mGuf9Krk2VAqrvnSysVYS5Ekua83hR7RRR55E5PT76VMIzqHqba/t/Mnh4cpksHU5pkuS79ynkn/1lAAAMjPduV7ytJK0abmXdN0vuG55p6YmH4fversF6FzatUMzStQV27zdVLbc01TM+d+wGq1yjg9cE/759kb1z4JcsCvJfecFfRbz1+49CG73XE/37co612Znb3+vxR8OVrn6is6tl8D9KulGeb/LY0HgBz0V7n3pT2krnzeK60PtcprwF+98IPPNEMIGHjQ2s6a0Fj0RGLW7QzF8CJLAAlarhrUvFeTy6GV7F5w++TA2Tj7RDBqkKzWUnw/xd6LqdHrxjo8vbQC8XQaLoz0g9vmYDH6BJAnO6OweZiCeC4HFDk+t78HvX4/dHt90IicE13npdeLQ/3gsdsYwR9zkxfBM8Wej3RF4MrqBp2mhmfi85cQ+JPVWJbre/54s69cr/pNQOkAu5iFnjISkBWddV61Vp/yD92E5pjiJlf1h3rf8I2/WP1sIFcvBQ7zeXj85jzcf36SucobmAeEFQqlI/jy1TnoCQXhjecnmPW/EZfPDY7WoF4aHWTEe8lsTnDlwCd3On2V3VzcbDFZGKneViLFvr+8f8Di9ruCPhiOdkJfJARWk0UgG9R4kstmg7vHh+Gr80t4Itdcn958/ML7B9/6OfxRqc8R3sdrQWr3Sna363pqdfKgeDiaLZ905MonVhoGu8la9Fhchy6T/SBg82ze03nuStDiOQa5treKh6NhfGL6QZ/f/5A8vVgtk4jH/5As5KLCQpqT0qHUmMcWPIA8Xl9b6yKVXD53pVQsklVLCW6kzuA3Xi0BW3YAjo5N3BvujHxIJZ6/ns/nPj83e+NPi5Sb8TSfsARSZIevy+2Jgo6Ch/k8B4S1SMhumUCuQ8hWs2g3BG1/INiLly6SulQq+cVkMrEN2hYQJWGezL2/szPSPzg08h9xb2iyouE8+PrNG1f/DNTBrybAUfapSvyeGt9Bq9SGSvZ+Bv57+/ov9fYNUO5n3WdcJpM+wOuop7d/EK/7lAqDk5OTJ25ev/rHdcFzidqrJnRrCYbSq9J9uUlI7AiHx0EHGzqO7YJiHsnOpemZ89/u8/l/kL9XuVy+vjA/+1/Tx0dp7n1eGdgYG/LCsVrbewIdHx1+HZotYloeNbe8tLFea4EQaV5Zo13d5/X0P5Wjw8NH0sfHu3A2MPatAvp1s69TBoRAIHhHu+flc7md3Z2tm7gHl7u7e1bdHm9TSIvdYR/DMymQSR8XQQ78JUudVM8mQGU0mWQZKIjM9IRYm7XBO89iD9A8T1v9TiuuX2nplwC/W/p7bHzyAYfTqZPBn+1Nj62vrZK3nXKe8QomTWVruzmm0wtAWbS8J7RAvxLwK5TaBsf4xNS/OEu/NPonnX66WCxkQL7GpHrxskOTtX94ZOxut1vGps/2yZs3r/22QmmuXL8AckOHFmGojC+HQhrPqYD+Wq26tbK0+HMoo2Sh+Uw5szL9W7m0Af0maD5HeXkGuH6RcAZw70uvauErr4ryGvDnys/+518w4gZYU7H6g81uNxDjP4jGeNDe5NQsCQ3hGIVJ+3YmYc5XC0aTwVAzm8xibnmB4I25tuOT3Q47gtsAs7rTZbOZGRFfuVyFxHEa0icnUCxUwGsX5q6E5/uDQfK5g00W92+EnaNjyBSKMBoWvOckN3hJCUCM/wORMIs5B6l14kvY5wXK+EfVQ3BKFhDaoHn3VeNzqaUZI7Hc432GoiEWk08x+qVqFQSmHWP2fGBoA+qqC05mCbOZLOX39t//7CfWHr6vZgDLVjwFT82vMCLCmthH0WCAHPpg//AI/vbLT8Lrx0dhsr9HdI8/vbWqYZ7ai0j/bbedh7974imRDwBg2N+bf0f0dbEn49d9q5m9IEUNCPoPoZMo+8FeEnH3zSVGzNcf7oD+aJgpTKr1Uy8J4RF1GO6JwNpBnPEn7Jwkhr9ycH30vs7zfIwY27xH3N1pvBaE8SCYYTCTa0MdTwCRtI/XWDYs/MSgj2C5a2Bg6AMWq5W31tfxwJrbWFv9jYOD/R1pjEDO8i1TXoU7owNms7ktQRz9LpmIU1YGicmf3YuK0WhsrAMxjWNTfBspJiqVitVM2goDuTbWjZQyx+cjF2S5NZnIdBC0/sHi/OzDouKCF/iaQAoeoHabzaaL0f/4+OhZUHdJVgWpt6goDzT+AGvpCjk4OPx2PRbscrl0sLK08Ag0W/mVB2RTGjm6iOwRBSIiHGrqVxzHxbnZG/+tWq1K+aJbufkrORQapQ35mpZVvBWjOBO0B4dH7unq6nmLztCPRslm0snu7t7e/oHBu5V9XC6V5uZuXvtNbHMe5AK3mlVXKXjybdSypjbiQL1e/zi0KZVK+RjX4y53Txn4n5o+9y/8gaCMyK9UImXNtf+GQOgE5AKxat7tcLhzBNq7bedEN39dKergFlumdAJZHoTwQIT9G/tNF7s6btHFrc2NR6E1GFNbDy9X0N/Ogq0kYWOp+0wmk2tgcOhBFa8gRX/VKxvrq4/hnGEAbXtr8/GJqZkh5VrDZWvDNfj2m9ev/hWcencBKIwOIN8bUJQy27Ausv0Kn3V0gkWlncp106imotqGFr/TynbAW/ubQH9Pbz+FTt2md5xwre/iWfiXII/p58NIWrmgn3m9aX1fhexQKWZpWdfVDABNZ9vwyOgbeaU2hYPoOetoXuEe9BVQD69SAnMZf00w2BHBs+4ngNsnKQxqbWXpl1Hez4M24FfzTlNrrwz0OxxO1/S58z9ls9lfx/cdynwpXA8fSyYT+6CeKlCLyb/lmH0rlhagXwn4Zd4+IDc88aBfzf3fCHK5SPrsVVFeA/5c+cVf/MX6L//Sf1Fz+a/jJsAfPjz45xc9LXLakGljEwQAI9RupNZCa5nd0VQ505MqpYMEdEwmKYZcIO8LulwsvpzcywNuJyODI5d9Naty2OdhANbCXOmlGtaFlPT4f2EXxf1bYDEeZx+liwW4vrsLk5EII8dj363zdnIxs4Bwo4YFPeh1M56AGjY5Vyk4q8Z6wFQzZKV+KUPVtpk/GKI0dd0BP3s+hQws7e43iAm7HR2zhrqBzwerpbVj74dsvpO3dN258IXdp6Zxzzcu7exDvliE+y9Ms3tSm2f6emBuZ5cpNp5cWIaNeALuuzDFQh+kDpFa1nwy0T3M8HYE/5995jmmTHlq/4YXIlB+T9+9S1WoLT8Vuxmcz2xG4icpv9VqF1IuiNkX4ukMu55cWAK/2wX94RBLjej3uBhZo9kgpPq7Z3oM/vGr36CgQ8Pl1Nxbxn2916K2ALmDqlkEqa8M9Upd7WCVuSsRbh6bmHqn3x94L9aHi5GsV7LZ7Cfn527+ZalYLDSaeyrcqx2IxlA4PKlnbVAKvIPY/oJUf47F34AHpdoBqyS1sVJaP2LvN5uNtplzFz/odLmaUtEhsNrd2d78JTwEl7j6Su7LkpWHB1b1YEdHt544SQIpsf3dWdB221OC01t1ELQCuZrCUbSrexL7TI93Rh3779MI0CU2a6Vrv1nxnixetrund6x/YOinsU+b3FBxfDaXFuc/lstlyS1G6e6uZtlsypLSIiWWUaU+au79yiwHUi5s1+j45NsQsN4LOkJXlKWru3dKzCYiA7vY5oOlpYVfKxQKx9Aa8CvDKaT2Sa+t3M3Z3x6vr9Nms7UNW8mk08tVIW8m33+sIJh6IBDs+ABwwixuCY/euH71V/Eck0AQv16VFk52+fz+tuSRhZOTq3jLtNgHasqPb5rF/wzWazVAyy4EHt16+p8K7rdP4zqgQ1bNyq8V9tHY919moF+PlVbVzX9gcPhuu93R0+6ZR0eHVw8PU+sgrpNUKonT+PgbPp+/icTN6/XdH4l2PRXb31uE071fC/izy+V0Ec+LTIldrVYStZqQXlbjktaImpu/Wh+180aS+kgV9Hu83u7evv63g06PEjpntzY3/kjkKSiAPKZfS+F4SxTYGp5afP9oeTRpufc31l1Pb98FHO8HpT7PZNK7W5vrS9MzF+5vVy/cgxZxLu1CMzCX5Ep1RZHJZB0eGfsJ4jbmepx4a349kYjvKfpTzbUfQC7/yzJdgQL0kwfV+MTUxywWyyTwoL9ez+zt7X4Mz+xF0N5DNEOnXoGgXypac0qW+pZ7lSnwbHa7cWJi+s14TCZv3rj6OKgDfq0Ql1d0eQ34axQF+FcKr9KEoQUpTUparNJiL+IBVPr42sPfvp2P32UCo4Ms+2QVJ0BPv6yUBVb3vs4OGIl0QjjgZez09DS2smsNegFZYbMVv0es77U6lxPeUG9MZXpx2+xwWw8C5FhMyEOPMiKB/5FQmBEFCqSCp3OeBF4hm5wImA3E1mNBMGuBUr7CQDz+h4eqoRHy8Gx8YcBiEnztKU0d3ZKUFduJFLOkV6qV6r2Ri89wfcRvlppMpzO+wUOsz9rDu88MUWN3U0fwd48/BZeGBli7t5NCGnaqExmbY0dp+MSjX4OJvm64a2xYID887S3V8Q37vXDH6BBcXlljCoTF9FbHZGgwHajYV+/pPLeO1/JRJWe9mljsWsvtdyULxwGT2WySeowyGOQKJZjf2oWbGztCDj4DZUuwgd1mhRL2ucFQZ94SRoPJej25MhTtvnMN1Nm++Tmlpp1kGz4ejGSN/IDFYh3jv4eAdgcFpF9bX1u5IgJyXjgC0AD9TqfLi5cut7psLnsFgSTjFyCPg3pd5mKhFIiaXN3EdH1mh9PpmZ45/x9sNvtdysEpl0rPLi3N//LR4WES5G7pUl818RPQ54GAvowECFBuInjLgDZAvaXucy3i2FvlNmavJNB29/S9GXQA2mw2M7e3u7MMzYKKch3ywJ/VZWh49HXRru6fVArQVPAA3VheWviPh6kkCUVqoF8N6LTqz1buoVqhIrJ+ARH8U87nyalz7/EHAnfq6SO1ouYhQK7CKID+xtFhahdOrblKwjY1S7+aZ5Mao7SsfeHOzgk9Vq5EPM67+TfK2MTUWzo65KAf5/znr1+98mvlcqnAjYO0Zpss/XQhAI5YrbaOdvVInZJ9vqSpplqkx2yXRoy/rJ2RiF5Sv9r+3i551PBWfrWUfarg4WUK+s+Sg55Z+z1eXzf22Zvadlatmt9YW6VUazmub+orSwufOn/x9n4EQ13898lDbGBw+IP5XO5XEAQmQa6wVAPeJrfH09XsqVPeBnWwLwt5A7mcp4wNVwP+WqEQSs4Rt3SZzWbf2PjkQ2fJS59OH38B93LKHa/FH/FN9yhp4SnSisxPUtw2rb1wZ2S4r3/w/dLY4Tmdmp+98QyO/4yO6tTj8YPHQR30S+OqyuSPIPzbrDbbJf5e2Wz2H1ZXlp6G1oCfD6vSyhIi48rp6u4Z6R8YIh6jblnl6/XsQWz//0HZ7TlQzwzTjjPlFVN07OFq2Rh4BUADyKOcaT1/4bZfwzX3FrHPBkCb2O9VV14D/i0Kn8vV5/OTm7DS6k+TSLJ0mOE0x2exbKpbtrPxe20WK0PztWoNjAgbyX0/GvBDNOiHDo8HqrXqadi9gOobuxXvf8Kc9OvcDiS6ojeQtNHIPAcyxQLkyyVGCEiv5BnQuB/+aDkRhyg+txfrwCsOTNiUukGy94smYvxth9cNmXwBrGarYf141zfq6W0Qp2zmY31k4afv9YQFpSmlx6Mf0739Ftdet7ODNNUWOAVw0mapJAviXS/N496+QqlWTnzl4GonyxJQqcJTi8sC74GRb7nYAmz/8k4MFrd3YaQ7AtP9vRDye6BSYQoLXsXR6MtzQ/2MhX83eQip3BFsFA76Ip6xvdIJs5hX/WZX9v7obfP3A8xVDDXLlfhi504+Hj4oHEbSlZyXiPnYqcJgk4AZ8gj46YK6GE4hjGA96g7GQTvNl1rogzT0dRTA6ZB6r8frlcXy0z3wkPzs8uLC76KAcIRzoM4Bf96rQplSjF2RaNe4zhjoWiJ+IKXr4sMQ+MOP3ZsYyfFzVc231+cPTkxO/4xS4w0CAdNnbl6/SozFBZADKElDy2tqG31lMpktLre7LQEZFVy/3wB9BHS3smhZR9RiaRvro7un95zdbm/LY0Buj+urK19UtIN/ltSnwP1NGR3NU9Pn3+fz+9/Pfa9RKpXK/NLC3McOD1MxUAc6Z0khpXXAawFjNaB2SghlsXimp89/Hwr+51/ksarF47E/3d3ZJo4SpVW3FZmW2pi3szwzJajfH2jrgYMA/jiVSsSU74+OTbwxHA5/gA+dEUH//8DfnIBcmQbQLNQ29obOzshEu1CJWrV6tLe7LeW2bueSesusUzpc1ltxREiXjcLw8JxvG2ZBhbJlxA9ipFxrxfOgOi9eZqBfSymlBWYbF/GyDI+MvtNobA9kU6nUV/P5XAxOlYSsT3B+5hBo/SFldME9SEbohkJ7ZHJ65iPzszd/k7g3oIWXEl0ul3sAFIowPFe2QG4VNIP8/FUNH1PpHy2vCLVsB0prP7P4Yxvfarc7OvWOFe65saWFeSKX4137tfbcbzZ3RCvQr6Voa/aw8Qd6hkfGfhTHnimaq9XKycL87BN0tHeEQm3P9XK5nMQ9aI4btyaCU1CxEoc7IwP+QPB7gZsveK/l+dkbH+dur3aGKs+uVqCfyV+4L78Jn/cT5JHG150s/bHY3s+uLrNUga2IYjVB/yvF2q9jD1fuTcq+bpD7WaxW07nzl/67CPoN2M/H3OdasvarqrwG/LliNRuaFpEI/iXQz2uGpfgRHvxLwL9kAUPGbrIk8Mtso780MgDnR/pBSqVHIFxw5eeKgZ+Vp/KZBPLJSk/gnuLyK/haxt8XqxVmXc4Wi1CoVolmn4Faj80K3T4f+OwO8rGG/Uwato+OmCt+LJtlqfFGw51czP8plK6L75JRl/gFqJCnwmEhHQQPMFf/mqFu3M7Fusjgb7WYoMPrYQSEa7ED4T54vwF3F7lrW+H0cOUBqQT8mbtgvHTcOXe03reLwDpTzruPinmL2WikFPanfSO620u1ZB1TF+p5KTxWi2dTsF9IGddiCVjZjYHTZmMkgOSN4HML7cidFKDI0gIKfcmUAngfSt/36PJT5qGLkS4f2FLcOLNXc91YuCs0uXEXTK7Te/layXHzcLlzv3AUjBeOAseFbEetXjHVDAazmaVbNAgVw4oP+XtuXPCNXBVBudIyCCDfjOC0gVDv6x+c6uru+QBuYr385ziH4qlk4jeWFue/TGCP7luTiBCEwqf0kkrjgKZ4zEBQXywrHojx+MHBGjQLsUpXSWlc+Vg6dnV0hLpGxiZ+DtuhPMwr6fTxH8/euPbXKqR7vFJBVfMeDAa78J5N5HPKUq/XCrH9PT4jQTuX5BcVpCis/e0ESFnKLLK+R7t63qjnOQjMr4gp3tSsFEoCK/ZZKBSODg6P/Bur1XYemg/DOoKcx1Eg+uVcLkvCt5LY7qw5o/Vq9ZWWIlWwZnc4AlPT5z7ocDgbbukIEvbKpVI12BHSxcyuVbKZzJdWlhYfhvZCt94YULU40IbC0+vzR202e6RdvY6PjlZEN//GGA2NjN6FwuUP86C/WCg8cv3alV8VQb8EtoDrd1WPENobEAC33Rty+dw3cG/Iw0tondJhvW5FUCe7AsGOPj3ZFKgtR4epx0Ddvf8FkazdynIG4VoPlwa5+L8ewXbb0COcqpnN9TXqr5zYZzLW9WQivux0On+vt2/gw/LwNayIxTowNXP+Y+ury39wcBDb1qgzA1gOp3NAOU4ot22CHPRbQK4A40MIlDG/rVz89Vr7mQJgaHj0bpxfeizYjbojoP2LUqlIYTRamSJ0s/e/WKVNmkwlz5UaeWbDu8bt8YTHJ6Z+3GQysTVH8tHayvLjuWz2hKz9JpPZ2q4+uA6fwvlVgWYgzo+hTPFDLv4Dg0M/xnu1iZ5dv1PCwt2eb6NyXihd/Jss0Far1T45fe773W7Pe0ChTK/Xasm9vZ2fWV9blSz9Z7X2v5JBv9YerkWaKH3HgGNruHjx9p+zWCxvlcarVCz+Kcjlmlct4JfKa8CfK6VK3aAF/ldW1w24MfCbKw/86VUC/2wR1yv19JuiF3/r0diz/9loMDlmt3YgEvRBJCDIFXWZRVh01Zfc7OFUKiPSvaNCHrInlFavxMA+/Y7c05kJvSYQ1DksVog6HOBGoO+z2xvPIGBL1vdOlwd8NgcsJxJQwn0yXSzCzf09mIh0shADKa6/wcEnvlBOe3qQEe9xXMrRgUY3rz2bWAgbjCYzfY08GASFRI0x4hPwLZULtTs7pkjbTpu8pFEHON0srTWouZ5OzE/OHq+NHRazfotJ6HzmSm8xCzwBpOTAPmAY2mgAq9HMvCSMJiOp8tgNXWZb/S2hi6W469D4yfXHLOV61UCEg8VKBVb2DmAZr7oY2sB2FaNB8syXSb/Up5+4+fneD469Z9lYbyIF4UvdabTm7uqYXubGvoL1rSTLGdf68S6Cf3M54PDmA26f1VWzrdarNTVLguye3Culp/OOjI5/r9Ppug8UKcWKxcLDq8tLv4kgLwGtc4Y3YhbJjY54+MR7mVCwj+i1PuSymcu1WrUEHKEfqJPEqbpgRaJdg4NDIz+nTNeHtzlJJhO/urQw9yWV/Luq7QDF4YDgbgR0bOSFQnE+n8sdQmuLHD8GL1rR6YasyXrc1d0zbbPZ2o4VKU7W11aeVKk/32cgttfgRKl9eGTsIY/H+26ydjbfsV7OZDJ/Nnvj2l+gcMXnij6LZUKtHq0saK3yq/NWIyuukcjE5MxPooDVCFfJpNNbszevXRsbn9RNnqVWUP5bmZ+7+ed1IQ2pFmmbllCmNt5Kq2NT+zo7I9M6CAlrsdj+Ij9Ig0PDl6LR7h/gydUQMDxx4/rV/14ulfKKsdGy9jeErI5QuM9itQba1KOeEFxsdQmpt6LoFBjbkoqJly0c7tRL6lfY3t5Us9K1DCF6mYL+Vsz0WtZ+yi7SH+3qvk/Ps4+ODr9SKJzQWSWRgUr9JNXHuLW58Q2z2fI7eM8PKbzamOV/ZGzio75A8NMrSwtPiJwystheOt/sdrsM+OP38ggM44q28eeLEZoV8Vrrlw+J4vdt5bySZRch9348x+/HNXURzgA48Kx6BvvkMjSHkrSN63+JQL+Wp5bq5XQ6A5NT537SbLE0zrXY/t4zBwexGJFFkvt/u/rg+BZ3treugPw8lbxLlcaJRmYjnEvvsFptE9ytSEH0j/t7u5uK8VYaNoC7pxrJXGM+hsKdPUPDox9GADqlHHc8S7e2tzZ+BuvOx/S3I4p9Rabua8M10orgt8mzgs7Oi5fu+IjVZnuX1Odk7V9bXf64/hq9OsprwP/shQf+BtzYa5VKhQf+1Ke0QVtuC4xdR9D961+OXfkP+IHzsWuzMBKJQH8kxGLnieCPALtw07qoCDDInkQx7SGXm8XlE7AmEF8ma39VUAC4rTawmQUFp+S6X1dsCfRvlmbPaITpaATWk0k4LJwwYDy7tw8TnRG8h+k05ICrhSx9vSBYMuC/kdmLChb3OkT9PvbslZ0YWIxCqE3EEdoPWF0V6fsgt+Ca1/J7A4/sfuP12UrJQ28yDgQQ0gg67VaIBPwQ8mC73S7wup2Mb4AUCgTOyVPi2aU1mNvcZTXzW1z1k0rRuJbZM0ZdQdjKJ2R1Z5zzBmE/F7gKoJHVQNZVpOCo1UuGOpnrDfyGrxbvJbWnAeIJEAfN7sNgx/jpJl6m11oZTj0eDKAuGLO/8dAzoaDwJgS032M0GmXWJzzoDlKpxP9cWph/jAPKjQOiUq0asY9q0Mxw2rSJdkai09x3WpVaPH7wLDSHJ6hZ+01SLD80Ytt6RwcGh/4ztkUWL0wb8v7+7i+srSw/A83ggfdaMIB8n5JZJhH8jehoA6Sb3fy/KYRIinqrARQt0N8AJAjq7tbzgGQycUVMBaRmZW3MUxJKurp73uJ2u9+GZ6VqHmmK58fx+dWNU4tEQ6kJzZaJVhZeNQuaHq2+Fus6e0VBegDXyUdw/20QsSHoX0fQ/w2jyeT1+QO6XWqVhUgg11aW/j8xNzvvZqsG8LRi2fm28oBBValBlk6s80S7uuH4JnEuH4rPqvX1D07jGvuXFGIjfadcLl25ef3afy0WCzmuvsrwHKmOTdbTcDgyA21ASqVS3juI7S+BfrfUF01YbZMCspWrMQ/0eQu23WIlh4tAWzJDKvlc/rlioZAG+To4q+fLN63oiMnWyrGumjUDBevA6Oj4Q7int7XIEvje2lx/DE4Z6SXwygN/NmYooD9OShXcmz6C+5LMLZoUk+Fw53d7vb47tzc3/jkW29vh6m7Ec6DDZDLLGP3LpdJOsVisiu1SUyqboPX6BWgN/JUeSY1+crpcndGu7ts7OsJ3IPjT40XSKNQHa2vLfw1yMj810P9Nm2dnAP1a1v7GZbPbPVMzFz4kV9geL+L4U0iVIxLt6sPP2nrxEZdNPp/LgVwJIxkgAJr3BCOu8XAw2PHt3PiSR+P60sLcZ1XapOSA4O+p5nViwjVhGh2ffKCjo+NHcQ67lXXGZz27srTwC6lUktj7tc7VV0XqvjMQjKoS4cKpdymTEy9cuv1f2R2O7wBubAuFkz/Gvk6DQs5+pfXlWctrwF8skrVfy+r/x/0D8A7B4k+ljhOMDrV6CQ8Wk9lsrCL6B2HRyrSAdwTHL1vB8ktfOrj8kXKlGp7b2TWsxg7AajGDHwFtX6gDukNBcFitDKlKFncBnIp/1wW2fBMx8huEk0WK9zeKrv2MWQ8kC78A9AX3fYMYQmBglm76KhH87WfTLNUfhQzMxQj8d4LdzHtInf4peQKU6xV6tI307TuFRICFK1SqMNQdZfXYTqYaS3jM000EYPR9ybWO3QohtfXzu09fnD1cnzSZEMYLcQzMc2G8Nwoz/b3MLZ94AyQvBGnbZeSB9SrD8J0+L8wbdllb46W08fcX/8lK/VMXlR9UL5/bxbgUSDFiIQ4E/KyEw5QtFCCdxyuXb4QPkEdA1BY8fk/fvQsGAfTTBiOlz+PDO9glutdzcQeyDbqJgA5ONzPZhk73FmPmqyjAD/X29n0/CqFj8oGA6snJyT+vLi/+wfHxUZw8C+gSwf+poF2v08FD89IgZVVg00ggzWlspCSwoZSrS8glN/9kIr4l1hW49Hoya7+oFDKLXgVs7vf2DUz39vX/jJoCY3tr82e3tzaIYb8stgVfjThEQvwLBZ1ToIeYHpA6qQmkeH2+sMXS1jJJdS6hoPgsvAQHq86c4lqkfmSFHMa9pqvdc8j6sbm+dhlUACkKWraOjtCgPxCcdLlcJIgOA6in3iKXR5SlPrm4MPvnOOcycCqYtEoxxHucqM196bVVH2ilfVJelu6e3qn+gcGPoIzVUFpkMullBP1PVqtVCovoNrHN8nmVGgLav0gmExTaouViq1RSqbkJS21uZ7lgYx4IdvTabO3J9JKpxIrEsdHT2z+G6+u7edCPx9DywtzsL5yc5KWxa6QPFb+i9J6R1Y+IxxBEteUZyGQyT4peIK0s/i+6Mk1HjHorIKvMBtG4xiem3qYnZIjakkolvgbaln5VxcdLZaHTScSmlbpPae2n1H3uycmZhxD8h/Q8P5tJP4n7yQHIyenUgD8bs/W11a8XC8Vk/+DgT+ESVmYKMOAaGR4ZG/+30e7u+Z2tza8mEnHiDTAFg6FhpbdMLpddAfkeqwT+yn0LoL2iUgn8JcWdI9gRGkJQecnj8V7APbe/XXpDrXJ4ePi546OjXdDee7TCi24lmd9ZLP2ybD7chce11TVz7uKHcBwb8kexUNifn7tJxgwLySoI/Ed1VKu+v7d7BaDJ0q8kbWxwHdG9h4ZG3k9EsNxtKjiPPoFyjmQwkS7lPUDxb2VmKiOer+GRkbF/jWN/NzQrTmsn+fzfz85e/11sbxbaK9I199FXgrX/BYJ+Kyis/ecuXHq/y+X+QZApdEqfvX71yp9As1yu5t35Ld+nZymvAX+xSGBfDfRT+WWzofaOU5b/euHkpHGAVAWLPx/rL0tRdz44tDDojvz8P+088YPxwuE9parBWMKfZE4KEEumIRxLsLRw3SEEqRYri9MnAjvJYm0QzfhkVWdAXwTDstwVBlEZIFm5jUIogBQTL4TDCxCeKt7p9oANZePVZJKBegL/gx0dEHS4xDgEYQVRijqJwP2wlGHA/+bRqhvBv5nuTSn/mNICP99KJNnziqVi/ULHOBFq0PcbLPPx4rH3U5uP35mtngRMZiOrdBVl2KFoJ2Ps9zodrC4VRkhoaFjl+aPYhP1yeWENrm9siW00sPAHyfhM9+pBsB/tCDLPgVqNG04xhSH9zmisw27iGL5yfQ5K1SpTNHzX0Ft2zHU6Hwz27Xw8MHu0HtjJxf1H5Yy7hr0m6HaEinht7oLf5jo65xtePR8c2ajXGsBUayOTvEKkDZ29UkFBwTk8OvYet9v9RiUgQ+F6HYHI/1pbXSamWXZIEEgGFaJA8j7Bwp5Zl/I1Cn/LNlNKWWW1WoN61kU2m7mG92SZHPh7gjwlnEkk9Gtc/QND53t6+z6GfSnTemN7djbWVz+Kh/aa1B7s+xqi/JII+gXHE3yrZjBK7QBQEVY7QuFRPbnai8XicjaTSYJ+a/+tENS1AEor8jpbtLunKfuBWkGhYp9SPbrcoRCCe6fT6QrYHY6w1WrrIau4GDvb4j71Mgrcj2xvb/5JbH9vE+S8JWqAXzmXeeG5VdvbEUGpuWY3hMfBoZG7u7p7/i0fn4mgf372xrWv4NwiwjFTONz5vGP7c9nsk7jWvgzNoF9J3tYK3LZzpW5qX2cnY5NvOc60DmN7e7RuatgHA/0DA+/j3aKx/bGV5cWfFzke1PYItdh+2ViEO6PDOF88bbqpiuv3cW6O6A31eEFFJ+hvxeCvZvG3j09Ovdnn8+sBG8ROn93d2b4O2kqwbyVLf7vMGQ7u1UFkfhOT0+9yezy6+oqU47u7O4+CsIZoLWkBfz4TTHVvb2cO1/RHx8YnP+hwOu+DZs80IvKbGZ+cnuo7yW/GD2LPBYJBZTaGeiqVXIRmZZAW8NcKTeLr2LD6k7INz5/eQCA443S5Ltjt9nMmk7lDpa5nKihLplaXF/8ZmsOLtLJF3FLlUouc6srwLC2lbQOw4b7iOHf+4k9gXzVIWFGmOkLQ/xkReBuxTzsdDmdbZX6hUNhPxA92oRn08+PLe2kYu3t6KR2ujAA2k8k8tbu7vcb9tqa4B68o5e/b2NuJGHdsYuqBYDD4QyiONHl3kHfjYSr5mwvzs5/HvyXPDS1l+mugX3tvUrr5s+9NTZ970Ov1/Rvgzk+cV09dv/rcz+FrWaUfVcH/K6Fv9ZbXgP8ZikaKP+kA0doc2b89Vmf9B4fe8fvLma1HH49de3e8mD5vRfRbQkxF6eqYtRwxDrm82y1mBHEmCPt90OX3Qm9nCMxGk+Cyzm7IIWGxNhI5n5QJnnEAGKFBJAiSUqBuYJ4E9Lff4YThEMAapcfD75AS4MRdFhn/hUZS2juKsaf6JIrHdryxDQFx0CByDHQHg8w9f5el8BMe3mHznrhNdvq5U+qnK4dL3U/Erk7V8MAkwj7KchD0uuDe6UkIeJwgkfSdRsLXmXtAA1vWCSFW4JErNyCRzjDwToWMX2GfF84P9EFfJMSAfsOfvlqX9ZH0RwXv8+jlWdhJpRipHylULvRNwo4pPXBjY760kd1znVRLViH8oM4yBlDWA5PV0rhVqV5xxQrHrv2Tyz1fObh6x92dM9dv94/PQ7PFiRcKZZYhPAhheGTsnmBH6AElozFZXlH4+dulhflPFIsF3nonHRo8AOHBsZYbb2MTDXdGpkEHmKR7JxPx50CufuE13dJzZIqugcHh2/CQ/SgJivzNcJ6sITD5aTywt4ATZnBuVUXlgswduS7ktNRqixk3e11u/tiPkpt/OzftW2GdbCUwtYo/tqFwG3K7PbraSJkNLly6/V+LihDdsaTELIxC1BcRyP3N3u72OsiBfRmawZ1W//EWM6mouWK3S/mkdsizgx5Bx4O4Vn6Es6TVs5nMTQT9j5ClH5jLr8+Pwt2ZXGulgkJCfGlxjuL6JbdkLRd/PRZtJSjlLRgyLwbcB1x6PHBwHu8UCie5SLSrB9fYQzjUDdCPayW7vbXx/+J63YFmS5IyREfLE8EcCoXbprPD/Wjp6DC1D62t/S+qm38LECvjJwB1UkhVwE/Ko8mpmXcGgh26+SByudxzKp4OL7t43OeZck1NSdLoq4nJmQf9geBFvXUoFgqLqWRiA+Qu6zzwbyiOxasxj7LZTPK5K9/4n4NDw0+GO6NEbquW0cSIIHGwf2BoUPkBrofy8fFRAuTnlQTulIov/r2m/YvC73COdPp8/kGn0zlqtdknLRYLZcQJgkoGlBdSEon4Z0qlErkmK0F/yzX2EoF+Ne8aNWu/BbvQfu78pR/H8bpTun+tVs0tLcz9XS6Xpf2W7d9d3T1tw51YP8UPrnFjCiBn8m8ClDh/LN3dvd8GnGJGCOla/jycZnrg2wTQGvizC+s73NPb/0Gr1aqmuK2Xy+UrmxtrvxLb36N1oNd77tUO+tVCRtRi+41j45NvCgSD/x64ccX9eXZ+9sZP4VkpZbJRu14WytmXqrwG/J9f4fn3pFhvNfAvfRfE79VGPX1zeG2u52IjX49df+teIXHRaDJbJZdzAqH5UhnqxRIc5/Jk+YShrqhATtfA+wbVmhBnAJEAru7GWJq6DP6eOOVcdhuM93ZB0EfWeRsDu4ITQR38dgdz/ac0f+RpQCEA2VKRxf0T6KV7Bj1uSOMaKlbLxljh0LOdOXCZLRb26Ijfyyzz26nDRod0OTsIqNJGXstVC5aHd54eXsvGQkYTy8NHaaDgrrERmBnuBbLxMg4CEEj8iLiPYvnNtP65Zp5gnf7PU1cYLwH1E/EddHf44dLQIHQGfEzBIbiFi9kJyHFD0oJw+J9+++jVWdg9PGTKA/rIZrbC/nECrm7MubCOLvKMMJtO9/666CsBIGU7AEkXwbgDylBzPh679rqQI1jqt4WIebgCzUIh/1rp7esf7erufSsKECH5gOLQFwpXNjfX/yR+ECNXxSKcHghaFjZl7C4VVcGe3Pw9Hq8uN/9KuZwSQboS9IPivcY1ODRyBx6GP6XMA1+tVFaWlub/UyrJcsAr879LbeMVGHUENgT++Wc02mG3O9x4tXWBJ6vTgeDmrwZcb7VLsp7DTSs/va27p/d2PTndxWLQ+10irKtUylez2eyXtjc3HkNAeawYB61Ly51ZC/S3s8q2cuVrvBpwzs6cu/D9Xq/vO4HLTICg/+rNG1c/hwe9XerfaLSrH86g+OD6pLq7s/Vn+XyeyMD0Evq1IjDUcl3k2yblsR5FwdQNbUo8tr+M340MDY++Qx5fXa/E9vd/Y2d7aw7UXUe1FBOysbBYrE6X2912bzg+Pn5SwTHSKmf9C15TZyCm07I6NhH6kcv69MyF7/B4vdNnqEr96PCQDxlqx3HxcnHv15M9Q2sfsuPO4hhnSreOu87SV8lkgjxniioXD/yBq4+sH6msra58bXdn5+bwyOi3+fyBb8N5384bRWi4wWjp6xu4fXNj/avlcqkser3J4rdpw7TZbGabzY7/szutVpvLbrcHEMR14FqImC3mKIUbUO51FBtcIu9PO6+cwkk+v314mNo6OkqlJyZn3o5nvJ4QElI8HqyvrfB9xp+RWl4lt6S0AP3tmNablLY0Fgj6f8zpcr1J6j/iMVhdWf4b7CfyxKP+MeL+7ne7PW1T1uJ+n9/b3VmGU1lEk/xX+nf/4NAdFqs1zN8nmYh/JZvNSBwBfJv4e6mmaA2Fwl29/QPf6XQ634pfa+K6IIU6Hqt/tDA/+w8I/iVlFw/8eVlO7Vx9pYJ+pWFKrzFAliWKvovn4G2hcOfP8F6ytVp1Y3lp4SPp9HEaVIxtoA76v+X79qzlNeB/xqKw+gO0Bv/S53yMOJuMg67IwuBwZOu4nI88k7x5z9zR5huq9ZrTYBRuTSCWwPobpyeYMoBKw6ovVcYguL6fFMuwsrMPxB2QwPlO1nkGesUa5BA0Hy7kYbQnwnLcOxH8W0ynGMGD/55EoL9wcMBAfL5cghv7uzATibKH3DU+Al+4ch2sFiv8zeojYTwQGewl9/iuUJAB9e14sqGAGHZFaTN1bORjns9sfXWwCjWz0SR8SGSG77jnDvDYHSBlMySwnyuVWLYBr90OJoMA+gUmf4BsPg+fQdBPYJ/u73U54A2T49AZ9AK9Jbjzy7Az4wMwyI7oOkt5+KXnbsJx/kQ8fYRflaplOMgkWaaAcqXKwincTgf48TkUxkB9ZbNYwI6XxWyGAvZPMpNlnge5k6LYhpohD6WexdyuO55LGI9LOWsJyrZUIeep16oV/F3Ja3Xm7u677fjB29/a73Q4uxWVpoM/gSD1Exvra18X2cT5+dXYvFD4IZd+fiMTZ0MDFGlZli2im7+MBEmrZLKZmzVJmyI/+FUFy6HhkTuiXQz0yxjiEfQvLS7Of/RQILThgRQTasS2KF30xFBm9bQ5HaHQoB5yqXKptJE+Po5Bawvdi+rmr0Noaids27BtThyrs6R/Ui3kWoj9m0BhaRv7YiGXy16N7e9dF8F+Yz8CuXKJVwBUofngVIvn1wL9ZznclcQ9CEYtjpnzl35CELBO91QU2C4j6P8MD/rJqoN9powL1lWwPx7b3tokjgQ+FvkshFpqluhWoLQRwoDCS1srO+4NRfI8Gh4eIdDPpzyrHx0dfXx1ZemroM0yXwe5C7Kqq25nJDqKIKclSKEwo9je7uU28+NFAyU6QCyvEFSzXDeFzyDA806fO/8DTqdLlzfNadtrxdj+7g3Qpwx7SQR2DeFaD2hTTbtGezm59wc7Qm+ANqCXL5TCb39vh9KnlkCduZzPMsGHwzWlxSSPt7nZG59C4PjVgYGhd/r8/jcbjaZ2ijIDzuf3hjsjZOWtipw8jfsSZZIE5PFvo/h3W2DfXOqVcrmyfZLPLR2mUmvxeCxRKpWoP93EP4Nr1aL3Tqlk4mECtaCeJlIrvOhFt/afAfSrhWbJ9m8KiTh/4eKPuNzut0t9S0pDlHH++iC2T0YSh3hvQ3dv36Se0L2jo8MFUuZI44Xr2N/b138Rn9GHRwDjfcFByeCevr2/t7tIhHvhcOQe5X0Q+EscEHzbJMu/ktivjnKTtae3/1wg2PGAzWZ7nTL7hFhqpWLxsc3N9d/D9m0pxk9NYagVMvdKBv2tPAAtoG4MkKXv6+0bmIh2df8Cn/4T5Zz99bXVf4fjegDqRjdN5ewroY/PUl4D/s+/8Jb8Vt/hgb9SSKr4LM7KA9G7Pnt3+Pwzn9p4/DsTlfQ44di7p8Zgsr9HHqMOIMT+IxbbTx3jdQR7R0cQPySwL1ivTWZxSMWYf8JUdgSvvaEOpkhw2YRQX0aCZzjlEXAgqJ2JRmHuIMbc8ClrwFwsBpORCCPIG4qGYPMgCTVDXVQ/4MnmtIMVQXEWwW/m5EQExQUIOnzWh3eeHpjPbARqTJMhkOedG+yDSyODQsew8IQ6FBHsHxdOoFapIdB24f3MYpC3cCLvHKTgS9duMhBPLvrnB/rhzokR9jnv1i9Z5lm4AL4vxP+LMf3442urm3BldR3YucId7RQ+4HbYWf9E/EK6ReIaoEL8AxQuwKsVBNJEI2NK+KevXW70M6UP/OzqE8NsDIzKcwOgy+GDb7/jXXD34G3M44IvRMyGoPjxtdXlL6LQQIzd0mEk12aIFweU1fKGtyRICYXCk6BPuKmjIHKTuzdv7VeCdANZ+hH0/3sV0L+8uDD3nw4PUwS+1QQaZSpCk+LeqiRwfn9Ql9cCAsRnVTIg3DILnYbgrWblVrNGNtyQUWgdQ9Cry7pVrVbSlXIlgesjga8xFIr2S6XiTi6X285m0vh3KY8CpdJd9KxXK2tuO9DfzkrEH/KNz1wut29y+txPo5B1G8hB/5M3rl/9p1q1auOeQ4J+L4J/WR5wPYUsbThJPwnNoL+VpV8Pn0HbbAUotAaxnX3QplC7RkbH3wKKGOJ8Pv/4/OyNvwfttcXXU+kGK6tfINhe0YRzaR37PwXt3dyl5z0vYNKGuV9PnLpq7nAKn8E59a9xTp2ZB6JwUljA9vOZEtp5Dn3ThEmV/mryxoL2oE2WPYOEauyr9wQCwfvgjIA4n889VyyyHPRqBGZqhJMmlf6TzVVKxzo3e+PTdrvj8b7+gTchAHsjrotW8eAGCZwZDGfE8xoFz5Ij3C/WEdwtZLLpxXgstobrgchpad8m0jiP2KeGSLRrwGQy6QL+eKZntzbXnwBt5d03hcVfA/SrpTG0gPYe3gD9M+cvfr/b4303nIL+ys725sd3d7bJYt8A/eRx4fcHBnX0f21/d2dW/CeLr5+cnnmv0vuPMik4nM7ecGeEeamoecP1DQy+DeXlR07y+XixWDgs48EptZm5gOBm4XZ7Qm6PZ8DhcE6ROz8+zwvqa6GO82IeQecfrK4sPaXgYVILmZMAaYPvCV6BoL8NL4tS+dzWEEDfQ8Df39fX/0s8fxT2d2p7a+PDYkrGViEUSoPFq7K8BvyhPaO/+B0jflaj79C/cYEbE4k45W0xbAls/w0Bi0i2iAgON32JBV1w4xdQPM8K39gM3CZ7uccZup5Ip8fpAblCEY6yOQZmC8Uy5PHf5MYfQ6C/lzpm9yQASbUhS7WkH2ikBMR/dwW8MNXfw1zhzcbTfY9c6pkbv8HEQLFUyLI9jUB/IXbA2P6J9I7i/4dDIbhzbAS24ik4zRVYR6DsZwqCrYO4kI4PP3JY7fCJ9Ud7heUtyKhWswnecvECdPq9pz/HzymkgBQGZMnqcLmZ54D0OdUxcZyB5xCsB1xO8OJ1FwJ+JyMbhNObgLiSEQtTnSUlADkYUBaDHazz1+aWIF8sYh+YWSpACmkIIciPBvww1h0FDwJ9ep7ULiIXbDzBYBAVCKLZDNtEqozLS5tQoJAMqRqkqCBALzgpCt/FL3Z5Q/DQhQfgTSN3gVUhA5CaIpNOL62vrTyWzWT2xEdQ2AfNi4ZLEzHaG40mk2iZENzfaT416tzoDPyW2YR9ITucRbZcJtx5vD59bv6VShrn+PZpNxjMErkfL0TRWwj6bxNSMClAf7W6vrQ0/1EC/fhZGdcD3rZSwsOTbcy4Hug9Nnz4XT58hp3odSFLAas/flcWruByuwZ1NKOGa1SyTp41RvvMRadWW09OcTsKjbrijguFk81rzz37h0SShP8kUEIWI2UKKK0wB/61qvLvdrFxavH8ytjrViy9mu58wY5QdHRs4udwL+WtsvVsJv1lBP3/gPPBpniWMRyODD2PYavt7e58HPuRXE61WPy1rNlabv5afA5NhIWRrq7pM1gFZaAfBdWN+bkbv08p00A7LIEPydEE/bgOCRS37b98LntTPLvauac+7zWlU1iUhf5AC6u19J4/EOgZH5+i3OGSy289ET+Yx7k2RgCiXb2yucxN0A5/ecnc/HX0l9YaVM2aQa/kVTI1ff67fX7//cD4VurVo8PUMvadx+PxdrepUv0wmWyQ0YJ6PDMfgiJ5S6rF3yvnahnXamZpcf4R3Bue7O3rvxTt6nm3wgvmhRY66jKUfQbPpc1KubyOz1w5Pj5aSSWTBBIrcLpfSQrbprOkoyM0oPeBmUz6KVFRosXir7q+blGKzLPEXyut/Q2r7cy5C+/3en3fDadnQzW2v/fxzY31G2KfNZ7R09M3rmcfRJC+g+OQlOqKwH6gVchfq/A33O+mxsYnJ2lug+AVwsC4yCFjEl/bcebUibvo+Ojwfy8vLTxCnlnQDPK1suC03Dtf4aBfaw9vCfpD4c4oypv/HQXihsIPxy29u7P977e3NpdAvr+0k/leMg6Wl7q8BvxBm8lfUeqK71bZxA7JhDGGGAX2dwoMZ+BM5uIP8knJv1ee8Q9dfvZo8V0mg9l5c3MbbmxskYqAWfkZmV1dsGoT0Bdgo/QYAweGAcGxhbHk93QGwYZgk0IFyHotpLozCDH+ImV+XZY6wMAUBNPRKCweHEChQtb4AqTyeQgi8J7q7YYbm9uN5wTdLgZuNxPJRhfVJSRcF4gFh7s74fWTo2AxmsWsA0J9k/ksS6vnttkh6HQ1OljaKYhboKsjAO8OB1koALOy14X61rkoCtKlkBW+LjbBIPZR7OgYdhIpWNs7YOz+/Z0hCPk8EMYr4HYzJQF5TtC9yJNAjlvUimDaJ13GjbVtWNjeY88pYx+57HYYxPuTt4DH5QCL2QR+uxfGApMw5BljCgf5RKrDfGwVnpx7ZmPC3CVp+SXhoSpqi/kcpUbByK8pVDY21Wq1ogo6sOoWn8/XqSdlGBUU8Jcrp9kqTOKhyFzr6lKaByz9A4PnEfR/WAX0b68sLXxUiuknl3MC/fQ3AX5p3leF9cGDE9YeSklI/8bPpfcbAgWFK0gufa0KAqNYKpnYBm03f6WG/XkfAjpAv9rBpkY+Zqcc9XqswFQOYvtfxn4lTo08d0nAX8lErwb6W/2tjONvZeWXXtsx9PJx7qrxe909vWP9/YM/bzSZOrln1DPp48/evHHtn3BuWLnnsWciGCFSP10pxviSy2af3tpcJ5CijOvXErxbsfhrgX7VWGqyqAaDHWeJMW8UIqZaX13+rcLJySG0dg0GaJ3Cj120phD8u9o99+jocA6a15EW8H2hln493iP8nNICspZItGsMBcZ/h21s7Bt7uztPb26ub+B600MoVse9jAf+3zQr7IvcX+0Ub1YiYps+d+GHcE3dC2wvrhaWlxY/n0zE0xcv3fFguzrhnp2OxfYXQB3sK+cOgGLvB3XllIW7HwMBuO+dbG1uPBuJdD0AHPBHcHhte3vz0wg6Ox1OZ5fVYu0wmU0+lCFozZFCmc6jPBFiovxwhO07qlaqyXKlHC8WCjEE4XvZTOYYAX6JyyoDinpJ/1ZV/tjsZDF28vtXq1I/2N+jLBlaKUNV19fLCPQ3ATQE/d/h9fn59Gq1+EHsE6srS0S0a+fubSCvCJ1rEA4OYte4vjAGgh3PR9nLF4OUiviMXiFk4Z87Pj7669XlxUdR1pAAfyt+HK0989UC+vWG/anNKSOeleGR0fFfQSwUaQxCvZ6L7e/91Mb6KimTWmVJ0FSevRrLa8BfZ9FSDuBhKMWpSaVBdCVuJPziVnX3l66w3V95V+89v/nE3tXvOyxlBxC0G+oIgA11IWa9htirWCnVvWZHOewInrgtzsrayX6HAFwFC/NMXw+cG+4Do0FwNydoS6CfrNjZUqHBF0AA32wSGO2plhR7b8H3JJLBiUiEgf+Tcgk2UynwIbi9bXQINuNJyCBgp3CAnnCAKRFSx1mxyY1wKOayf9/FGcYBwOzfYu/R37tHR4xHIOL1gtdmP+2+RhpB4T/WeaT4oH1CVChImFNy6y81vBeMCOYrjBjxpFAWQhcGeuH2kSHWL6e/BRbHL9XX0Kg3X5ScAUK7CuUyXF/bgPVYAvo6gxD1+aE7FACPwyHwDwB5TVhh2DsBQ15SdjQrsGPZBPzVU5+BpzevUp7RgcuO4AOvC01dH/X0rnLzQdq4aAMkYcAivjaY80HOI9FIK4OAQMO6Wjd3hMNjoK3ZkJVUKrkAzQKkNJ9ZY3t6+yfw+oiSyI8sJetrKx9NCB4DavGdai7+fNECT4I1ONgxoqcdKABepzAKaBY2XzQL5fPMK66MO26wZ+MYOgYGhu7X0z5s28neHos5PlG5tFzV1UCslmVfD5hrBzj4tivZn/n3mcA4PDL2OgRpP61IA1lDwPnJuZvX/y+u4SbQT1e0q3tET3yovP+qGRRE/wqef1y/Vj/osrAGO0L9NptdlyJOWXUUov88Hj+QyD+1lBXKMCA1iwsbJ5/fPwBt5hzFuIss7VqeIU39cxYB9gzCYrsYdZng2D8wdEdPb+9P4vRoKCcRmH59bXV5jqyyeuYNgtljPOu3QC7Et/SGudXCu47+apdyrSk222KxOmbOX/hxp9P1ehAUsMWV5aXPJOIHh26PN4pAuu18LRROKAY7B+2tnVJfGbhXqQ2twJN0X3KnHzOZzXwWj/rBwf4XcH0s4UV7o+zcwbGucR4rZ93rZOSAYl3N0LynEvlbN04rXfJ1uVTawbNyA7RBy60moW01h1p5a8myrkjX1Mz59/r8gR8FLjwL5Ym/XVqc/zIIZ55y7x7CideW3LRSKWdi+7vLwKWCtFltzyuDy/MsFGYZLxWLX8X2/N/NjbUbohFDjRtHNZMTaMfyvwb6tQ0CpkAg2DE2MfUrJpOpEaJFPFgHsf2fxjNcSbiqxaHQtH6+1fv6+ZbXgP8LKDRpVlbXjaKrPxWJREmw/JfLFTi1tigtak3An64pd//V6fGBlc18bGQ9Gxup1qteQx3sZoPZGLB6qoPeaMVlshufSy72Pbp3ZcRoFsIJfG4nvGFmHEIejwju6+L/BGBfRlBcwuoQiR5Zu82Uy17UcFL6QALYlN5PKgSJidl/LrbPmPSTuSx0erzwhulx+Ow3ngO7zQZBspzXBUBsaKTXE1IAvhVBv81sFsC2uA0QON5MJVlcf5SBfofoAVA/XYkSKaESewMIChAQ2iQpLKQ2CPcxQsDpgrBb7p0leUboKxKH/2kF6FkHR0cs9KI/EobXT401uBdIHUQeCTaTHQa94wj4/3/23gNAtqwqF16VU1dXdXd1zjndvmkCk2AGGNKAIu8JCoJP9KGCYkBABgcBRUR9gvj/qKDCrw+eyJAGAZFhcs733g63c87VoVJXDv/au86p3mfXPqFvAJ3Xe+bcqq6qc84+O65vhW91I+Av53xJZOPw+NJT8KVHvguZXIZ+hgKLaTsdbrtn7dHWalvl9jWB/sdP+rplq5JMfmeX3ssWD3nRZBcxuqCm02m8pJUnkCstrL5KY7mqUchNoKC3DGJBhxJYkjQ2be3tv8On7MOdMbSyvHSnlL5GDfTzFh8ApcVHzWJK33u9lV1GniMU2nsB1IXOyxaiLgH0s4K20MW/u6fvZqfLVW/k/ol4fCaXzRKtGw/62bRZrJJFJOzygq9uvlum8M8su/drMfcLN3Yo5uN9fVV19btBwZJcyOzu7n5x6uL4/VK7lbU3sRj5q6qPavkp7O7s3BONRjah3MWfJSAT8WmwJK9yfeRXvewNJVf/+vqGETCg4OHLQSz2CAo794MypEOk5AHB9YVA2uPW9zDB7WyD8EWA2DOEj5080tzSIaVT48nQshLRsdXbP/DKQKDuf7IpIBEQPjo3M0WI50gaxVoj9Usmk3NgzMX/x1IuUUmilnatmCnF5SKZDn7P6XSeBrrd5tOLC/PfxPYiZFmeurr6NiNKkmgkcgHUQb8IxJaswlAuI4kMJlnpuYir97XM+WTv2kcwQGLAWeVnaW7Ibt1c36mteSKvHjbdG5uCUPFMOK4Mc0jEYtFzEg+NyNp/1Qj9riDoL63juIa/AUHarwKTfSUcDt2D6/cPpN8p7kNc8evqGwyR2Ib298ekVJqyzFMKDTxKyeKeGYtGRolnCsnkYHc4alFs8hNCXYksjoiaJBPEAQL7XRLugWB/MhwJndtcX5vBNTAJYh4cNbCv50UH8H8H6Ndz7xel7KOgv29g6M9wn2dCZwpJlFHvnJudfhLEaRJ159BPuq1+kuUY+F9m6e7qoOAFB7z8kewBUMCNFJKJhDzI+Ikviq+lnxECk1ZX3RQeJCczcb8k2lCv/P5H68+ePb8/12exWkzE4j7S0QKD7S0UruZLlvG8RKBXJLcjFn2H1QY1BULcV8RbxRCBAo2tNxVvXFxNpTAAcq3e2loIJRPgRhBPPm2qqaIEga21NVSBsC/xEBQd7AGu6+2CQayPTLwn437ijr+yv4egP0ct/T6n+9CKz3gElAC3SYn8C9L1i/HzhzH3xHOBhj9Izynfsxh0f9hPpex+AugihwfQWIFC8d6Fgqn0TMTN3l9RAY3VVbSNCvnDk502F3Qh4G/zdgkt/KlcCsaCo/DA1OMwsbwCmXyaehyQUAaz5F1hBaspkkvU37fx/M88uzN5zY31J384WNFKFAAsaGZj3GVWfxaQYyc68O+c0H3K7fb4nC6nbvo7UuLxgxXc3GSllYW5Dy0obLW2d3Qh6DcrtPRko1xfX/vDtdXlKdAH/SKLpPxeZKmiz4NCqdfhdOqm/CFkScHtbT7mS5PY7wpYJ3nQr5Uyi3fxdzS3tI3IZERGSjQWmYTyHNlq8f1qz60l9KoBfv65tYRFvdQ8FjMC9xMjp95ZUeF9MzBx7JJG/9O4uT8rncPWqXRfMh5tNpuumzpb0unUIoLne0Gcuu8oObPVrOmaVmkUOL3eSp8hRRxbstnMxtTUxD9LWT9EfAS8Uk1WPGu6geOc0lU2YZutM8BJzzvEUDlCfLoIhKgBWcJpYh06cfLnfD7/W4ABISgs3j8zPUnGEx0vnoqKaiP1xDVxGtQB7I81vt9gpgMj87D0HY7FmoGBobtsdvsAbahCIbOyvPS1zY01ogAm67zJ5/frKoeINX13N0jWJSOutjzxpN6hkJ+wzlW4r42w90/E409lMhk5Vl6kyNNj+Bb1I+tZx+65quk9PR6P7h4ll92dnXOg7p58VZRLVwn034EY7T3AplyNRb8/MXbhbsLTI7oP/r7e5dIPiSDrzsbG2gtSGxWk+plS6VTYA7rOAqWSSadD42Pn/zkejxNlFlGaE0VmAmWqlNVqzZvM5gxKZRniyU8IcSUXfn6+iyz4apZ9Pbf+FwXgJ+US0ojy63eZbEDc+yVLPwv6UzvB4F24jsthsmo8IsdM/irlGPhfoSJI80cI70pu/6C+gWkdZZvPN5ceumk5tt1PQD8hunvF6SGodLtBVsQfZp0vVoVaxAsSQKbbVQEcVnnnOsRbeUlRQICtbE4mMfp2BPwBd0XpewJah1qbwe0ohtRt7oYo4R1hwn851sXrckvW8EMPPmoxj0UJmxs0+nzgd7qApRYo1r0ghRmAVI/DOskW/iLoLlBsnpdS+1HlBeceQJ65yL5/6Mhvlj0cJH0A4Ukg4QHF+8uWffkyplKnkWKhYRGyEqP4ndfmhU5fP7RWtON1yqdRNp+B+cgMTO9PQDqbhv72ejwaaHgFaUOiMNmLFFMCLgd3IJFKEzJIUzibaPv+8hO/8pRzbPT2hmu/0eKuJSEAigURn122eLAWfxwSOUUsPHOerSYQ6DbqehgO7S9A+WJN74UbdW1Xd+9vS+y2TCmkg9tbn1peWiBCDFmM1eKOWRdZuWjFiCvd/GsC7UbS+KVSyTk8YnAV4nE1hCaRxVszXZZ8NDQ09be1t78WOAI3rbK/tzfJtDHr8q3GCm1U0NUC/OxzG93YVUG/E6U+ycqoYA4nlpa11eU/QfAxDUoPlzIlCwJ/Q/GhTMmtr61+FQU7Mj7U4vpFObONtIcar4PCFb2+obGfxFIfpdJFMLb8D8lEgrDq62UfEPhMKdquFDZkt9vdKPTqcmakUqlNUAqwWm2jO7cukcRPbWzJGSGsVpvNcWLk1G8iKLydaQMC+r8/PXXxKZBAPylul9sI8Cf8EnNQLuBfkRCHoxQNzwieeZ2fh2rA30Lc0rt6+j6OY4AK12Scra2ufEUiy6KoCtvS43S6dNPAZrPZYCQc3gZjFs+ydub+Nqn8hoKp1rb2m9l0XuTzYHDrPji09rNroRGGbz1rP8uVYQaxAgxwLXPZbHZDLugkhGRnJ7gIIAxruCoWSgNW2aO4YtPfDgydeB3KBu+Fw5DAAoLr+8YunCNKSpYTQRGK0tjUfFKlnxUlEY8vRCORLTiUG+g1cV6uIDg8bfTZNzbWnsB6RUDpVUlS3iYlS76R8DhRqJMaf46asutFBUBV1qWjKpLkz+mYwnWpsbu3/09Z934K+nd27sJ1/EGmr/S4Mcrw1IuhzS+nHAN/pmiR/Gkx/suFB/8OpzMfixHeLcOabC1XM7hn5bGXLseDw4SGxG23wxtecgbrzFuZJWgqWZOlt0UpkAG1JVN84fCs4u+Kn68Hd2FmfRO2wxEK6jtq62Cgo4n+nmQKIO7/JCvA0nYQznR3wInONpDyrlNG/XSuQMMLCFv+QToFkUSSpv4j7PqRRILyDuTyRTBPPAfI7+hnErjPM09jOqxk6fnkZ5Q/LpS9SucUFH8xXgPFYjEXyQ6JEoDyHpT+NlFPCMIPIPMhkPrXu+uhr2oQGtzNVOHBF8IzsBybh5n9i5DMJWhtifc9bRpTgYJ+8hkJkyDkiN1N9XDLcD9NzUjICFd394gywBTOxk9+delHQ63u+vvuaL3hq16zm2xKJbdoEAB/ELvG00XV56sylLOaWGx2gjQ2nxck897KyurevoH34kLMC8v5/f39z83OTJEYPhH4VANTAGJSJzUrn9XvrzJkJT2IxXgG7iuSxu8KECGVWMblo76+sbejq/tnTSbjOZ/z+dxBaH9vnWtntY2QjStUA/oisM9bvLQUNEYIxNi+tPirqgJ9fYMfQaCmcPXMZbPz83MzHwsGt7dA7NJZUrB4PJ7Kigpvs9F2o2PjIPYsAn/ijixy8eeVU0IrgYp1Qy1EhVf6kLSaI3r15Es4FPrBxvrqKKhnH+DnF0/qx9az9B4xnc+QMi2ZCIL2/DE8ny4hPp0H+/x7euCzVA4Nn7zTbrefBSXo/zoKi8Qt1C3X0YUFx55br67Uir2zswzGshhcFYv/EZn71bg12Fc6f5qaW3vb2jv+CPu/TnrWzMb62heXlxYIiaNHfhZimdViSJdLKpmcZzIW6bUXr5wSjVH2KHUJYmtHZaXvVvbemUxmZmtzg9Sb9+ARZecQGVdEfckry+R6qoaMeb2V1UbairZXKrmAa7mal9EV5444IujXI2OVQ7Rei+Pjt5j2KSSTiUfHLrzwtxJJrzBFr9vtQZHCWNjezs72U1J/yh611OKP83IBx2/WoFGjEAmHN6GcK4I1VIg85dQy3OR0/tbyqKPlvzoAPSK5qJYxgF3HzfUNjW2dXT2fxHWJ8ZwppLC/PzI9OfEAHIP+yyrHwJ8rcro+UmSgT1L5gc5mXvrNx8Bk/4Qpv7G5TQHN7k5QPk+xAKDAQTgACqm03eSwp0vfSe73ZQtEOB/3TYcWb7HbHSZiUb9psJcCU7Fh57CYShcqlLC+PDULkpWdFsl6ToD5Y6NTsBmKFEnx8P/dSAyPA5jb3ITXXnuKAl6btXjvwdYm6GpqoGCdpPbbiERgPx6nYJ7eyiQBdXw9yKQVXgb0tgwHAKmDmfxBwLfiIUxlrW9i/mVfDlch2WpfbB8zow4wSSEBxY9ImkXyki/VWT6v5DWBe0p/TQ9c13AKWr3NihSIciGA/+LuJJwPXkDAH6fKAxu2U05qd0KOaJEUBYfXLv5LiBdrfF4I+L1wpq8TYvEkPDu7AAubW9bN1P6r/37q327sqWz9p59pvYWkMVMIxxaLlab3IxEb2WyGMDKXAS+L1epCgbjNyPhHwW03Hj+IS9e3FAUYk9XpcjoHBoZ/1Wq18m55hVg0+i8Xx0e/DcwGigt2Fo8cnk8O4kJXwGvzghJtYJ+/yhqLRc0I+Mx4fWsqlbIRmimsvCKNH8kL7PFUdBh4DEImRIidrmjasSPGIYvSHZUduMH14Qb3C0aAl6KfUullLi5ULWWWlqeDFtiXi15Ig9F0fSXAT46mppbu1vaOj+J4ZVODFdLp9FOTE2N/iuMhxtybVRQpwE5DY/OAUSGb3qCQTy4vLtwNYhZ/vs0UFkGBwKDl5q8W32/z+6sanS6XobAbuWQy6ZWZmclvgjg0QZR9gO1LTZDtKlq9da1uyWRqH5TK6iMrzzR4EYwAENF4KoGQmkBtQ3fRct3JXD9HiBBnpicJcJAzp9C6+3xVWjngSwX36U1s/zioW/Suqov/JTL3i8C+QvGG6861DY1NH8H5Q709COhH4Pz5xYW5C1JbldYHBNlGw8RkklojnCpaFkL2uVhFAK1PZ1f3rbhmKjwQIuHQ94jlFrTnh5anBq8AYF38WeWjGcr7v3S+22MsfKTYXnG+vXjXcDWl7JGLQW8Ro7wssns/sfT/DhyCe0inUk+Pnj/36Ww2m4dDjFG27jS1tIwYAewkVe3G+toYKIE/Oc+UTCYiiURize32tOtdh/zeX1XdGImEF6CcSJn1mtPixtEjxi2AOugv9eGLAXweIV3fkRRJzS2tPa1tHZ/A+c0QiUqW/iLoZ/tMTeY5Bv0a5Rj4c0Vk1cfP8qxCQOU8hbDV2FCXI8R/oJzwJRxOQD+Q2Ep7mryWiIcK5Ux09L5ei2vParXnCAhz2K1Q5fPQOPEiQz0BpxaaXx4Kh4C3mAIvD4lMhqado2AUcaGFIfYD6XGJ6/v4wgo8P7dA4Si9Fu6i3b7W6FxopZJAwH3Eg4QfwG4zUyCdRCDfUheARDoN8XQKgpEoxPA+dFXGexw+eEF6kEO3/CIZX/H7fEH+1EQt7qRushXeIsXuk4uS5yC/rXK5iteSWpQ+dkEG1Ieu+8A3Iv6bh2I2AOKxkMK2s1uKbVLqGIZAsNZTCwM1/TBQ3QMelRBiCvj3puDc9nlIZA+oUoQ8O/ESIM/gwOchGQ7MZYYNvn5F5UY+VwASwnHriQHoaaiDH50bMyGWr5yLrf3mZye/fuObO2/9gwZbDdFa080zV8zoICkBLPKGqFhUq/xVTSgMG4qBDodDq8BsztgeJoLBB4dG3mGz28tiPHHjvX987PwXgYvnJ2zQEuOtyMVfMb7DoX05baCJpMK0EIVWPm/Oc26+Xm9lrdVm03WhzOVyodD+PkkjKIrpFG7GWhvCEeOQWWJFTfIxFLr7Ozq7fxk3uCO5fEvtLjOMi0C+mputnmVfrRw19prf0NmN3dzV3fuS+obGD+E89bJ1QCH462Oj5/5OIkUFKBe4FeCaKEtQ6DySm38kHL5/f3+PtJ1e6j5ecNNrG7Zd1NwZJWVP08mjZCCQ4q2/lEmnw6Dv4p9XuYwoLIW+dzicum7+pEihM1pARHMcXcI80gP9JQDS0to20NLa/jEcE6WUjqTdtrc2/2Zudvo5KPJoKIRzo/H96XR6DbTn0xUDZwbbTA2w8Va1sqwZ8mv/4PDt1dU175fTsBIlIrbV5+bnZuS2UjyX2+MxQoJYQFC1COqA3wjot6gc8vck7MDt81fdwVyDZpJZXlogbv4p0M50IWJU5/uNr2devjcoQb9Q8eVwOnVDIuRyEIuKPEnUPEMvqRzRW0TPFbtklaVEfkr3fjJXnh0dPffJTCYtp11k27HUvyjTkFSmhkj9IuHQ07inH0j9yAJ/2h+h/b2LBoE/4D37cJw8Bkp5QOQBoGc91gL5ap4ktLwYwOclMPdrhYyUZIP2jq6TTc0tH5WVkbTxCoXkzk7wwzNTFx8GbUu/Vlz/i6Ldr1Q5Bv5XsbS2tRe6uzoKDPGfXHhSG71SILDeYbaFM5CrS6Fc/K8PPAFupwOctqJ3sAvBos/tQdBoo/HsxHWeHFv7YQTMWaip9MBIZys47XYwyx6gkvkfF1W477kLsBUKl4j98F7xN7TeNNvqrkv+XSx4OllI20lad6JAIFkAyG8ml9ZhcTsINqsVmqqroK+1kYLWRDYDB6k0JHHt340fUOBbW+kFi4TSKaA3H8q9BCTbpJj7EooH5WpJPibXXNzbofVvrvIXf1YoxvwXiQwlBYMsUzMu/YctWSiGQeBbkpbwIJWi9fe5XOC02sHvCECtqwEa3c3gRrBvEoB0UgjgX4ktwFxkCuKZAzzfDD7Kv3jIryArOEAOtQCZgUHbS0M+rzlQBa84OQwPjE4QhYIpV8hfe/fsg7/z3sH//iFQxhxqkjnh5myURKywu7uzBoyFhaQIHDox8kan01l2DdzcxybGRv9SYtpl3eTU3I9Za2Rp40Awb0Kwp2Y5Lz1XdU1NhyF301RqIZvNJAEuP77/EsnHeLBXBlqaW1qHWts6fl0G/dFoZB6FwP2GxuZrjNQrmUisgzrQ14urNfLsImu2mlVbD/SXfj904uQb/X7/r+GlmLCGQjocCv0/E+Oj90jkcfJ95bHN1qN030BtXavdbjcsZOfzucjC/Ny/QXkMsNo4FQprBokdhd4eVqsNQYt/wGid6diIhB/c3FgfB3XQLwqhEfWz0OKHbegFAwXne1Lw8VHd+tl6GI1PVw0XIUdPb/8ttXX1H2QzjJA87Rvra3++uDA3LrV9GbhyG0hNR0oylVwD/dhdQ21xlHKZ6Q15hRt9JevniZFTP++t9P1P6TPSVqnt7c2/lEg0WQUJPRwOh91ms+kqh4iyF9exLSgXvsuUvdx7tf2L72s6Xrq6e1+P66bCWyMWjX47kUiQ2G2eUJYHcUdVgsr1k9+LzlcUI6np5HvhurcK5WPqinFHXIK3iBrpmgL04zr+M35/1XuAAf24Pjw3Nnru46lkMgUcITB/v4bGph5cC3XbiYSN4Dx+HA6z1MjAX94/zFubm+O4b77CiNecy+1qcbs9FfH4QRgOx6Yow5bIYKFmydcLfbqkvvvPWnQ8H7V4WdQ4IuiYwnX8JlzHf59ND03W8WBw+87Z6cnHQN/Sr9ZPL5q2v1LlGPgbLHrx/VrnMHGh8lf8hpNVuUTpnsQVIODy/2Ahsv52u8VGcCAkUhlIpIup4ULxOGwgyJeBrZyz3iyR31V53ZSojzLJS3Z3m8UC06sb8OTkbIkMj7zW2n1bb+58xQWHyWbKmQqeaDZmI/np7Qj4q70VVKEQRxB+fmEZihjbREnqzi8uweuvP0N/43RbaTQl8U7YCIWh0uEEm5zyDyQLtyTay5Z6EuNvKjlWKMEx+cvjsEONpwJ2YjGqYKhyuaXsfybquUDI+dKZDGzj/bxuF1RVVMh3OrwOeX4prKGuIgAWjxMcFi80eRuhqaIe7Dp7B2HlX4rOw0J4GpLZRMnjQJYNFKELwHofFBgX//LnA+ZXpP+I18DS5i48MjFZ/JUUBmE2W1zcKXqxxbYKb6UhbXgmk4lHwqEwcz3TwODw7R5PRVnaMQT7mzPTk59IJhOExEIUZ64A3U6Xq4BglSVoO2yAQsGQ6yoKq51GniMRP5iFI8RMql3nCNa2I7m6t3V0nmlubn2vbG3DNly9OD72o+qaGkPPR0osFpWBv4hlWEtQEW6CzLPKzyu/6rlh6zKGA81cabWfOHnm1xBsvZEdSzhfQttbmx9H0PEUKAFCiRmaqYvCClhX33DCaHuRsr+39+8o8O3AYeYDtWwTijGiIjQYsZyVWTjqGxr6sC0M01DnstkdbBs5NEFLYcHWm4+JVqs7fW+xlK0pKnXJZVWuxb8vXZ/Z80xgHHyoxYMqwAf53YmR02+u9FEQWwIgCED3V1eWP766sjTHXK8M+DucLkPEfrierIO219AVF/AvI70h/1pqW6vNZh8ZOf0bLrf7TfK1pcwZn5S8ImQFieIZESd5EVTp8o8QorpEPB6F8rUHQLnO8s+lxQ/C8tqYawK1jd7Kytcz1yD9vbO4MHcPHO4/Wplk1JS/an0mW/jl9wWNgxarxWpoPpGwhEQiHgOVdVqjTrpFR9lm1NIvBGjDI6d+1ucjyttDIloE/c+PjZ7/Q3ygBIhDIxT9XFdXf8rIc+D1JsPhEJl/PPCXFcQWbMO9g4PYnNdbOah3PZPJTIlVF+Zn17mvWLd9Vglg1BtDNYTuxQI6L8EIwq/hIkWSzBNxR1V19W8QO1CpQwqFGK5NH8S16WlQzm013ijeWw9eTO1/Jcsx8P8xFon8T/5Tdh9j05rJRfR3/i1tt/3TxejycyvR7b5ELlkZzcY70/lcVyqfqohnUy4E7bQ/SV75Ymy9GUGt3VRfXQm9TfXgJnHmCChD0QNY2AzC7PoGtXjL4BQ37szpqp7zr2y6dlZKv+KYC69WWUzUhZyS0clO+xeX1uDQWbW45pHrPH1xFl5z/WnpVyaaESAYjcHCzi7019dRV32inJhe3yx6GOCfPrcbQboHmmurDuPvFY8u40OgqQAjySReM0q9HVxW26GLPiUKzMHkygZViLQEquFUVzv1KOjxD4DTSkC+CypQ7ibWfKvJJgwLEJV4NgaLkTkK+gljf7FarO2+QMMsSoi29A+AMqJfLuL7Et6G9Z19eGFuAbYJz4LFXDozX8jFuj2N/wrimGdhfLnL5fI5nU5Duapj0ch2vshzQCvX3dN3vb+q+ga+siRt3+ry0idC+/sk5EDE4F/meoXCEL8xlq6JqNCczWY1wQCCE7vL5TaUGzkSCc+Avru7UcDPtrFa/VigomUtsWCb3oyAlYB+qmFCgWl7Ynz0m9lsxmx0LJK6R6MRlmhNzc1QcahtgALQr7Wp89p8XYBWgRLZwOCJD9vtdj7n9uLK8uKH1tdWF5k+Kg0LUFraFIIqjmtC6mdYUYIAehfBwQ+hnMxPCxgYKXrx/YojUFtnSOCV+3lra/OrKEvvwiHo55mnRQzgimvo1JvECDnAWBGBdxC8Z1/Z94oQAzCmSBK5q1tsCGJPnDzzXhwHCpdvHFNr2M8f3trcWIdDZYAM/EtzhYRFGbFik3JwcLAJYMgie6UAv6jN1LKG6MXz098S9/ih4ZE77Q7Hy+AQ9MdRsP4YCtbPS7/LSuco2srj8RjyqsE1bNtAu4hc/I1kASHrI3EFfgdrESQF961/jcWihH9Ci+PEiLVfVFdZTtNcW9lzcc82xNdC8shLaXmNuPZfCS813ip75DCtkVNn3obL+S8z/Uj2sGfGLpz/CALwBCjHLYBAPqmqqm5wud1GCFkLu7tB4t4tK2pl4C/LzSBd0xbc3nrGCPAnBQHmmYV5eAjKSSTZdua9AYyQmgLz+qICnFfQc0SxllMPpJOn34F991ZgFEm4NoU31td+D9dyOUuUnqVfBPoviwjzxVyOgf+PuXDM//IiJmsxRRYVxSI06G07hwdhrqXs4FI6G5xYJk8kF6s2mawWr9WdTuSSnrHw4tAjGy+8iQDknTAC160d2NwPw0EyVfQEyBct0vlcLtXhbRx9ReO153x4Lk46Ocd4YSa84jdLLPeBSi9uVnnKhD+zsUnhKGHu7/Y2RTYT+55kLm3ZjcXgyYvTcPNQP2XtJ1imraoKZra3YW0/BM3+KkqkV+lywcLGNuUFKO6uhM0/D91NDXC2p5Na9ItOC+x6DBRct1VVw2wwCFvhCLRWVxXDBoi1P5sFG4J8v8cNO5EtuLi8Bhu7e3DdQA/8dNfJI/dVKpeCrfg6rMWW8XWDISqU/2GBPbanqeTLUPyGKAJMBTHEZ/ThJDQ/nkxTVv+JlVXYixwQH3saskGAeC6fK7is9uduDpz+X9fU9E2C2HVSCDqqa2qJe7yheR4K7W9L1zIRghUEqLcClFWfkGX99draygSop48rc5tGwYyP3JBfTalkUlYE8ACzZAH0+asajVhKidsqPsca6Fv6mUF1WHQ2OFFcrZaFUsFU2z84/Jqamppfl7XaBIxOToz/UzKRIO1WAerx2dwz5tPpVCoB5ULKkWNDDbhhqxH16DGs07FY39DY2tHZ/TFlHl4oZDKZp6cnJ/4wHA7tgTLrADDjAJi/FUJqQ1PzkBErpHy/vb3d76ZSKeLNogX8yyxvGoLDkWNlKyt9tQjAdHOhywUB//mlxXni4ii7+MugX6vebP0MCT1mk9kQOSL2oQ2UwjIvOMt7GWslNTqP1KxEZSC20ufz95Oc8zb7aWDWp2w2O45j6i5C8ME8v3wvxZpEcsAb4VnA9SQfCYfVlGyi9r1SVlq98WW0vcx+RDp9/YN/jOvnCTgE/ZHNjfUPL8zPXgBlyFiZldMoB0Q6nd5RaQP2OXj3bzUSTD6unChNb3E6ndezF0bwvDw7M/Ut0I/7PSphHu85w8psmlZeo2SjiPnjBTkVkvpYMjyeDK7lqhlzQMNLjTzTyVNnf9lTUfFW5vq4jqefHL1w7qPEdYG7t8gwQa/X2NR8BkAsFrEF5/Pe2toqAX6snCGvLzY4nNu27a3N6ZbW9qDdbtc1cuB4bqmurmnCPSEG+uCf9QQwRJD7YgOblxByZNM4SmOqqLw9/Vsul/tVwHoB5vM7q6sr71tZXiQy5jHovwrlGPiDsVR9Mrkfw/Qv55ZWDQPgCAEVPt4ry0uAA1v+G+BwwOZwgyax1YRYLZspkgCSg2Uhla2sdskyj0ch5jW7iWXIWshlrU6wWgvZfCUCx/zS9i5Ozr0iPDVRy3ghlUtnvTZPsMkdOHdbw+lzlVYPvR4UFQpFsy+WpfhmAyXds1ig1uelVvX13TCkM1lqjXaa7ak3tb5sbDG2Wf31xfsHbFY7LG/tQFd9PdRWVVLXfY/dAdUeD2wfxMDjdECl0wX11T643X8CdqIxmN/YQtC7D6lMBhY3g/Tvl/T3wkBbE5AMBnzzOa1WaMC6bCLwD8Zi0OCtpKR6LltR0X7DIJ7b3gwPvDAOkXgSHjw3Du86oz8OMvkMhFJ7sB3fgvXYOn2PvQBW3MdJCATphSI3gVKmPqQsVPj4g6lQZPQnqQCLIRYmGs5Afp1Mp2EfAf7a7h5s7IUgfJCgigXyvVkKiUhmUtkqe8UjJwM937ixdvgF4pYJSgFWsQgT1nvgBCifz5h7PLE87O/vkfED1TWB2ta2jlcJBBhC3nT31OTEg7hoZ/GcNP4mgwddhMlrrsg2WCZo4SXB76+yoFCeJ/H8OK7NuXyOgH4TsfgTRn8QCyf0wI26E4wJC7sohMjuk3oueqWiYfU2KjSpEmqRdhweOfVWBH7vkK5BlG3709OTfxuNRkhdPVBu8Vbvq1w+oSIwGrY8GrDyi6zYWmCDB/3mImt4452Ir1hCRuLf+q2x0XN/hUCBHc9yn/CCIw94bMRbwigxlDQmthYX5u4H9dR9Ig4KLe8ILUuaaqxyQ2PTKaOggGQfQND/ZWKVBX3Qz45xvv1Ub1H6jQl0ATApNrvdDeXKOdHB3gPAmLBoxHJN8n53tbV3kmwQzcyzEibxB8bHzv9JouhqLN+TJQJTtFOFQeZ1XOOiEreBnpv/ZQmZOmFFWvH8mqC/vqGxpaOz+5Os4o0I1gioPrC8tDDJ3EsG/mUWf3ux33VLJp2Wsz6whe979nPW2l+W/YJ5JpL6szZQW/dOUO4Bhb3dnc8nk5R0Ui2zyZE8vjguD7meWhZegCOsu2xB2SbFtQdfRF41espq9rdqClw90K8IEyFMfCOnzv4GF6ZVSKdTDyPo/5gU0y9S2paBfrvD4an0+Q0RskYj4cdQLiB9K3s6CV39oZj9x45j4WlcY1+vd12yBuPvXoLAfwEEymqmzdii59b/Ygf88quWQUDN+GEHbkxVVHgrB4ZOkLSrCiUQ9uM6rku/u762SsK0jkH/VSrHwB8UYF5TAcB+h+9zR7k2CDYKTvguCf0oqLJuRlbmPQv+yWJIJxYBfCgg8hZI63U1fQ+H0hFYjm7dQPj+PFb3boXNtR9w+NevCfQtI6DNSOfJE9TJ1MO8Hg8Gktm0x2K1ASHabq0PUHC6uL1dTPWHqLazomGTCKcdFQ1pu8XeibDWkcMrTK1uQH2Nj16NPAyx+sdSKVje34fBervEem9BAO+j1v+mKj+ML63BbuyAAt8nJ6cRtMfhuv5uCv4P3aCLMLva7aZpAwm3QYXDQZUL8m9o+jyXG97wkrPwrcefoUqKc6sXwefxgMdppyCeuOun82lIZA7gIHsAsXQY4vial4A57TuLqcgJgP/ZpKwzhN9gcnkVGgNVEPB5KQt/iWeg1LXS/kyAfD4Hz16chbGlVao8ITwLJNyBPpNZOotECZD/8N7Yzjmv3bVW4/Q9ekPb8I9aXLWE9ZcAPXnjY4ESyzRMASYunCXhkJDduD0VhtzjSaw+ArIkcQnt6e27XUSUgwLWMxfHR79MMu7hfajrMdEhkQN0AAlJa4mHvGnLDUUbGjd3APX4Q/rq9hizlKLwuS7lkdYj4hIVrThko6BfIXyjzGQbOXXmN1Fo+in52bHtQnOzM3+5v7dLrN1uqc2yUr11C2ErB+VmzNYdBK+0cOuN1vNqgQ1DgEOFxC8TiUQ+Oz56/m7pGfh+ErmQlxEF1dQEWhwOY+ErUBx738lkMkSAVGPDF6XQMiLIqY3ZsjGCxeH3VxlWVoRCoe+jILsI6mkHRYAGQAm2gftMLLgeEipqFofD4YNyRRB7yNk55PvzVr9LAf0lYbynr//m2tr6D+A6x3r+5OPxgy9fOPf853FeZbl7ymtkmSLS5jAGZkmGELiKgJ8UQTz/UdpL5JJN26utvWOoqbn1j9lMB0SwXlleet/a6vI8KMGa/FrmGk/SwRp5jlQqJXtaqK0lBe57LWt/yeKP97f19PS/m0/fl06lHpmbnSau4CKwr7UHGAJpkncms6HTojaXStbhgsH5JBExmTQOuZTeC9Zw9vujKnD11nIzscqePHX2/Q6n83bmPoVUKvkfOOc+iesqC/pFa7dizDY3t5zAftQNLSL7w8b6GnHH5zM0yPuE/Cpf3766svRMbV39rbjp6noGeit9Z3E9+x6O2TgIlNYgBv98v7/owL5cLsP7SC2TUWltCgRqm7p7+j6C87oDlGFa8/NzM+8Lbm8Rwsujsvcfg/4jlGPgb7BcCrmfXuFi/kkRxZ/xaUfkNCmlgwH97CudmK9qvPa70Aj/DsrFjH6P57GbrgOUrpHW6chyFbHgE1BKcszbrTbq8k/4AcjPSHhap6eRTFLismZpc9VtLya3WslFVnd24ZBGsAjGe2trYWp7C2aCQeirrZOIBwGcNju019eCw2aD8wtLsB2O0pRuE6vr9BrX9HdBKXefXEV8afVXwdxOkMb7u6vtXLx+gQLtn77xLHzvqXPwqR/+LT2nt5mEEnTQ76gSoVBQ+IQCFEF8kSOxaAormGQ2/mKaQZK94JuPPkNDCobbWqC9IQC5AusBIF+rQJUYJ7s6YGY9SGL0aTpEKTthKXUgyXfrsbrWmt2BR29qOPlMjc27RuLooZzQS84tK3KjNTPjgC60FRXegN1uN+SmSdxZsa6m3v6BG0Rsu1jHtenJib/CxTlOLP34WzX3fq14SnlMKzYV7GszXlcUMya9mqxOh7PeyHOgQLIO6oBfTVDXc2XTc48sA/xQjKutGDoxcqfd7rhJvge23d7C/OyfBINbJKzCCYyViqTUMvKMhXJBS0tw5F0Y9bT4Wm7raoCjRPyE480xPHLq3S6X+w3MPWjMXjC4/Yez05OPg3gDl+ti4erFs+Tb6hsaDcfJo2BKYr4fAf3YfsUY0REe9Cz+PFEdsbz2WG02o7HSG3Mz098BYyz+/BzjAb8WUKHn5g0Df2c1KMc4D85leYL34FDz5NGaQ6XrkjJ84tQ7KrzetzHjg1w+Gdrf//OJ8dHvcf0o3w9AGd9fag+L2WIoTAT7IsS3F4jXtCOXy4jF1gX9Pb39NyAIuotVkuAaO4dz4X1bmxtyKBQL/HlX/0M+BINtlU6n4yAGByXvSO6e8rOIAH/pmQaHTrzF7nCcZu9VKOTDS0sLf00yCYC6pV+o9L0CwEAT/Et10i9F7x8+VEa0HrNK0bKrMK+Xs3+VKdtcbrcb591HcE2/nrkPIen9xvlzz32a8e7jQ/Xk+ijuRz21amqNkfolExOh0D7Zy3kOIfleLPAndU/i+IuE9veerQnU3qZ3faIcaGltv35udvoHIE5XmOH6pqy8GAHmZZBCyvNYzb2fjqnWto6h5pbWP0D5UeFxhfLl2PTUxAdwPSfggifxM5Kyj5Rj0G+wHAP/n3ARgH9S2E2SFTrIgJfjFbUsL1qumDwhmczky7r6kc+zm4n9ujwU0881V1dRazch1iNp+iw07t+cGKruXC4U3fGtQ1Wdy7Nr663ENZ6A5c3dfaiv9hdBLv5ts1ihK1BL4/Ong9vQgdckKfSKRieABvybXDuRWoQo4SHAM8dXVsHttMNgWzPw8hVJE9haVQWLu3uwFYtCo7cSlPAbhVW8/qvOjsB3n3qe8gjMrG3CcnAHXj4yDDU+b0lZIAU+lnQL1KNBduCXMiXQ35mAKkBuOzUMP3zuHATHo2CdNEN/UyOc6GqldaLKBOn3ZryG3WaD28+Q318AoKEWpC1sUG/3X3TbXZvX1Q49GbBWLEtg/0By6efjelmgAqDuTlfayEn6O1DZtPiyv7cbxEW50+OpaOS/I/VZXlr8dCwWJTGcKavVmibgH5QLMxW8UUArpFMpYQ5VNWsFSScJYoGHjmG73eY0WyyGct0nkokNMJAWSTFIDt/rbXJGwAr9PQof9d09fSSutk++D8k1jaD/oyh4b0rzzsK2oVGBUeJsMGsc7DOogX2jng0i4kKhld/n91f39Q/9gc1mO8m2bZHEb+n319dW5kCsKOIFR5FFkL46HI4Kb2Vlr5F2ItfdCW7fI+WANsJFcSlCg1o7Ktbf2tr6aw1eL7+5ufGVdDpFAKc8//VY/PmxzbsEq1ongUad5OJgoDiKJKGi8W+DciDJhq2wY4ufR6qAn/zeS/yCBwY/aLc7WPBB0NU2ttMf4Hw6x/UjD/xZN/9SO5kMMmkSAjaN9tNy/9Ysl5gmVE/xRrXZQ8Mjr/dXVf02vi15baFgfW5mevIDuM7vQDmnBk+CqFTeGo1ZLy7katlOZPmCNS6wCj2Jq6h0yHH9N1dW+v4bKNfqAgKEz0mWQT1gcCVAv6iPRfHfxfmUpeuNbkEZw8G1lVnwKo8J/r56AM0E6n2hp7Q2+3z+qv7BYbJ/DbFdfHAQ+8cL557/R86rjq0H37+lewVq69px/TbiqUVCOEhoFg/62Rh/HviTMZNcXVl+vKq65kYjXgXVNYGXLS3OP4Jzg6yxDuZecp1lOZsleCytrWQOv5iA5iXyG6nF9NuBW8/7+gdfjnJRKZuRXDKZ9OMTY6N34dgiHDy8lZ+VL48t/VeoHAN/plwNq/4RCn9vUa5QdmMtbQ5YiIu3FhDgz2E3XBZIUsAvfZbdTYUbyK2zhTw019VQMDu/GUTQaqaVaXbWLiDoJy60NI6yz9e67Fi3ns6aCh7iGbC6s4dg3i8BYaA/c9vtCPirYWlvF1b2Q/i+hrr9m0xFC3hnYx2N+59cXS8CcJMZXphfoq71frcbWDd68lLhcEKTzwcbkTD2nwWqXZ7DFpR+6nW54GUjg/DA+Qn6DKlMFv792Rfg2p5uGO5sQeGuQIn5Snx90htq4y/Iq70yjr++qhKG21thfHmNuu1PrKzD6OIKdDbUwnBHK9T6KovkhpLfQ62/El5xchjuPT9KFCYQT8WhN3Di6RF/1wtQBPtEWCACOAv6RQI/a0WTn5L2K2fxt6HQ3A4GS1NLa6fXWxkQfJVH8PTFzY21Sbk+UtiBMF0SA/qPmkNVDXSbbTa70yhBYfzgQMQsrWXll4vI6q3mYqvmjiy52HYONTW3fBznZZ18cZSJV+fnZu5EYXVbOocHtplcLisT9mmCEryuC8RCIltn2e1aFGpk1DIkAv1CC2NLa1tvS2v7R7BurOKIkPg9RQjXwuEQz7rNW9pZ10pecCwJFA2NhNTPmBIok04vLy8tPAHqVnOhR4hO9gO10Ape6VJq40qfr9rldncZqXMiEX9+ZWmRpDbUsvbrKbRYAVUI9oEJcchls4aAitPhaIByt2y5XiwAYOsmsvaLlGi8t5q5ta1jsLml9U5pTJXmBArqowj4yVzaAG3PETMIrP1SMcRrILWN4RSgeuWIFjU90K9QOJK4ohMjp9/pqah4G/t8KFg/PDGOgnUsFgGxkkRutzISRHKYjD6vSejJIY8Ndlzw4IG19JcAA/b9QF19gyJXPCnJZPLeqckJ4sUoiuvXSrt4KYV39Zc/U5tTuUyWhhXpFuwvmiaRDc8D5V4iH7zCQdnq6q79akprNQ4NlhfiE1g/NrwuG4mEPz124dzdUO7Vx96Tn++le+F1zxppF0J6iwCeZJrgQb+Wqz9VHiF4DEYjkfM+v/96vfvYbLZa3LeuXVyYfxCKwN8B6l6MIs+LFwXQvAyCX0PM/TjGrcMjp34B5cufA27dTSWT3x+98MKn0un0AWi794vSFR9b+i+xGNr8jsulFaOKBGbQqmmR+fh+luCPxFsTATHBHXHmOJAO+W9eqOSJrnIH+ZQ7mo17SaUcNivUeL0UwhIiOnkfHKxuv8hcl4DXWLe3ZRYk9/nt/XDpGSlJn5TKz+d0QTsCfpJ6bz0colZw6v5OMgzg767t7QIHsZxLzZHL5+GZi7PEJHoIvwuHQL3K7YFGBP/roRDsxRkZlml9ktrvRFsLlDjREHw/MztPrfA58siy/7QM+umtC4ehCnDovg/FGlD+AUJ4KBMQWixmWAruUu+C7z39PKxsByFXyFESRKLUaKmvhs6GIhYkvAkPbL3w08lChrQ5EchI/uOYdLBKALafeKENoNzNmC7EVivJeOZuMDpWfT5/o4glHYXFh2Znpn4ETKydxWplx6Gaez8/tnkFgJ6bemnzIfHRBknRcrjx73FzCXTuyQtJWrG0LOgRMvcPDp14DQqsn1aC/uzUzPTkexGoLMPhfEtxr2kpDl13zcBrO202uwvEwMByhEMNVMjP6GBe2feKjb1/cPhVCNL+kgP9eQSxXzv3/LPvQ9C/C9rue2rjWdH2xFW0piZgND1HYTu49W3G2q9lNT+qtV/kKSL6jtajqanlrES8qV3hQj6xtLjwzwYI/WSFiajeor9VQT85UqnkHhgodoezSUpDyYN/0TgRjRu1QxHTLQmKP9va1kbGVBPTpgUEfd+8cO75d+NcWgPxmNLq31LbGCVZzOZyMRArUI4MJg2wY/OAWLTuiNYei8PpdJ0+e+2HEPT/AhzKdQUUrL99/tzzH8R1XLamiQ5RqFap/YzGrEshYqL6sv3v5Ppe/lsxBhDwd+Ca8vt86j7iPTQ9NfFpzsVfLdRM0UdXyMVfS0ajr+lUatfIxSwWq9dSTKWp5fVy1HVcbcyozTmFZRYB/6murp7PsqCfePzt7u58GEH/10Bd0cKv34q6oCzi93q9PUbaJRqNPIL9TGQfHvSzB7uPygeVlVZXlx4yypdTW9fwKilbkBPEY7FMyQ3M/FXxYvwvUwRrkpH1SDSu2H2gNI+x3yvOnL3uQwj6fx6UeLOAsto/v/D8M59gQD/f18eg/yqVY4s/U4yw+x/xema8niGmbi7NH1tkLSMf26RYgEBsbVKbxKxlhPxdtlme35ttdVqcFpqOrzZAwTdxf99CME/d4HP55JCvYx7PkInGqNvy2UD/xdG9uZMmu9mUyGTgIJUGp91KzJn0wg6rlcb2E2b/hso8xJJJbKcckJSDtEKmYtz9iY4WeG5usfgZnrgZisD82ib0NDcCIb03MWYI8r7a5ab8AxuRCP3e53ArYv4Jod6Z3g7Yi8VgYz9EPyP12AyF4esPPwW3DA1AS10NJfeTrfy8P53SFFugngKvPHMC7n74yUOeHnwlYRC74Rg8NDYJ5oKJkgDWV/kor0A4dlC6SB4K/kc3zrXf3nQdIVrSsvSzix1vGRVahyp9/nrc0AwRWKkVBKKrU5PjX5RCD0ogxAQmtXjKgs/nBwR6WpZTtY1SDZSTfNsujfMO+zifi2fSlIFbD/CLFJ4iK7+eS3LJ5R6FXvuJk6d+1e32/CworG2ZpyYnxu6S2Pvl++SZ9xa5XVFID5GMGwa8kE1EURMMbu2p1El2UWSFMREvgJpng0ijX2YZsiMSHDoxQp5ZEc9P8EY4FP70+Nj5b4JyE9cTFoVKLPnw+6sanS5XWSiKqKTTqYXlxYUnQQz6+ToYje0v6wfBGCs1Ark+zkEzzkVDbv7hUOg7AkI/PRZ/hVcNI8jxVkKRIpkqk+PxeNBI/XAeBhBg+ggJKFMv1tIu9x2bHUFkARRZOOlvqqqqa7p7+3+Xiysm62syEg79r4nx0XskYki1vgQ4tDyqknoi6NJ1BSZF8sIBUAf5hhQAR3TtN0J6WPKOwDYL9PYNfNRqs5XS9UHRLfsLo+df+AcmLEsUJsLG94uAf04yLOgW7DMfKIEBa6FlvULYsI+y56qtq29F8EnigNlsIDQF4cry4kdi0SjxHhKBBL1861eiiLwwWcMMzqcDQ/OJKANxbWjc3QmGoNxVWqQQ5T1p5M/1vLb0FAv0vOETJ3/a5/eTdLMlJSW2+e7mxvoHmZAakccIwKFXhhAsNjW3nDSZ9NOvkrm9vrb6IJSHZskHb/GXPVVL4B/X0fVYLDqOYFOXTwDXtPq29s6b5udmfgTlRjARczzb97SQUN3/auDzElI/qikkVdMXB2rrmrq6e+/EPbALlPJBNhwOf3Zi7MLXJWJo1srPt78a6L9SfB3/V5Zj4M8UAvrVwD9J36fG5M8CfO581UHJ/k5+TwYxef/4ow+x55Zcu2sCtWaGGZ2+4mZrTqcpJ5jQYkqIkSTiNOpyQ9L70R/jKiy5hgsF4OXYZleRhM4ELTXV9Gpbe+FipfCfOmc1Af1R6XwZ+KfrHf5VkjkgA/lqAuj3Ee801PgpGA4iyPZXVIDLXiTiq3Z7wIPvbZZD44scFkBi+p+fXSpZ3Mkdzi8uQ6Cqkrr8k4wATHQ+Zdb3I/gnPAI70ShNwee2Oyi4h6LTPr32raeG4J7HnoFEOkPPIZfP5vJw34UxaK0NwI2DvbQ+xfR7wNSreKtC6a4mWk/y25efGIIfnR+jChEFuz/egPgobEciEIxEmRFBnP/zRMmQGqrpIrlKCShkSfzU8nTLF1fE9xM3eImosbQoozDYcTlzgRDNoZBFUiWF8fp0QySLNI4h4pKeApVFWQb9WuOdL7j5WhAggzwuoUhUWNqIbAbTSeVz+WQmQz0oRAoxdjOT264AYhBsNA6ZnlNdXRNAsHIXPgebV5wwH39n7MK5v0jhG6ZNZAGb5dQg7enIZrNxnKsx3Ch9oFO8vso2BP5TIBaebSB2vZb/VtvYDbuD1tU3EHfQ38e69gIL0PL53a2tzbtQkHoGxKCfVWTJ9RER+pU9U0NjkyJvu0YpbG9tfUtSWLHzSQtAX24RWtabW1r7sY0CeicT8sy52WmiKGE9fVjB9yiWTHatUAMqJeEqFo1sSYSddtAoZJ0JBOr6VleWQqD0QGLdt9nP5KI21hQM2r39g7cGagLvMZnNVex98/nc8vra2l3LSwvjoPR6E4U+sAz1qpk8bHabLvM3vXcuz7KWHxlIGkiJZZT0UAj6m1vaelrb2v9I6W1DFW9/Oj52/jugP/9ExH6KA9d7Y6EgTkrAypIFs2GEcsYFdqyUkRLXNzR1dnZ1fwifp0Z59UI6uL31xwgKZ0Ed9BvyPLuEoubazyrSmPkU3SBeEka8Snw+fyfKdLNQrjDhlVn8eGZlAVE8v9Y+pph7Hk9FxcDg8G85nM7bmOtSMkicc+/fWF9bgnIwnOfuD6AC+omXUFV1jSFPrWQyMRoK7W+AuocYbwgj95MzXMmx+sn11ZUH+gaGRiR5QrPU1ta9em1t5blUMqlFECma+//lwP8RUz8eBfSzIVtmlA3O4n79e3wmDuLNhuP9j6anLj4A5YCfn8/sWDsG/VewHAN/rmhY/PMa5+QNnG/onvJ7gfW/gAIkq+kkxYSgX8TwLv9N2NJlXgCC+ZmNl8RMF/gNUjrfZA6nYy0ExBJLObGEk18QN38LJb0zFZoc1RegKKQq8qnike32Nj8/GVu+nZw0u74JTYEqepP92AEC7jS01daCzVo0yjisNmAI8Q9T8pFQgtYmmFhZkypGYvNJarx5uO3MEAX+bDFJe4HLZoMmvx+y+TyDEJTvzvZ0wmMT04eWfROpvBnWd/eo9f9ERzOc6e4sdrhcuZICobw011VDY40ftvYjlLm/29s6sxXf8UYz8apUJmu326yU3Z90RSafIZwGsUpbxfiwv/3uJkcNAW98ui5emGGrX6bpx8W0jHClwus1lP5OpRRC+3vf3drcIKEcSSmmnwIoyXrEhx0IyfzUxjhw4A3BemkMFwqFAv8bBP4eMFAIaJZOV9Nes3GIPBAWxbCJBCYF6O/s6jlT39D4YexflrQoG4tF/wZB/5exvWQhjr2fvO7K9ZEtFo50KrVpBPhXVFC3yQeg3PVORHLGkoWqAQ61Zy1TdPQPDN1eXRN4N85VRb8gQJhcXJj/EI4bmXSLt7KrkbCxChihoEG8Pip9/kEj4wDbcG5lefEZUCrS1Cznl2rtl9sTQAD45eetCdS9DPSVFXkENV+U0qGJrP2quch16qwHVOhak0wmIzgHgw6Ho1nvgatrak4j8D8P6tZ+HhgAKIXJMg4PQgrZ3dP/6wgcy9oqnU6ReO5PRSMRniOCJXwSpTNkY6N5gd1ks9kNZVjANcUYQztXOBdgoScT6AvY/Kv8PW23vv7Bl9UEaj/IzkNc/0I7we0/mJmefALKQZMofabcT2UKIfnAsREx8sxOp4uEZThAqfyR5zTPwcCvP4TT4URzS+vv4lrKZ6LJ7e/tfWZ2ZuoxUAeEaoSXV9IVWDWun2mvDAk3I6SQuI5X6V3QW1k5QIYLHJLL8e0HcKg44RWmRj23hHsXObe9o3OkobH5/RaLhedmeXJqcvyuSDi8B8r5xq/fIu9DRdx3XV1Dp91u5xQ54vbdCQblsEI1Rnd+3LLKc0rwR153d3cW4/GDSY+nYkjvphar1d/V3fu6i+Oj/wrqc4VXEMvvFeCflP+MgFQH8BvlGNGz8tOU0oPDI2/y+/2/WMQYhwVloeD6+uqdy4sLoyAG/KK258PajkH/FSjHwP8/aeFcN+l7FPZhCzZYja/S+7x8IWbZSFniFcTzeZGli56fhZwzmo37bRY71FZ6qYs6UQBs7u9THJzOJnNn64eIpZoIqXIslbwAZ17edObJycnFG3MF8BCCv+1QGAK+SvC6nJQcMHKQgK6mekq6R8j7WM/mggSuyTGAwH9saYWCZvI5YfnfCofg/NwSXN/fXUq5J51YahFyTaeNV7ZL3AD4b3tDLcxubFKgTk4nZHsnm/vhwvoUZE15GFtchfmNbbi2txs6m2ppKAJtxELhsMGZ1idtc8uJAfjGw0/RD3wW19JP9/7UE1i3VBah7NjunLdQyGb8dl+00VsbdJntm/kikzYL+EUxiyJ3aOD+LlugrQiSUAgzmue8rKTT6aWZ6al7GBd/3moqiqU8Kplfabyh0GGSvFLkzxTf220Gc27naVygWtw+G+KixZGgBYJLQipJzD40fPJtFd6K/8FucCRt3d7uzkcRrDwM5THZ8v14sCQLSSkUVubdHk+/3rO6XO4+bDcntlsSlPF2vMAocqvnLURqQJ99ZpPXW+nv7R98NwK0W7l+KiBovRcFp09i/aNwqBiSX/kxw9eF7QcRa7AVhdMBfF4jCqDC9vbmt1hlFSgVVVqpJo0WXgDkLep0/rrdHqvDYddVViSTiUcXF+YehaIiVYt7RbfeXMiYat2Ai5XFfpsyAvxRkO5HoN4UDoWWQQkA5D5jQYtWeImJsNLieLq9urr6V0wmCvZY1/5ENBL+6/GxC99gXPvVgABbDzYkTkVYNyHwt3oNdXQhbyS+XbF2MVl62PHNh+IZJQ/lY4yJEx/hQHg7ygPvAIb4Lp/PLa2uLL8fj1mN9uL7Rq4Pb+kvnZNIJDaNtJXD6Wy0OxyV6VSKd+uXx4VIGSR5ewy8PBCoeyfumXwIRj4SDv3NxYkx4r3Agn49vo6r4eIvv8pHGeiX64Zzegn7Rxf44zreQ8JnUsmkDPpFZJkZOAyhYeU/0VquBv7Z35hQPnD1Dw69A+fzG0GJAwrY318dPf/CZ7PZTJJ5LtFexhOaloVnkaOuvuEaIw2czWa31laXzwn6l1c6ACjlWZmJX47zp3vh+trqj3pwYBmx+vv9VTfXBGqf3d0JTkH52qK27sprAzuuC/+Z2P4NAn4913410M8qJEn6x4rBoRO/iWPrFlDKB0SBOjM/N/Oh4PbWCtO/onh+kRLvGPRf4XIM/H9C5RKI/2Bjc1tk2eCBEvtqhnLAwQtDig2YHE9tj3bZLDYLcXdvqqmmrvDE0L+5F6YgvNrpna+0uEgcm+zyLW9EFPjbTbZsT2XrQzPR1TsIMH9sfBruuP40jYmP4/62FtyHDbzWTcO9FPwT4F0wybD80BjrcTmgodoH26Eo/a7L15qY2V9wTq6smwib/1BHs2SQlwA5/pPKZqgywI5Y7NB7QL52sRTj/Tvh3mdHqWcAyVqQSKR2P3DjL+18a/Re81R4sSOZztoeGZ+E52cWKFM/STVY5fWA02GjVyxyEVAtJr0+UWoQJcl2NArP709de1PDyfttBXPYUoDEqaruBZDJugqQzBetSKK84mqM5yJvDlXg7/f5GywG09/xhQjZK8uL/x9u+hFQKiUMpUG7lEU5RwaGRrHaDLrlFq3rahsXa4ESjX8tS4nCNRkFhLqu7t4P2my2a5g+Ic8xvbK89KH1tZV5po1ErpG8m7tsrUjt7AQv4OVfAzrEqwQENzY1D6OQTyzbWgKjWjy9loWozBUbBaibsF7vKXfBhUw0Gvn82IVz/5uEh0C5VVZkZZcLG3ahAYZM1ppA4IyRMYCgYxb74DnQnltXytqvBQLSRPFXXJXUCwq7czPTk58hxKhQXBPY8ARN0K9RZ5Grv8g6WSLI2tvdeaGqqvo20Bl3xN2/s7PndefPPfdPhSJTKuu5YQXxmCudLteruaW1p6m59VdxDg1DuZA4u7a68tHVlaUpEI8lNZ4GUXhDGQgk24LRzBD5fCHPfcRzObBrMh97zf7eKOO6Jq8GgsnKgcHh9yPAfilbD1yvn52ZnrqTpGXVaDPRHARQAfzyNcLh/aVCoV3XdZ2QjtbXNw7i/vEcKMEh6wmiGBPY//bB4ZG34XO9CsrHXj4SCX9hbPT8V0Hbe0dVKXa5IIFJt8wq01gwyIL+EkFZJBwex2c6rXd9El7T3Nx6FkGR7PrMr+EihRow36uFi6iG1BA37PqGxvfgHsIp+grJUCj0FxNjF+4B5RjKCu6vZukvI/Wr8FYYIvWLhEMPSnwSolTBfOYOdnyxZNclqz+CzBncI8ewH3TDDAjfQkdn11tC+3ufkbxkWYuzXjgYK1vT8pO0/gu8jeTXo1j5eSUOD/4VPEcNjU2d7R2dH7BYrK3ArefpdOrhyYnxT8RiUTlETI+Q1bAn6XG5tHIM/A2Wy3Xh58ulEAk2NtSVWR8Y6wIpIquHDP5FGnDhIrAa3xuUL9NSW03frWzvFEn98P+Ao5pY+2XgKhOukELGExVYX9N0w30LF795NmeBhng6Dfe9MAZ9zQ2wfxCnIH83FqMKgZefHgaHzQ5mqcYm5hFIYMKZrk7492fPUaAdS8bSfd62yMzBav0zM3P0Z0MdLZRVv2iNN9EQgqXNIE3/Z7NawWq2clKaiZIA1lRUQFtdABY2t+nno9tT/lPe9qdf03j97g2B4ece3Hx+ZPlguyeezTgurq7D9MYm5Sko4L0y2SyuTHlab7fDDg68JwqSEIzGigoGs8X34Mazba9qvP4Rpp14674RBlO+r9j3qhpan7+q5ahjVS7RSOQh2cUf9HOIXynwBNyr4r3VajXk6g+HyideAOEtUHrxx0LAT65P3WtrAu8zKWPXaDw/bm5/cXAQi4K+ldvKvS+REyEAW0LwuoaCvW6oRm1t/c0I/InbNRF2nKBUbvCWNj3gLxQU/VXVga7u3nc5nU4F0KAPnc/vbm9vfXRudvopEG/kamAbQH88l/rA5/MFUIBsNzKesD5sbL8WOd6VsAiqufhTBRRx+UWh5wmHw/lq0bnYz09MT08SN3ZZiSoK+bnUuaYWk8zWscSKvb21OdPW1rFps9ub9B6aeKT09g++anrq4g8O06QohH9ecVlq60CgtqGtvfOtTpfrZVAuf+QTicTdkxOjn8PXGIjBq8jjSC7yXiZSkJfaxULSrxjjigAosbsYOtiwFYBywK9nVdPk1Whqbulsbev4KNafnQuEuf8eBMd/jmvQgaDN1FzhgasnD/5LQDYWjQYzmcy23W7XJdasq69/ydrq8rjEJcR6g5TNPxwLTZ3dvUT5w5F/0ZINh/Y/Nz524WvAAGpQDx8qc/O/wiBBzYNGmG1pY2PtHIKhNyGw1/VWqwkEbllcnH8qn8uJXPz5OaXmNSEaW+znpuqaQB2C/l8WreXYXZubG2sfXlyYPw/q3lp5Qd3UrP3UzV8i9dPFGcRDa3V1+SEQK3ZYkj12XpuYOsqec0nm/valxYXvDg2fGMA62PXqgOt0W09v/+umJifuAQ3wybS96L1CfvlxWv9VwovY92qA34gSUgT46RjrHxh6FY6td/EZOKBIMPrlsQvnviB5Jmq59uum4jwG/VeuHAN/g+VKM/5DueXxkurATwZOEQCgvmjxwjZ9j4DGup+J9BB5x2G303R1xOK/iMCfmErS2Ux+2NdJcs/LgiqZyGycP7X6WE2mzC1Np798//qzv2O2WKyh2AE8M71QdOU3FdPbkZj/e5+9ALdfM0KJ+GQ3/1LKPnwlsfMVLiccEE+B+Lb3XX1vvLAyt+1OWjLeZxH870SicMtwvySe5ambP3HTf3JyDjoaa4upAa02RXPQrIL43zV9nbC5tw/xdBaBu9Xyb8uPn3pX3099y2fzpN/Y+tKVg3zC8eDGuTPLB1snEul0ldVsKbL+S82XTGcgmUqXfP9ppoFiRUx7qRgh9IqAUpjXSlmiWPhQMIZkIsFusmrAjWVHpoenokLXZVdUcHHen5ub/gaIQb8ec/JRipalsuwgpJRGLiqlGlPEF8Jh3LvcjnrEY3J7KuZFhdfr7esfeg8KTQprPLHUhsOhP784Pvo9Adu4GoM9269pps5UaNnZCT6AAtM7QAecuNzu/kBtXcdOcHsGlGBLHiNqFn+R5VHxvFar1dbXP3iHz1/1dmxX3uOCxIA+Mz8380e7O8FNEIN+kXsxa8lSdB2IxzUVLBubms8YcddEkE1i+58F4+n7jgQQGOsfgBIA8CAgLfczguM/w3bM2+2O24gbcyGf38O2G90P7X1nfnbmKclLgk/xyIfUXCoJoZqrvyyAyQonwuNh293duQ/BytvBAChG0HabzWpzzUxf/DeGXJYdc4q0g9iHnQ2NzW9wuZy3AJSnNiTAA8fxp6Q4bjXwqpayTS68klvkns3QiOgX4uEA5W76IuEZgOPfUfmtmmcRL1QrQD8K169A4fp3lbwahUw0Gv0sCtZf1QmHULP2y3WVeYCEbuuE1DUWi45WV9foAn8ETw1dPb03z05PPQRKb7VSnDquofau7r7bfX7/6/B5yjwvCAjc2935MwRgPwRB2lPQ34uuJkAwpEhLJZP7kXD4CX9V1Sv1Lmiz2Wu7unpuwbF/H4iBv8jVXe4/VVlO/tzt9ni6e/v+W0WF942C9iZr+dOz05N/uL+/twPqllg9pW2Zmz9Z76qqq3WZ9UmJxw+ej0WjOyCWjVjLO6tozHH3T/N1CIf2V/f29h6sqQm82kg9cI69AtfA2c2N9VHQVhLzSjP5tWwssjL5lQavOtZ99r1IAWlECanqgeTxeLx9A8O/5nK5+NA/SuK3v7f7F5MXx3/A9elR0vUdg/6rVI6BP1cIuBZ9rme9V/tO47zCJdzLhOdo3oeL8TThom/K5rImFDhNuMCbzBaaVJ4y+jOkcKUFYCuxXxNJxbwOqwM66mop6CenLAd36SWdFvtOb2XzgpSGgwX+BSZTAJ3Yp/3dzx9kYp9/cvviuxH7m2WBq7++PT21MZ9DqcoVTSbhW48/Ay8dGoDOxjoaDlBk3SvCf3L/ppoqmFnfJMHr5ud3L3rf2ff6H35t9kc37uTCTUvbO7C+twfX9XZDX2sjRBIJ6spPzl3YCMLq9i6c7emA/tYWKHptFj2tTdj0JAPAdf3d8NCFScriH83Gmx7butB8U90IUWxkPGZX7vXNNy6bzYV7nglO906Glk9Esgcd8UyyNgNZm8PsIF4QRScF4qGQB+rNkMul965p7v0eFIG/WloauuhZrNZcLpuli5/d4SAgN4+APy+BftZ1FYDb6InrpdTeFonZn8R/2lGwqoOjlwIK3t9OxOO7Ur+mCJs/HrSu+JorHuZ8JpPWXJgNjuvSexR8TMTYUWzGAvt9gboTF0o8EpoFx5icR1oU865GMqUGOEvCU3dP33W1dfWEdKqB6RPipn1hdWXpo+trqwugFJjVLFEA5UocedMtCSvLSwuP19bWvdJmt+spcExt7R1vRPD911LeYp5h3QpigKSm9aef4/O+JFBb+0sitz1iYESw8YWJsQv/RyI+EwE0kXsm746tBpAU74kCotLn13WZJdcObm/z1v4rrbBS3A+gDPzLGSXkkifW/OeeeerDJPUhrqNWBMkZxpVUFG+vyyqtJwQJ3JP1gAqZ79alxfmHUPB9md1uN+JdYULg9pIzZ68bDIVDj+0Gty8gcFgpPhrl7bAGausa8XrDCDhulKy6IuVNDte6b89MT/5tNEoJ/PhxJLLs8u3CWvpF4F9x5HJ5NjxN7zFF80R0sO0tvzfiSisC/iXA70AkPTR88tdcbvfPsPXFcb6P6/VdEokfO4a02oxVvgGUgxf5UFivyfjY2lh/oqqq+hWSIkSz1NU1vJQox+fnZh7C8UD7CM8jWYma6xsar/F6K2/CtbRC1P75fH5nc2Pt44sL88+BGPBrAYarDRS0FGn8fLItLsz9+0nfmZeYzRbdULXaurpXh/b35nZ2gnPMGCoZUqCcz4Ltw7J1E4qyn6ezu+eOyspKBPxmEWFs9iAW+9LY6Ll/lNZy3tIv8kBkuYY0Y/tx/rfjuqeb0QSK5KYyqZ9a2KMaCGet/mysf6ke87PT/4FjbsSIxwoZ323tnb8Qi0U/G4tG10C8V/B7Vob5Wwj+5fMvVwnAAX25LvzrUdz6tbL5qCkjKRFnU3PLb+E6r5CJSMGxtLS2uvyHqyvLU0x/isIAeW8OoQLvGPRf+XIM/OEwHZ+WVZ/9DflbTv0nv1c7B5gFgwVER/UekOqWN/JbBvwTTapi0cpLghmoaInH9mbbXDYnPZfknydlYzdEGemJ0a3GXnFBAv28VU22pMiaV/r5zbWnHvDYK8KPbJ77lWyhUGcqFEwH6QP4pYHXf+kHS0/eshbfHTFbzKaHLkzAwlYQbj1Z5MI6tPoDNPp9MLNW5Be6GFpqu63+7BPv6H3tPT9cf/r0aHjhWlwybI+NT1Gm/ppKL0TjiVJbZFDuINb/52YWqWIh4PVCwO8Ff4Wbxue31tVAtdcDe7ED6q4/EV46jcCfjbfL5fOm3DU1/UE8iDWKgHPTTibiOx+cadlNhRtS+TRubmany2bftBesmyM1vU+2u2tXQQPwy9dG0F9a9NKplGJjQ4HZFItF5UcpLeJ4fwvWXWbzpwtyUQFgsuFm70esZNQ1/nB8pdPLCwtzxEpTIvQj/czFbdNNGAVA0nYFKXWfHoO/Ygw//uhDJYUUjk1AYAeZTJrX9paEUNyIC1mD6aQIGz5uRG5JiJHZkVkLAc9ELrdrGfglrygsVPb2D/yq0+l6HShASyF9cHDwxYnx0S9l0mmeAEnNysaG34iAf1LuS2xb69rqyr92dHX/DojBUqlg3bp6+wZeOT118T+4+8jzWgt4swKjqb2j62Rdff3bbDY7mw+89NDZbHZifW3lT6UNXQQ2RLF6PJmYrJjgi8haAQ2Nzb1GshzgGFpYXlokIQe8d83VBAgyAGCtPgrgL31uSePkZp5bmAZMpf0uJzRBzzVZFpSpVRvnjXl5ceGL3b29H8K13mXg+iYL9k1NTeAOPF5HrM44dslcJWtkBYmbBQ1wjeNpbGtz4zNLi/OjIFYeicCryAOCHfMFAwfxRCepSXXj/HGpd4BYUGbnF5sphLdyGwH9Qit/fX1jS3tn14dx/A+w7Yj9NIVj/UMb66uLoJyH/BjSYyZn55yI/LEUM72/v7eciMfHEEsaUcKZa+vqb62uCVyD436DgH5cU+pwbfZqjodMZmJ+fvbjO8HtFSj3kBMpxURg4YoDBQ1PH34+sYDTivtbcGtz8xuNTc2/qPXctANMZnt3b/8784XCF0i4l9yOoFTg8s/L9yF9T1z6W1raXuep8Lwar+sR3ZuAs62tjU8szs/JZHpGyDPlOsn3ExGxlgB3fX3DWSPti2v3ysb62gQYV+4AKLNRyN4kaRAA2UwmY8E15l96evvfK61JmoXsN339Q/9j9MILf4v7O9/WakA6w7zX8kQpKQcFmbv0ipp1n6+bSJmuBfhZxY2m9xFRYA8MDr+1wut9IzDEonJJpVL3T02O/3ksGt2DcoW2VojOMej/MZZj4A+H6fi0wLjoN0cF75cTKnAFwgyMaP0su9lYe55ar4tu9mT+zW1sSu75+UJ7RSOxhvPuqWycv+y+LE/01Glf9xMj1T1jX5u99+eXohuvjcZiF/31npmf63jFIgL3gQfWn/vZvMVcuRLchbsffgJeNjIIzTU1kM3l6OxvwHqQJAQmixlimVTV7MGqq8fTsvrqpuvvvb52+Invrj7yqo1EaNiKPyDhA0BDBkxQYXNHI8moh/j/Z/Ba06sbMAMb9LrEi6GmsgJaAzVQ7/fBLonPNxG0m64yWc3pQjYfBjHRXoGA3mpLxe7LG87MgroAr7bY8alK2EVPQVyDoF+2YCnAGt7fJOo77B+Lz1/VBDpChqDkNzfWvpHP5WKgTeZH62u2WAAFQVpnfmHWUp6Rz3mFFAr/xE1BJvgrA/8ETCBm2jPyEIQLwOOpqI5EwnEQpxuTY961NPhETiWpsm6tqq75dQQHAVAK3TNbm+t/tLgwPwbqoE1NMJXvwQpRLCFhaYNdX189X1VTc7/P53+lTn+aArV1b8jmsrH52ZmH4RCIiki1ytwViYtIR1fPDdXVNT9js9kGRPfCPjjAjfwfLk6Mfg37i1V0GHHFFoENIyCWjodAbe0NoD+eC7s7wW/h+OdZ8a+mtV9RT8H3BTgcCzIwNHHniJjURaRSlyMIibwSeEG1pPjd3t6cdLldf9/U3PpuI0IyU8i8sROPI70f4vq1Ggrt/8P05MQPCQCH8jHEe4xoZhHh2lUI9JVtUCBOF3FjwJ+SAIo4MGQwxqbmFHkSqZ2rmVu9f2DolQjgfhvblM0+QHghvn9xYuxTEpeImrJErc1E454dq6JQEDlm2ra6unxPb9/AsNFxgWOhwuVy9xr4aR73g29dHB/9OwQOclYQrbC4q0bmZ6Cwyr4yXg+pvUp9vTA/+6C3srKPeL0YaK9K3Hd+c3tr857FhbnHpH2eX8eF2SqcWFpa26/B/f82h8NxGpRyA/vT1MHBwf+Zujj+pWSyxAnBW/n1wtT48V1m7bc7HISHss9Ie4b29++TjElaKRr5Mcx7q2RBQ8EW3N6a9vurflBbV/9TRjoZm7N9aGjkHWOj574keTHJ91LzlpOVD3I9tAAtr7Dkxxd7P75cDuA/itdR2bqE42uoqbnlPShnlXkCkv6LRsKfnxgf/Zq0pqsR+GnF85fk32PAf3XLMfC/iuVrd999VAB2JYsRYg/eemGOpg4aCGj2Oh3gwYO4zS9uBemFcrls5oa6YaKZVaSCgkNBjXWpVsSRWnKF1Fs7b/9CwWz5qimfw8sWqDv2iK/z2RZP7cK3lx5+814qPJJC4Pgfz12glvlTXe3Q3VgP6UwGHA4bZLJ5Qt5nenZ7sruns+UCnp/32zy7b+987d8/vTc59Exw4k3JXLrOYrZAb11H+DV11/51JBlzPrp5/pq56Pr1BShUgMlMwA4F+XuROOyEYuSjUlNZLdbK1fRuV7O56iFQgke1BZwX4I2CQdV4JhBvCLoxowSweioqdN3Z+JJMJqbWVleIQkeO7RdZWEp1Jdb6XQgKr3UJCqqC5A5aZu2X751IxA2lk4KipWkQgT9hbJTd/GUhTR6TWkAYcHPra2xqepfNZj+t7INCJhFPfOXixbHPJxOJBIgVOnrWWhb4yy6KfF+WPA9QOPuXU2euaXM4nHoClLmhoemtFR5v+/zczDdjseiu9Lk8VsqE5Kamls5Abd0tbo/nNompX7RWkTR99y0vzv+/weD2Gmi7YeuNb4ByoUU0VkpzqtLnq0TgoJsOL5vNriwtLpB0eCLQr6aEuSSQwHpTcfUVPQMfb8sDf3bM84pAXhg6Un11+Aj4ccd6YBSwLR8hcdYE/OPYMJT2zkhBgXAN5+ZXZqcnv5dOp+OgDfiPsl4ClI8pFdBfPHAvO7DZbNV6dTZbqHJAjzBU5Mkj4mHRyxpi9ngqPP2DQyQl1muZZ6Jx7yhYf4ZLb6gVXiNSKmvNN9bdn7Vgl+q5E9yerqtruNdfVXXHlRoTuPYTboe/mpudJt50adC28mtZ+n8cYIEdW0JCT6nNFISwF8dHv3Ty9NlqXMd107QSZVRDY9NbagKBlyIgfgzX3Qvh0P6m5N1XIrhzOJ32mppAc6XP3+PxeEbsdscJKRWimsxZIOzqqyvLn9vcWF8E5bhRI8/kOSFYZYIoPrwE/Bsbm4bwWRygU3BNiK0sLz4K6l4dbD/zY5j3tuIV6QplOo6x/8D9rh3nmC7LPykoSw0PnTj5tvHR819hlDBahjNZmcq6sKutW+xYEo0xALEMyL+qyfciHh89r6Oy1KHkwDar6O0beDu+vAYEVn6cw/MoP/7x6srSJIgBvx5Hi8J76xj0X/1yDPwvs1wF0r/LroPB3J2sUFp8bwZHKBNrIbHv9dV+BNo5OEilIZXOUAu51+GZtICZxK2zE5oF/iKGZxswqVZMxVzrLPGarcpaEXtn9x2ffSZ48cTzodk7wtlo397Bgen+C+Nw/4UxAsaJv33R8R+fci8TbcdNLoSbYckSf331wGPX1w4/OR1abI5nkhUDVZ1bliyE8drmn2q5eRp/9I0Htp4/vXIQHN5LhkayhbzXarYQt3laYWryyGXxgubnG8yVxNVfZpXm4yPZRZtduFjhnT0vm3XlwJqwGFEiqI0jPdBfOlwu11Hj+/Mb62tCJnRsG2z2PO/ul8eN+nIFLcUzW6zYv9msSJiigkgkHF4lMexG4kurawLXEYI3EkvNjUm57fi4d3o0t7R1o8D18w6H4ybgNjfc2Ca3Ntf/RLLys4Ieu5kZSUfDgj/WNVwkVJgI9QMKjZ8ePnHq9212e6fOo5sqvN6bR06duTaRiJ87iMXG4vGDtUwmE7PgOLc7HV63y93gdLl6UAA9oQH2af8QN+zg9ubnFubnXgAxQNNTdoieXQ14CL09WlraXmLAulgI7e99K1f0VuFZ8YUeO6A+z45S+Gvkue9kQZ0H/ewzlwFSKBd06e+vQEgCu07JSid2/LG/zS0vLT4RjURWOrp6fgnXlLOgPlZ0741j6WIkHPo6Ct734XiU2Z31lEdq44n1iuItkSLQL1Io5rAeIQTXrXqVtxZ5Q0R5rHkSNi3gbyRjiLm9o3O4obH5TovF0sLWAcf2HK7RH1leWrgI4jnIgjUtwAEgbjN2bGRBbBig43h66uLXTp0+24HAc+gSx0OxErjfHBzEvjk7PfmVeDxOvOuMWPl/YqCfU/jxbcZ70CiUfTjWYHz0wmeGR079Hu4vRjwgSGhEU21d/Zvx+O+4BycI8S5RPpNIP4vZ7DVbLD5QAnHVpsb7Pxfc3vr7xYU5mbFfzVtLxAnBu/gDlI/vMg+WqqqaE0baNRaLPp5MJuX+17L286E9cmHBv0iRXgK+JDxy8uL4/x45eeZ37Qayl5Di9VaePTFy2jI+fuErKKMY9eSRlQ9HWcO0xu/lxPEbDTMqW5sIh1RPb//LagK1v4jyQrVgrBVQ1vj25MQYycIieyDpsfYfk/j9JyjHwJ8plwLitX7/lje/ufD2t179euvUWWthUCgAZiKrjSYT2EisPslJTy4aDEVQ+LEQKjmos/sJ4Y5WbC8PsmQtaFn8l+jv62oHn8DjmdHQQs8zOxOvCyZD19itdlIfkxkkDj2sR77IAEdygipd0XI56PO27gqemRj4Ta+oP3svvr+XpHO6GFpuXThYb9mJh5qy+ZwFN9p0k6v6yduaz5yDDAXBmgRb0nOqWZTYBS7nzDoL/397Xx7kVnLe13i4BjPA3PcMOQev4VDcQ9KakdayVLJja+1EluNySnElf8h2lcslu1w5/M9aVaYqa+ZStlKW5USyE6mikg/tSvJK8rE61lqvspJWy2NJLsk5OZz7BgbADO6HdL9Bg/0a3f0aGGCIIb9f1ePDgMDDe318/f2+q7Mo41SBWNSHrFIuMtzYBLvH4/H7fP4OVAawwL6Flcq3kd1baglvvFDKKotLx1uZc8i6VqHOAeuNtBU9w8rBBiYPEa/X61goCH+mdWz8HR+5dfM6CUtnC97RNqTKgenz+91DQyNPtba1P4O/dx5xuedEOd3b3f387Vs3v5hOpxLIrmTzHjZR9WGnSA5ZYbti22Cl2Lxx49pz4+fOEy8gF4UgGDAul7+xsekCObh+0iFu+VwuOxkJhz+PFfxXC55FGdl3yr1WPbvM6FU0+GBFIxMMhS443TC+36W5u7NkXhdrU6BSBbKquf1cAVUWPGm31VBg25k7eM9HVZQhzuvPymZK/hEqva/iHAyHt2fDl9/4w/6BwbPdPX3PEAMAHl+O25Oh/Siee8lk4odbmxvfXlpcmCzUCpEVwNQxIDmFq8vaNs9cr0iOM+m0VvqQ1+drQ/YtynyotHYInz4k8/jzhMH6DCYh/rPj5/91U7DpV/FXWZ3MxG34lYnbt/6I2ybUKSVCt81czOf40HVRhXiUzWZMLA//+/g7zv8evu0xnTa0/WieiLTdlxfm7/3l9tbmChKTfVlo/4Py9FsQRNGIPM4iQx/pR/Pm9av/efwdj308EGh8Eukb0rAoNJrIUebtmul0+vXNjfUvYcJ/DZXOPRXh5w2lrKwTGbVsJBLLiVCgsfG4xj3msO5BZLcowkOmc/Bn2gci8l+ypWEqmXRNTd7+3NjZd/xb977xxBF4HXr8sceeDBA9APfjFhKTfbqVNa2bIipw6xTlKYOM+Mt2GXHy8vP3XWKI7B84dmpgcPBjWC8+iwRjFeuG63hsfWp6auL7SFycVhbaL3KiAek/ZADx10SFRgGznM/XAC6kbx10zewsD7ldblcO8+re9v1tyjciO9ans7ls/lhTDwnl4Sc0v0DLcsBUBY3YECPP+daRK/i4lkCZ0D/OXxndykZ79tJ7IROz/3g2MfZEx/jnsQJBiL9TwaKSAmbkP3KWgWBgEx+X0X1Fd5/MZfJaYYWF35Ap77Yjm8mIFDHEvS4KPknlVlEYl80AgIlhCJN/naJcFOba6vI3UemWg6ocO9u9HgCysMmSquMkzDWZ2Jvyelt0KgSToohnH3/y3b8+Pzf7tY2NdVqHwWrrUKi5pbun90xzS8s7GxoaMJERVpfOZzLp1xYX5v8HVkzmUOlY1yUrMuLLFiYSzU3EfJdUPc9evfzj/0S212vv6PiVQsEmHegqlzlMhH4YjoS/MjM18QOO8LP9oROGLVPU+HsSeRvp9dNYKWswDCfFLJ9dX1v743Q6RTxGh5HbX4SE/LNKMr97A0J2BVpkQOTbpVrKkOh3ZP3BGt8IyU0tLy1ewcd1TPQCPb29p4PB5lFMVnutYm0ul5v0A1YEo1jOrSeTybuY7N+JRMIb3DiSpcXwY0k1j0raRZB2wXv7S0g/OfB9rus0nN/fQFKnKOknoct8Whsl9Xy7qnYKKe5/fnxo5Gxf/8C/x215gukLolivYWJ8aXLi9mtIvt7qyp+SsSQYuyyJZYullcgjTNyzb127cnFsbPxXg6HmDxW2UVWOv0wmM7Ubj30XE/5vx2LRLST2Djp5+espF1gURUOru/Ow7j2VSmXfunr5v50+M/7P29rbf0mw7/nBbyqfj+L14lurq8tflaxdqjnIEzMReF2kxPPd3ds3phOdh+fg21hWkEKGbCFWVQ64TH7ztTVkee7W3zuRyPzs9NRnT5w6/duGYegYMsnWuafPP/7E70xPTX4xvL01h0qJP90alZJ+UfSCyignM8zx7V6ul19G+nkPv/X99o7OvqHhkY8GAo0/iQRh/eS+sDL299OTE38Uje6EkZ3089EkqgKjQPofIID4M7BV6sfHsxcvui5evEj+pNZwIeh38CddF6lyd9F6Iy8zFjz7iT8wLj33SfPZbN64yBFXlcGg8FvFRbtwz4bgO9Y9JVNpdzDY5MJKmfU9WhEeCUjxRipshRP7PW7UFsLcAv/U1PLa/n+b+eRTXWfvFUK/RQtHkfhj8mmFKZMt/PadPzla4MomjOgWdNzfdJs6vCp6oz93/ALdUsVUHDJyIfKkivJsRQW2eA8uLULHKuj0nC88N8k3zmGhSbanI9sgkG2M8o2Bxnw4vJ1DYqXfEnrsjg/Hjg+7FubnRM9Ci89ZWzGSvrTaz0Ru/G03JrM9SJ/skc2Gp7ByQMLXhaQfP4+Z3ffG2wT1e3/y/Y7XloxJ0VZj+YZAwJVJZ/AD7c8VPMZyJNI9nzczhUIxSbzIXMec3bFAEoXf7x88debsx4dGTqxgEr+E28qDycoA2WWMGRMlIGG1eGH/9NTknf/H5dI6hfXLFnUKtu/ZQmAspOG3xGM6cefWV0Oh5leHRkZ/MRgMfRA/U7NuewiAuzZzK7GXeHVlefHbm5sba6h0/Kue2cmLISNoIsJbkiuLicIuvsEJ3GfvFd9+Pr29tfX83dlpQoxobQqZ4Yrtk6opGQrPP0J2o47wAQRn23vVuE9BiDKrJGe536be8aIBBjEFn9Lp1C4mbsRT/gb3HMJwelS6NpQ7loRGJLZdOHnCP4sodcg64vHYsk77YTnS7/X6gliGsOOK9fZXtGVmMBQKnjo19muYUHwY2fUwQhD/dmZ64vkIXjQQcjScOEXbCMeSYOyyHuwsEqMYlYObI33j+rXPtra1vdTXP/g+vMadc3s8vXjxDuTx3DRzZjiTzSwm9vbubG6sX9ne3lrmdojhc8xVuziwfVm83wdBFhyiaOhrUZtZjgW8nqXv3L75Qmtr22vHh0c+0tQUfD9ezx2LTKpADOMknD8ei75yb272HxOJBJumqDN2RPOPQkQ+RaS/SCLxs+lEgpCCrN9B4tQOJ28/4v5mZZeM+NsI88bG2oTb4/7c8MiJ38TrqJYBhuxMcWZs/OOrK8tfn7s78zoSpwDR1FZZnRkdBwELp1pdqlx+UXoRT/atc0trW8fw8Oi/aGxq+hmZIY/UaNlYX3t+ZnryB0hsrBM5DESROjYdGkj/4QOIPweWqF/CAxOT83K+k7/E/sdz8u8Q0m+dMTm6ZP8v5SQo/Faee09qKGjw+4jHuSj4yBZ2SCAMCXbS8WHy12BXByJV8CPxXbRP4N2ozR+6jb9Lq6XLitZZE3w/wtoKw1UVRDEY0l+oSp+n79vCC1GpIicrWsRaSWVh8iz4HH2lIlqoPI+QRGnP7uepk7wnm+KVSiaVHn5uDCGSQ9/R2WXghZG+ZRP4xCiC7lf3d+0XP0AurER0IX3ksRD/e6I0IPH+udlCqHyJccVh9wtqkLKNSUHETLF9iEeb3D8ectnCvRS3KSwc3rXVlbewghkrs9gYCaMdIIfTB3FbrsSi0S9gcv0SJsS00riuh5JXTJ2s+DQMnB177GcQ93+kT6ww41gsmrp5/dqfer3eLx47PvxkqLnlXZicjOE5OqDwvJGdKMJ4/M5hAjO1t7f31trq8rWdSGQbycmajKCpSBrbr6IFnfWIlxg3kL1Akmt5afHTx4eGT+E+Z8c18R5ew/f/J/P35sg2cLR+CJvbLytQVXUFQ8Pzj5CkcKKkz4vXrfI9sm+J2oOXgzRFiyiyfHi6zfiMxHKUjaSSHaLUGG3yKmhPXs7KIoky4e2teWLYc6ohQf6/p7d3bHFh/k10v2Ao7V9+qzX+/koIB9lF4/TY+M+1trT+umu/zsb9TjHNxe2tzf86OXH7+6i8KAlptI2qzRR56wiVrpn82LDq80TC4QQ+5smzkuKy+CBEFBXq74gMQE71HUQpU/UYFiyLohGlzvCGzXQkEk5GroU/0xAI/N/BY8d/IhRsftLn95/Bw6MbyY2F1jXxONnOZbNzqXTqzm48dm15eemtBNkbV2y4rcTgRg9VbrkwbZSkrQQCjU71aIhysb64cO/HSC/K0Clqhe0D1gAji6azgAn8dTxePzs0PKpN/knxxf6BwV9pbmkZm5q88yJud7KGUjlJU4GE+hSyGzWkIe/M2FHl9Ot4+nmyX1K3o629o+vY8aEPY93xZwrFIUVDjmxf/MLknVtfYHL5VVv5HpU5/MgCiL8mKgn1V31H5hGt0j3oFgMpCsPF5EZPKpcNNfh8+/n9ePGeX99Ebo/bmqZtvibiGVYJMVZg8/ciC1GX5WKJ8p0RKg2nl5EsFflHimuWE7osIrFOr7WFHSb91DOs6kdbWzU0BLRC4QkweVpZXFy4guQh/sI2rrKwlhFAfo9xTzKZ3IzuRL7T2tb+S1X8fUvZxmT6L2emJr7ObG9UiYfEkfwyiooLlSqMfLvIUh8sIob7b292Zup7+DXZws8iFM0trW1NTU0tbrfHTwx5pplLpFPpWGQnvJ5OpZJMoUbRvHU6+NBpZbiig4eRzy2m4cVsqGx+eWnhTjwe/ejgsaEPeNye9kw2s40J23WssM1zbcKHDctSdGqibHBRDaLrOxHWkmvVCOy1+bHHjmXSdlRZpIWqdGSzKbgObwxQyVipB6yMdlF5+4thqblcLpFMJuZ0tpvr6Ox6Jyb+19F9hZaOYXaLUDYvmodlWD956sw/ae/o/DU8VUeRbS3Kp7FC/eeTd27/2e5unHprnQh/NcNn2T6k4I2RbHt60X3DEGvId+XzxZ/kx0GlkUQHea6aQBFFw7aX09pmRdKQHWKmJyf+Dr9+mRhOAnhAYjnejdfyNlKzB+1bUjDPz8axCA9Hd3ZWE4m93YIsl8nqrOJvfl6K9Cn2OWRphyIdBHV1957QqeYfje68QrbURGKPP3tvUiOWImqFv0+EJMaUleWlt8yc+cfDoyd+i2w/qTkEXMFg6LHHHn/nCF6Lvjl/7+4beNyzHn8fKq9IpSqygX0GPoJBpEeX1H5CAv26p7dvuK9/4J+RkH6F8TOfSad/vLg4/2ncTjNI7eGX1eOoyzn8qAOIfw3h4Bkti/Q7Xe8AsCbj1Y3Jc6TonWG4UFdbM/K63Wh2Zd0qo5fJZcxzLaOEJPKWPRUJImC9BbzAYouwlIRColJBzS+kKs8qYn5fKfi56xXv3+v1Es+i6necXh/Ui+dkvOG8SS7D59cv7BcJb3/XzOUI0bUV9ENyq/uBIBi7PAEsCfdGnJdxemriK4898a7zPp/v5AFvh/Tt1ehO5Gsz05Pf4/amP0hYvyP5JWeJ9xUhZ4WRL8hTnDNYiXJhUhzFB68EiSJleOVPZLxTETVRyF45Czr/jNQ7zHqSrd/Giu7arZ3rL6LSFB2VB7Fmuf0qaBgAlN+r9b1J8rop2P6gFalFxJ+XqeWON5nxlo/cqkRB5K/Fe6mLdUPIEYtGr+sQ/6am4GlM/oe2NjdmmGtTGawMT8ZrquvEydNPt7a1fxQTudOIMz5nM5kfrawsPb8wf28KicmxjBjLPIZltZsDeeLbVCaj+Qg9Orb4PtCN/Kg06uPQoIiiYSEz4LL7pbOGE2Nvby+Oj3XuGqIxLUqvUbW1kyxXOVDoa5kuUvxsW5tzmD8pmrswP8eH+fPjXESInfqBN1zJnD62tl1bW3k7k808f/LUGbJHvbbzhNQ4GRg89q86OjovzM/PvbS5sX4X2Um/yuuvE/LvpPupnGglZB/fr2doePTd7e0dH8K64jnEFTNmgfWJ+e2tzf+Fda7XuBQdFeEX6Ud1O4cfZQDxryEcPP5VjSCgkBSGK0EhJK+4qKwnwyet1R//1REKoc1YHEX3ElaYv9tlhM+0Dk0LijU5LST091kDAM1vdszDQnZlHyGxIBFZSflnl5F//rrF+8fEULUgyvpA+BmVoNOM/FAtutbh9Xq8+NDK+SZ75y4u3CO50Xx4tLKg4UEENjt2OWWTJ7nUKMRuj2Q9ezqdNu/cuvncmbPj/87vbziP5MYcYd/kstm7iUTiNbzQv7y2unIP2Rcwne35nAh/ueS32CXce7yiTUlYyb7fqJSMsdcXGrWQWAnMSV47hWEX77vM5+Y9/gjZ5QS9Dza8nP8/WWjrAw0trFfFRkH+2bHC7hcuM8oiVBo9JTJaicadau4oDWcOz0XvycnjT4l/cnlp8Ydd3T0f1tgy0hgZPfnL8Xjsf6aSST6fn7aJTZnHynV7/+CxDwaDoWcMw+jl2ovI4HuR8PanJ+7c+geyVSkSGxx1DOy8waTs8cd5sNkxwPYt355OMoj/nszg6CRnKn6uQ4KTIY1vO3anI1kKjWpu6RhwdQy3SlmO5Gur1IFCvEaNTUFHQ9re7u7ru/H4JhKHxFdqtKWfKcehVmxTTHKnb6VS/+XM2XO/5ff7R8u4BmoIBEZPnzn7u/0DgzcWF+a/ha9FItKoAcCJ+MuMHHw/qIi/7LA+09HZ1dfXN/CBYDD4fsz+RdvyFUHSSGLRnS9OTt55KZNOJ5CY8IsMNY5pR+SfOp3DjxyA+NcQOrnQNYTKw004f3GCkqjgPTN1jGyV19q4X+R0cnEFk34DkY81uxuv4s+zQlo24XlFhP4e7yGyBFgo1GzEYlGqYMpCs3hvRPEZBO/rtIUo3L9Sw4Lyt3WEXJmRH1IDRgNefQzDrZWnhhfdH2ECTCqyspZpnjiJ+rJiKMY7q9BQEsh6f22eXlKU6+rlH39iePTE+9ra2n+WbCklyk0j4zWXyy5m0hlM9vdubG5uXN7cWF9E6jxT3dDTA4UkKzz/ogJlLPGnCrcqLQYJriEjYyrFW+aRrXgxF4TI0ufm75tVakWh5Spvl1DxAIVjHxIPL/2brTshCitVRVDJZKcpeY//Dv37IH3FPgtPjijpLxL/vb3dDSxP3sDr0NNOF/b5fN3nH3vyN+fnZr+8vr42jeyykUTyG909vUNYyX68qSn4lNfrJdtglVTFxnJpG//m/8GE/0WSfoOqk4t94DHOGU9ksoifl7wMot/njXsymcMbho6Uh1DDkCYah7wcFxlPdKIdzQoOLeOtICVLheJ9tbW3d3o8nnaHz+dWV5f/FpW5C4tmrQodo7Lw3tG+bpG7fu3yp8jWmsFQ6D1IQZAFMILB0ONjZ8+dx3Ll9trqyqurK8sTjLe8nJ04ELK3uxP5Lzk3N7e09Q0MXmgONb/X6/OdRgrvvvVj+XwUP/8Ls9NTL+zuxqNITvZ1DZJHYg4/qgDi/4BQSY5/mVCSWlJtvkD+s6bH8MVSu81N/kbU09Zsef2nl1atL7mQKz/Q1EUqmIqqlConO3cv7GJiXZpUwWe+r8rHlz1P8UwqwycTCZVwURlCSs4tLa1oZyfCe2JtqIYw04ji0CkMlg81NzstuBTm+vrqK0h/+z7rqLbg1thjXET2LAWeVEbGCxTZ//cfSB5kS2tbF1bMgySKJZvNpkjBHbx47TB5kKotjXhFW1aYRuZhqwZZoWeRss17YFnvkEpZtN0f15+m4qxD9sv2ykqeme179v9YRVk0FvjPKBUPUDrskBieCFg5TMcj+55O2pSTEVWk3FZTOeRJEj//6ZZbVrj1vbuzXzt3/rF3Yd7uWFmdbGF48vTY7xwfHl3CpJ3scBM33Abm+N5Or9c3YhjCrUH3byqfj2NC8OezM1NfikWjUVQ9wl+1tpOEr4vmnSgtTyV/eFniGDVVzeeqJRQ7e4gMAGwEk8xDy88x2XySRdSoZLuWLOcMtDx4cl2cY51dPWPIgSzjeUNIMdkWuqophlw/0DGa4z4makObYSaTyeRuXL/6Z6MnTk139/T8Sx25wMFobGw6NzJ6cnzw2NBGdCfyJn7ey5FIeBU5h8XreP3pueTo7Ozq7+zueSIYDD3lu0/2lf2BKcDObjz+1buzMy/GYtEIEhN9WTHvmkQgAWoPIP4MnEhYcas/5jMqAk8+f3F/S8Di52VVz3Xu7QCPJhJ4RYVoZmex2ef2WRbBRr8fzS6vIROzf0KkzHw29k+H3/NDTLdUQjqPhR3Cio2UEDAKhaVQFraso9sGlQg2EZEvvMeH01mQkH5XfDfhDjYFcsgZNjKNSb/tPfZ56DjRTdfAn3Pjzwnvwen7WIC70tZOUsxDFaw2iFmwcPtrEX98rbt4IZpA+xb3NL5Ulgk1Feap1hotLa0u3N6sJ7A41g3DjUwzZyP+iClyh4m+e2tzI4JKjQS8R1hHyZYVplEpqBUvbA6ef17RZkOKZaTfKZXFyRvrpIhX5ZkVueb8vahCiFUGC5kBEsBA4f1HSDy2dIg/f5a9Lp5rQFr5dY7KDXbfbXIY0ejO0sb6+l909/R+TPOnXFgmD5JD58OE8Cf29l6YuzvzJaz8s9vzlUv4DxxxU0Y7iuanyBjEe/oR8zm+L3SOmjxTrSGQ47SdRHKcl+eiFEe2PYttgpxluMpoW4kslxmj+SgGixwGg8Fxh6Yi2xp/Hdm3X61aiqGE/Kv0bJGcsPShmenJb4W3tyZGTpz6mN/vr6SmkMvr9XZ3dHb9PD6eyaTTK7u7u7exnnNna3N9NplMxpGa+POyEjF9QXRAEsLf39rWPtrU1DTW0BAYd7vdXciB6FOYprkaj0W/Ojsz/XWst8eQ2DlCo3udUhTAy3/EAMSfQSWh+SoC/+UXXjAuPffJnM6WgAe5NwV4QV8UcIV8fdL/6bnwcoPP40U5M4/aW0Po7blFi/QTCRJyN77izpjEQyHz+FvXxcKjOPlFE56rbk62rGNDsHjLJiHyJQJMQO6d2iSPST/fPy6Ha9j+Fj0LY7zR6hMZ6dcBJuoyJcpGbv3+hjad62FF93vo/qKbYkLRZNb2mnlMqbJeiKygCiVCjKWeI/1UgecLI6k8wrwBwIno8zl3NVe4FVvCUcVL5n0th/iz13RSCKtO+DWelyUXrNLm5Ek8lD56WKHw/vNGAPbMv6afV70uUWRr2Dd0TNA5QwvJUo+/jXBNT0283BAI9DU3t3yoajdgmuHdvd0X792d/TKWb2GkV6W/FrVEyobCIMQbgUykNgbpGIAemvkqiJhgn5FNo1HVNFIRN5Ws1jWqVDL/RL9pI/0+nw/5fP7Tqovkcrm1ubuzZBca2RbCBy4oLKhXIbt/XkcoiQ7a3t6ajkTCfzh64tRPd3Z1f6QQ0VMJXF6fr7+VHG1tHxwaHslns5kNrNut4GM1nUptpdOpSCaTiZFCw2YuRwpM5UkxPgyf1+tr9Pl9zT6vvwO3c5fX5+3zeLwDhRTHsuoc4d+4ieXRX5MdgbKZDJtqpJP6KHKKsDKq2NZHeR4/CgDi/5BBEKYlEnTsRHcnc8nCwp5HG9sRlEilLY9/NpcxL/SNvYTs1lkZSdSe6LwRgLtXPsRNhkoFi+P36kxolSxahT2S+YXXkfjj7yVXlhbpwisqPCPzLGmjkqKV3O/k0X3iLzJy2CohI7lX2BR8V0TyVTmQwrB+ghqlPrAeIt6QISP6Tl5Ytn11FfCakzSFsYMPNadwCn3l773e5nFdQ2EAIGANUCxUslpoCDiEPmHvlU0X4XeRYeeOefP6tf89fu58rLWt/ZeRQz6s6rcxuVmIx2Mvzk5PfSOR2FNtzcenFVW9lshBIBkPvCESIbkxSMv4c1jPc1hQyHE+bUmWQqMrxxGSy79ayHKhdxwVIvD8DQ3EWaQKi8/jefG1XC5L5gRP/GW6ZEVOB0G9ChopJ3LylDhREKMfm6aZmZ6a+JvlpcUfjJw4+eHm5pYPyPe714LVx5i495CDRMpy9yP7TsUg+fuJROKVjfXVby4tLkwisUxSFRUtazeIh2UuP8wA4v9wgl2gRcKNrZru6mns2LgdW8j7PF7Xm9N3LW+/gY+gr/H1C+3nbiB7PpaMJFq/W0lFYfq6nG2w+N+pkHAeFcgs7cWF1+P1Oob6p1LJa7FYdA0x+f2GYWS5PYGFwlwX5faBgADyCzX73HSbMZ3CUjyBr7S41KEtaoLt4HhFW+aB5RUD0TzSUcQP0yuryo+VEQut+wfFo3I4GGUJZORO+t5h7qYgKfLFykyZkTB76+0bX+rvH7zSPzj4b3w+/1mkqXCTqCmMH+1Ewt+YnZn6AZanKaRWrMsJ6T8UL3+ZbVpO8Te2nUteP4xzVSHHESqVbU6ynIeu7K424Rc5j4pbfe7G41vZbHbS4/GcEV0E/9/EzNTkC/glqRTPh/lXPc1QQv5FKWVK4l840nt7u+m3b7z1hVCo+W+OD488g88/hXWnpjJuSQcHIvgsiEzKpNNvRqM73743N/t6KpXa455NJpdEOfyqKEjang/lXH5YUbWB9qjCYcu+WhfwE95DYcFhc8ioh5QWNfKxRzqPWj5z56/+2uVyd5DUcUL6cygXf1/PE7/xVNuZm0i+L2lJXhZM/oOj0H+U0PL95ncZRmPeNEkFf7LwNLnd7uZ3/8R7PoPP3YrL5tdWV/7jzPQkKey3iw+yEJBFmN/Sz7YAH1Z/MlEqssq1sq3FeOVJFdYnW7ycwiMfyKLGRe44edh0FUb2dV0o45LndHqmQzVSAO5DVvirHtqfkyOsvGBz+9n1j3gp/YXX5EzkrLenp2+0s6v7QkNDw2m3x9ODlfxml8vlIbuF5PNmLJfNrWUymdnd3fiN5aXFy1yerCo/ttxaIgjVkWIt6XudeVpEPTzHYaIMOa6rj9dcljP3zM4hVhcp6iP0GBg8dnrw2NAlrIcMM5fKYdL5nempiU/tRMLsFn58YWFhqP9Bx4pAr+D1CBpByD8X+3w+/vD7G0LHh4afbmlt+ymfzzdaRt/VDFg27abTqSvxWOz7i4vzZMtEWkRUtu2tTjh/3RkjAQfHAx+s9YRqe40flBeaIf48+aeKj5c7PLfSy0+/vnD1Fyxnfw4tPT345MtnAv2k+iq/j6eM9FsGDhACBwdnuKFGG9pXZCEiymqgcDRihbTpqQvv/ROPxzMkuyaxxl95842PZ7MZshgk0H3LO2vQeaCGHAn5lxkCnPIinUi9U6h4XS1qCnIs+lsEVQRAXTxnGaSi7u4dUD/g1j9ejrJrIFXk+dd8OhGFyDso8qKpCvepIo/qlvBrtHcJ6v2+DxuCdqpEjhMciix3cCBRAxo7dzyGYfj6+geGSc0hEjka3t66u729RQh/hjlEaYYlHv8qPwdtX5EBgD4TbwDgjQDsuag7t3d0DnT39F4IBoNP7hsBXIcUSZ1PZzLZmVQyeS0a3bm8tDh/PZPJpFB1ihrXtLAx4MECiH8BOhX9uWr+jpXdRf9Xi9/hofB68FWNbRWO0X0lpxj+iOypAVlMLk2Xy8hlMumScP9aCgHRjgrltGu1fqcGz1USFSJZcK0FyTDc/nQ61UCKvqD7BoCGJ9757v/Q2Nj0C6LfyJtmZG5u9ndXlpeIISfJHKKdGqw+PXZ8GJ0YHZZFq5SEeOq0v85nuLFLz6qD/aztsQVnnRzII61s66Len0/1jEfh3gEPFhLjtyj6zSt4TUkAn0rEp1vx4cGi1zpetEOrJQKoHxxUhlPUaowoHEi8AY0988YyvjAvX0ROWN+i2s/kEFFI75l/NpmM4N8rGgoDgUCwu6dvPBgKnW5oaBj1erzHDLe7FR08Tz+Zy+WWMLGfS6WS0/FYbGJ1dflOOpVKoFJDpEwO6ZD9IxN9BKgcQPw1cdRyyKnQbmlpNXZ2IjLB7UZ2zwar4PC5kSKhYVNaHqQwOGr9o4JgwWX7TBSm6u/u6R05cfL051wuV4i9Vi6bnZifv/fJleXFacRU80f2mg3CAjsPqj8VoZGyIkgyOXZYeZAAAKCO4BDiy657rJLPr4uqwqGioqEihbqssFlUB2spAECgcCDxTiR23rAOJAKRHimLginOhVqMf0VEocoAIDJy8K9FcoPuNmQ0NjYFW1pbewOBxm6f39/ucXua3W530GW4fC6XQfQ4l8vi9vm0mTcTpmnu5bK5nUw2E04lE2uY5K9GIuEN/L5MtsgIvS7RB8L/iAGIvyaOGrEUCG2e/LMCjldwZJ4NfquhmgrqcnDU+kcFyYIrC1OlOWje40Mj4339A7/vdhtDmUz2Wiwa/cbU5O3v5nI5lujztRrY6tKHntuv2Q60Ldgz/1oFZU5kPTwrAACoLiTknzWm8kYAkeIuIv58UTDZLiHlhM2CYg2oO0jSZkQGNHZOsfNFZSQTGsNqPQc06wmJ5IIHiQ0CKvnBXpf+Jg+RTOCLD4uOXJlnkEsAC0D8NVEJsax24b9y70EgtIuCzev1ujOZjChfmkCl3Agtgg9aMDxMxJ9gZnbOWJifIy95r78oD40e/MLL7+LAHqJQO9viWy9tWmFuZN3ntAMAgNrCIb+X9fLxRnF2beQhU8759dKpiCi9FsgjQF1CIz9eVHRXFCHDO5KktS0OYy441BMSPZdb42Dlh6hNVNs1Vkr+dYyO5ZB9cIw8AgDir4l6IUHlQCO0SVQZnUIkfKpa1VPWptU2stQzZPetsLTL6jSIilGJtqjhw+1KDDq1EPTV7J9KciNh8QIAHk1orIO8t48n/bK1UaSkOynVoFgDjhQ0POQqBxI96+yqc6hzQaOekMrA4ZacVTsPieoS8dGIKvIvMgKonHO6RB/k0iMGIP6aOKpkVKNSeiVV0en/H0g4PPuJvHHpuepsd1gPbV3N+9bYhsapTgMBa2WX5XyV7J0LAh8AADxMcFDyRcp5JR46VQFRUKwBRxZl6JEiIxk9K4tZ1kFNIR0DoSH5W0b4RVsOs2e2jfh2cjIsOp3L8eyD7vcIAYg/B1rVnUWhqr40NF/0Hfo91e/Qav2632NJIv89VUrBwvw9tDA/l+/o7LK8wdlMxrWzEyEvpVXRGwIBl+Ey8oZhWNd1u915j9eb39rcUArqcp7n2U/8gXHx4kXh/6naQNamOt9hd0jQSbdgq/w7GRfY52H7yWkc8PdG/379+6/Slzby7/P53Pl83iBHNpu13sP9YxH/XC7HXr64EJDdGPBnc17chy6Xy3QZhuk23Cb+28RjQVmgUTTudJ+pnP4RzYejaMwBAAD1B0HNEBWZQUi+PoqUZieiD4QfcKQhIP/sa525IntdF3NCc0chUbSsU/SDyCiiK1NUh6n5nlMf1EX7Aw4PQPw1cVQ9/hS80tPR2eXCJL74t+RrB7YKVlLLoBLUU1tX896YkH9UOBsNgYCRTCRkoal8CJkq7Mtmedft18PqUwAAAKg2NHcNYc8y5DXPoFgDHgpIyDESvOZxJDzMDrJBVDC7nMOpjWTt5BRJpBNxJLp23bU/4HAAxJ9BtcljPRIkiWBzgqOgqGfi/aBBIgEuPffJisaBwgrNLzyiqrHa1mDYihEAADxKUKyFOmtkXvK37X1QrAEPGxyK7co82SV/1/vcUBg5nKKFDmJMZNtIJ1pCl+QfmXYH1B5A/B9BQHG0w8VBia1GCJr1XjAYcsfjMd7A4GgJLrdvgagDAICHBZL1sGyjOAWslYBHAQo9UlS4roijNj8cthXWIfky0i/L8+f/1o0sArIP0AIQf4BQgIOgqC+UEZ7KQ7koQD8DAACAHbrGcZCfAMB9sPPmYZsbikgHl+Z7yOE9Ah0DgNbrh639AdUDEH8A4AjBwfosQ8nCAIsCAAAAAAAAQPkoM+WhUq6lawiwAHodQAdA/AGAIwiHRYcFLA4AAAAAAAAANcIBU4ZUeChSJgD1AyD+AMARhk5IKiwQAAAAAAAAAIeLSmpqUYDuBgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoDL8f9DwCoJpoZhyAAAAAElFTkSuQmCC" alt="Hemlock Logo" class="header-logo">
        <h1>Hemlock Language Manual</h1>
        <span class="tagline">"A small, unsafe language for writing unsafe things safely."</span>
    </div>

    <!-- Mobile Menu Toggle -->
    <button class="menu-toggle" id="menuToggle"></button>

    <!-- Container -->
    <div class="container">
        <!-- Sidebar Navigation -->
        <nav class="sidebar" id="sidebar">
            <div class="nav-section">
<a href="#language-reference" class="nav-link" data-page="language-reference">Language Reference</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Getting Started</div>
<a href="#getting-started-installation" class="nav-link" data-page="getting-started-installation">Installation</a>
<a href="#getting-started-quick-start" class="nav-link" data-page="getting-started-quick-start">Quick Start</a>
<a href="#getting-started-tutorial" class="nav-link" data-page="getting-started-tutorial">Tutorial</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Language Guide</div>
<a href="#language-guide-arrays" class="nav-link" data-page="language-guide-arrays">Arrays</a>
<a href="#language-guide-control-flow" class="nav-link" data-page="language-guide-control-flow">Control Flow</a>
<a href="#language-guide-error-handling" class="nav-link" data-page="language-guide-error-handling">Error Handling</a>
<a href="#language-guide-functions" class="nav-link" data-page="language-guide-functions">Functions</a>
<a href="#language-guide-memory" class="nav-link" data-page="language-guide-memory">Memory</a>
<a href="#language-guide-modules" class="nav-link" data-page="language-guide-modules">Modules</a>
<a href="#language-guide-objects" class="nav-link" data-page="language-guide-objects">Objects</a>
<a href="#language-guide-runes" class="nav-link" data-page="language-guide-runes">Runes</a>
<a href="#language-guide-strings" class="nav-link" data-page="language-guide-strings">Strings</a>
<a href="#language-guide-syntax" class="nav-link" data-page="language-guide-syntax">Syntax</a>
<a href="#language-guide-types" class="nav-link" data-page="language-guide-types">Types</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Advanced Topics</div>
<a href="#advanced-async-concurrency" class="nav-link" data-page="advanced-async-concurrency">Async Concurrency</a>
<a href="#advanced-command-execution" class="nav-link" data-page="advanced-command-execution">Command Execution</a>
<a href="#advanced-command-line-args" class="nav-link" data-page="advanced-command-line-args">Command Line Args</a>
<a href="#advanced-ffi" class="nav-link" data-page="advanced-ffi">Ffi</a>
<a href="#advanced-file-io" class="nav-link" data-page="advanced-file-io">File Io</a>
<a href="#advanced-signals" class="nav-link" data-page="advanced-signals">Signals</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Api Reference</div>
<a href="#reference-array-api" class="nav-link" data-page="reference-array-api">Array Api</a>
<a href="#reference-builtins" class="nav-link" data-page="reference-builtins">Builtins</a>
<a href="#reference-concurrency-api" class="nav-link" data-page="reference-concurrency-api">Concurrency Api</a>
<a href="#reference-file-api" class="nav-link" data-page="reference-file-api">File Api</a>
<a href="#reference-memory-api" class="nav-link" data-page="reference-memory-api">Memory Api</a>
<a href="#reference-operators" class="nav-link" data-page="reference-operators">Operators</a>
<a href="#reference-string-api" class="nav-link" data-page="reference-string-api">String Api</a>
<a href="#reference-type-system" class="nav-link" data-page="reference-type-system">Type System</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Design & Philosophy</div>
<a href="#design-implementation" class="nav-link" data-page="design-implementation">Implementation</a>
<a href="#design-philosophy" class="nav-link" data-page="design-philosophy">Philosophy</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Contributing</div>
<a href="#contributing-guidelines" class="nav-link" data-page="contributing-guidelines">Guidelines</a>
<a href="#contributing-testing" class="nav-link" data-page="contributing-testing">Testing</a>
</div>
        </nav>

        <!-- Main Content -->
        <main class="main-content">
            <div class="content" id="content"></div>
        </main>
    </div>

    <script>
        // Embedded documentation pages
        const PAGES = {"Language Reference": {"id": "language-reference", "content": "# Hemlock Language Design Philosophy\n\n> \"A small, unsafe language for writing unsafe things safely.\"\n\nThis document captures the core design principles and philosophy of Hemlock. Read this first before making any changes or additions to the language.\n\n---\n\n## Core Identity\n\nHemlock is a **systems scripting language** that embraces manual memory management and explicit control. It's designed for programmers who want:\n- The power of C\n- The ergonomics of modern scripting languages\n- Structured async concurrency built-in\n- No hidden behavior or magic\n\n**Hemlock is NOT:**\n- Memory-safe (dangling pointers are your responsibility)\n- A replacement for Rust, Go, or Lua\n- A language that hides complexity from you\n\n**Hemlock IS:**\n- Explicit over implicit, always\n- Educational and experimental\n- A \"C scripting layer\" for systems work\n- Honest about tradeoffs\n\n---\n\n## Design Principles\n\n### 1. **Explicit Over Implicit**\n- Semicolons are mandatory (no ASI)\n- No garbage collection\n- Manual memory management (alloc/free)\n- Type annotations are optional but checked at runtime\n- No automatic resource cleanup (no RAII, no defer yet)\n\n**Bad (implicit):**\n```hemlock\nlet x = 5  // Missing semicolon - should error\n```\n\n**Good (explicit):**\n```hemlock\nlet x = 5;\nfree(ptr);  // You allocated it, you free it\n```\n\n### 2. **Dynamic by Default, Typed by Choice**\n- Every value has a runtime type tag\n- Literals infer types intelligently:\n  - Small integers (fits in i32): `42`  `i32`\n  - Large integers (> i32 range): `9223372036854775807`  `i64`\n  - Floats: `3.14`  `f64`\n- Optional type annotations enforce runtime checks\n- Implicit type conversions follow clear promotion rules\n\n```hemlock\nlet x = 42;              // i32 inferred (small value)\nlet y: u8 = 255;         // explicit u8\nlet z = x + y;           // promotes to i32\nlet big = 5000000000;    // i64 inferred (> i32 max)\n```\n\n### 3. **Unsafe is a Feature, Not a Bug**\n- Pointer arithmetic can overflow (user's responsibility)\n- No bounds checking on raw `ptr` (use `buffer` if you want safety)\n- Double-free crashes are allowed (manual memory management)\n- Type system prevents accidents but allows footguns when needed\n\n```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // Way past allocation - allowed but dangerous\n```\n\n### 4. **Structured Concurrency First-Class**\n- `async`/`await` built into the language\n- Channels for communication\n- `spawn`/`join`/`detach` for task management\n- No raw threads, no locks - structured only\n\n### 5. **C-like Syntax, Low Ceremony**\n- Familiar to systems programmers\n- `{}` blocks always, no optional braces\n- Operators match C: `+`, `-`, `*`, `/`, `%`, `&&`, `||`, `!`\n- Type syntax matches Rust/TypeScript: `let x: type = value;`\n\n---\n\n## Type System\n\n### Numeric Types\n- **Signed integers:** `i8`, `i16`, `i32`, `i64`\n- **Unsigned integers:** `u8`, `u16`, `u32`, `u64`\n- **Floats:** `f32`, `f64`\n- **Aliases:** `integer` (i32), `number` (f64), `byte` (u8)\n\n### Other Primitives\n- **bool:** `true`, `false`\n- **string:** UTF-8, mutable, heap-allocated with `.length` property (see [Strings](#strings) section for 18 methods)\n- **rune:** Unicode codepoint (U+0000 to U+10FFFF), 32-bit value (see [Runes](#runes) section)\n- **array:** Dynamic arrays with mixed types, `.length` property (see [Arrays](#arrays) section for 15 methods)\n- **ptr:** Raw pointer (8 bytes, no bounds checking)\n- **buffer:** Safe wrapper (ptr + length + capacity, bounds checked)\n- **null:** The null value\n\n### Type Promotion Rules\nWhen mixing types in operations, promote to the \"higher\" type:\n```\nf64 (highest precision)\n \nf32\n \nu64\n \ni64\n \nu32\n \ni32\n \nu16\n \ni16\n \nu8\n \ni8 (lowest)\n```\n\n**Examples:**\n- `u8 + i32`  `i32` (larger size wins)\n- `i32 + i64`  `i64` (larger size wins)\n- `u32 + u64`  `u64` (larger size wins)\n- `i32 + f32`  `f32` (float always wins)\n- `i64 + f64`  `f64` (float always wins)\n- `i8 + f64`  `f64` (float + largest wins)\n\n### Range Checking\nType annotations enforce range checks at assignment:\n```hemlock\nlet x: u8 = 255;   // OK\nlet y: u8 = 256;   // ERROR: out of range\nlet z: i8 = 128;   // ERROR: max is 127\n\n// 64-bit types\nlet a: i64 = 2147483647;   // OK\nlet b: u64 = 4294967295;   // OK\nlet c: u64 = -1;           // ERROR: u64 cannot be negative\n```\n\n### Integer Literal Inference\nInteger literals are automatically typed based on their value range:\n- Values in i32 range (-2147483648 to 2147483647): infer as `i32`\n- Values outside i32 range but within i64 range: infer as `i64`\n- Use explicit type annotations for other types (i8, i16, u8, u16, u32, u64)\n\n```hemlock\nlet small = 42;                    // i32 (fits in i32)\nlet large = 5000000000;            // i64 (> i32 max)\nlet max_i64 = 9223372036854775807; // i64 (INT64_MAX)\nlet explicit: u32 = 100;           // u32 (type annotation overrides)\n```\n\n---\n\n## Memory Management\n\n### The Two Pointer Types\n\n**`ptr` - Raw Pointer (Dangerous)**\n- Just an address, no tracking\n- No bounds checking\n- User manages lifetime\n- For experts and FFI\n\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);  // You must remember to free\n```\n\n**`buffer` - Safe Wrapper (Recommended)**\n- Pointer + length + capacity\n- Bounds checked on access\n- Still manual free required\n- Better default for most code\n\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // bounds checked\nprint(b.length);        // 64\nfree(b);                // still manual\n```\n\n### Memory API\n\n**Core Allocation:**\n- `alloc(bytes)` - allocate raw memory, returns `ptr`\n- `free(ptr)` - free memory (works on both `ptr` and `buffer`)\n- `buffer(size)` - allocate safe buffer\n\n**Operations:**\n- `memset(ptr, byte, size)` - fill memory\n- `memcpy(dest, src, size)` - copy memory\n- `realloc(ptr, size)` - resize allocation\n\n**Typed Allocation (TODO):**\n- `talloc(type, count)` - allocate array of typed values\n- `sizeof(type)` - get size of type\n\n---\n\n## Strings\n\nStrings are **UTF-8 first-class mutable sequences** with full Unicode support and a rich set of methods for text processing:\n\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';             // mutate with rune (now \"Hello\")\nprint(s.length);        // 5 (codepoint count)\nlet c = s[0];           // returns rune (Unicode codepoint)\nlet msg = s + \" world\"; // concatenation\nlet emoji = \"\";\nprint(emoji.length);    // 1 (one codepoint)\nprint(emoji.byte_length); // 4 (four UTF-8 bytes)\n```\n\n**Properties:**\n- **UTF-8 encoded** - Full Unicode support (U+0000 to U+10FFFF)\n- **Mutable** (unlike Python/JS/Java)\n- **Indexing returns `rune`** (Unicode codepoint, not byte)\n- **`.length`** - Codepoint count (number of characters)\n- **`.byte_length`** - Byte count (UTF-8 encoding size)\n- **Heap-allocated** with internal capacity tracking\n\n**UTF-8 Behavior:**\n- All string operations work with **codepoints** (characters), not bytes\n- Multi-byte characters (emojis, CJK, etc.) count as 1 character\n- `\"Hello\".length`  5, `\"\".length`  1\n- Indexing, slicing, and substring operations use codepoint positions\n\n### String Methods\n\n**Substring & Slicing (codepoint-based):**\n```hemlock\nlet s = \"hello world\";\nlet sub = s.substr(6, 5);       // \"world\" (start, length in codepoints)\nlet slice = s.slice(0, 5);      // \"hello\" (start, end exclusive, codepoints)\n\n// UTF-8 example\nlet text = \"Hi!\";\nlet emoji = text.substr(2, 1);  // \"\" (position 2, length 1)\n```\n\n**Search & Find:**\n```hemlock\nlet pos = s.find(\"world\");      // 6 (index of first occurrence)\nlet pos2 = s.find(\"foo\");       // -1 (not found)\nlet has = s.contains(\"world\");  // true\n```\n\n**Split & Trim:**\n```hemlock\nlet parts = \"a,b,c\".split(\",\");  // [\"a\", \"b\", \"c\"]\nlet clean = \"  hello  \".trim();  // \"hello\"\n```\n\n**Case Conversion:**\n```hemlock\nlet upper = s.to_upper();       // \"HELLO WORLD\"\nlet lower = s.to_lower();       // \"hello world\"\n```\n\n**Prefix/Suffix:**\n```hemlock\nlet starts = s.starts_with(\"hello\");  // true\nlet ends = s.ends_with(\"world\");      // true\n```\n\n**Replacement:**\n```hemlock\nlet s2 = s.replace(\"world\", \"there\");      // \"hello there\"\nlet s3 = \"foo foo\".replace_all(\"foo\", \"bar\"); // \"bar bar\"\n```\n\n**Repetition:**\n```hemlock\nlet repeated = \"ha\".repeat(3);  // \"hahaha\"\n```\n\n**Character & Byte Access:**\n```hemlock\n// Character-level access (codepoints)\nlet char = s.char_at(0);        // Returns rune (Unicode codepoint)\nlet chars = s.chars();          // Array of runes ['h', 'e', 'l', 'l', 'o']\n\n// Byte-level access (UTF-8 bytes)\nlet byte = s.byte_at(0);        // Returns u8 (byte value)\nlet bytes = s.bytes();          // Array of u8 bytes [104, 101, 108, 108, 111]\nlet buf = s.to_bytes();         // Convert to buffer (legacy)\n\n// UTF-8 example\nlet emoji = \"\";\nprint(emoji.char_at(0));        // U+1F680 (rocket rune)\nprint(emoji.byte_at(0));        // 240 (first UTF-8 byte)\n```\n\n**Method Chaining:**\n```hemlock\nlet result = \"  Hello World  \"\n    .trim()\n    .to_lower()\n    .replace(\"world\", \"hemlock\");  // \"hello hemlock\"\n```\n\n**Available String Methods:**\n- `substr(start, length)` - Extract substring by codepoint position and length\n- `slice(start, end)` - Extract substring by codepoint range (end exclusive)\n- `find(needle)` - Find first occurrence, returns codepoint index or -1\n- `contains(needle)` - Check if string contains substring\n- `split(delimiter)` - Split into array of strings\n- `trim()` - Remove leading/trailing whitespace\n- `to_upper()` - Convert to uppercase\n- `to_lower()` - Convert to lowercase\n- `starts_with(prefix)` - Check if starts with prefix\n- `ends_with(suffix)` - Check if ends with suffix\n- `replace(old, new)` - Replace first occurrence\n- `replace_all(old, new)` - Replace all occurrences\n- `repeat(count)` - Repeat string n times\n- `char_at(index)` - Get Unicode codepoint at index (returns rune)\n- `byte_at(index)` - Get byte value at index (returns u8)\n- `chars()` - Convert to array of runes (codepoints)\n- `bytes()` - Convert to array of bytes (u8 values)\n- `to_bytes()` - Convert to buffer for low-level access\n\n---\n\n## Runes\n\nRunes represent **Unicode codepoints** (U+0000 to U+10FFFF) as a distinct type for character manipulation:\n\n```hemlock\nlet ch = 'A';           // Rune literal\nlet emoji = '';       // Multi-byte character as single rune\nprint(ch);              // 'A'\nprint(emoji);           // U+1F680\n\nlet s = \"Hello \" + '!'; // String + rune concatenation\nlet r = '>' + \" msg\";   // Rune + string concatenation\n```\n\n**Properties:**\n- **32-bit value** representing a Unicode codepoint\n- **Range:** 0 to 0x10FFFF (1,114,111)\n- **Not a numeric type** - used for character representation\n- **Distinct from u8/char** - runes are Unicode, u8 is bytes\n\n### Rune Literals\n\n**Basic Syntax:**\n```hemlock\nlet a = 'A';            // ASCII character\nlet b = '0';            // Digit character\nlet c = '!';            // Punctuation\n```\n\n**Multi-byte UTF-8 Characters:**\n```hemlock\nlet rocket = '';      // Emoji (U+1F680)\nlet heart = '';        // Heart (U+2764)\nlet chinese = '';     // CJK character (U+4E2D)\n```\n\n**Escape Sequences:**\n```hemlock\nlet newline = '\\n';     // Newline (U+000A)\nlet tab = '\\t';         // Tab (U+0009)\nlet backslash = '\\\\';   // Backslash (U+005C)\nlet quote = '\\'';       // Single quote (U+0027)\nlet dquote = '\"';       // Double quote (U+0022)\nlet null = '\\0';        // Null character (U+0000)\nlet cr = '\\r';          // Carriage return (U+000D)\n```\n\n**Unicode Escapes:**\n```hemlock\nlet rocket = '\\u{1F680}';   // Emoji via Unicode escape\nlet heart = '\\u{2764}';     // Up to 6 hex digits\nlet ascii = '\\u{41}';       // 'A' via escape\nlet max = '\\u{10FFFF}';     // Maximum Unicode codepoint\n```\n\n### String + Rune Concatenation\n\nRunes can be concatenated with strings:\n\n```hemlock\n// String + rune\nlet greeting = \"Hello\" + '!';       // \"Hello!\"\nlet decorated = \"Text\" + '';       // \"Text\"\n\n// Rune + string\nlet prefix = '>' + \" Message\";      // \"> Message\"\nlet bullet = '' + \" Item\";         // \" Item\"\n\n// Multiple concatenations\nlet msg = \"Hi \" + '' + \" World \" + '';  // \"Hi  World \"\n\n// Method chaining\nlet result = ('>' + \" Important\").to_upper();  // \"> IMPORTANT\"\n```\n\n**Implementation:** Runes are automatically encoded to UTF-8 and converted to strings during concatenation.\n\n### Rune Type Conversions\n\n**Integer  Rune:**\n```hemlock\n// Integer to rune (codepoint value)\nlet code: rune = 65;            // 'A'\nlet emoji_code: rune = 128640;  // U+1F680 ()\n\n// Rune to integer (get codepoint)\nlet r = 'Z';\nlet value: i32 = r;             // 90\n```\n\n**Rune  String:**\n```hemlock\n// Explicit conversion\nlet ch: string = 'H';           // \"H\"\nlet emoji: string = '';       // \"\"\n\n// Automatic during concatenation\nlet s = \"\" + 'A';               // \"A\"\n```\n\n**u8 (char)  Rune:**\n```hemlock\n// Any u8 value 0-255 can convert to rune\nlet byte: u8 = 65;\nlet rune_val: rune = byte;      // 'A'\n\n// Note: Values 0-127 are ASCII, 128-255 are Latin-1\nlet extended: u8 = 200;\nlet r: rune = extended;         // U+00C8 ()\n```\n\n**Chained Conversions:**\n```hemlock\n// i32  rune  string\nlet code: i32 = 128512;         // Grinning face codepoint\nlet r: rune = code;             // \nlet s: string = r;              // \"\"\n```\n\n**Range Checking:**\n- Integer to rune: Must be in range [0, 0x10FFFF]\n- Out of range values cause runtime error\n- Rune to integer: Always succeeds (returns codepoint)\n\n### Rune Operations\n\n**Printing:**\n```hemlock\nlet ascii = 'A';\nprint(ascii);                   // 'A' (quoted, printable ASCII)\n\nlet emoji = '';\nprint(emoji);                   // U+1F680 (Unicode notation)\n\nlet tab = '\\t';\nprint(tab);                     // U+0009 (non-printable as hex)\n```\n\n**Type Checking:**\n```hemlock\nlet r = '';\nprint(typeof(r));               // \"rune\"\n\nlet s = \"text\";\nlet ch = s[0];\nprint(typeof(ch));              // \"rune\" (indexing returns runes)\n```\n\n**Comparison:**\n```hemlock\nlet a = 'A';\nlet b = 'B';\nprint(a == a);                  // true\nprint(a == b);                  // false\n\n// Runes can be compared with integers (codepoint values)\nprint(a == 65);                 // true (implicit conversion)\n```\n\n---\n\n## Control Flow\n\n### Current Features\n- `if`/`else`/`else if` with mandatory braces\n- `while` loops\n- `for` loops (C-style and for-in iteration)\n- `switch` statements with case/default\n- `break`/`continue`\n- Arithmetic operators: `+`, `-`, `*`, `/`, `%` (modulo)\n- Boolean operators: `&&`, `||`, `!`\n- Comparisons: `==`, `!=`, `<`, `>`, `<=`, `>=`\n- Bitwise operators: `&`, `|`, `^`, `<<`, `>>`, `~` (integer types only)\n\n### If Statements\n\n**Basic if/else:**\n```hemlock\nif (x > 10) {\n    print(\"large\");\n} else {\n    print(\"small\");\n}\n```\n\n**Else-if chains:**\n```hemlock\nif (x > 100) {\n    print(\"very large\");\n} else if (x > 50) {\n    print(\"large\");\n} else if (x > 10) {\n    print(\"medium\");\n} else {\n    print(\"small\");\n}\n```\n\n**Notes:**\n- Braces are always required for all branches\n- Conditions must be enclosed in parentheses\n- `else if` is supported for cleaner chaining (syntactic sugar for nested if statements)\n\n### Switch Statements\n\n**Basic switch:**\n```hemlock\nlet x = 2;\n\nswitch (x) {\n    case 1:\n        print(\"one\");\n        break;\n    case 2:\n        print(\"two\");\n        break;\n    case 3:\n        print(\"three\");\n        break;\n}\n```\n\n**Switch with default:**\n```hemlock\nlet color = \"blue\";\n\nswitch (color) {\n    case \"red\":\n        print(\"stop\");\n        break;\n    case \"yellow\":\n        print(\"slow\");\n        break;\n    case \"green\":\n        print(\"go\");\n        break;\n    default:\n        print(\"unknown color\");\n        break;\n}\n```\n\n**Fall-through behavior:**\n```hemlock\nlet grade = 85;\n\nswitch (grade) {\n    case 100:\n    case 95:\n    case 90:\n        print(\"A\");\n        break;\n    case 85:\n    case 80:\n        print(\"B\");\n        break;\n    default:\n        print(\"C or below\");\n        break;\n}\n```\n\n**Switch with return (in functions):**\n```hemlock\nfn get_day_name(day: i32): string {\n    switch (day) {\n        case 1:\n            return \"Monday\";\n        case 2:\n            return \"Tuesday\";\n        case 3:\n            return \"Wednesday\";\n        default:\n            return \"Unknown\";\n    }\n}\n```\n\n**Notes:**\n- Supports any value type (integers, strings, booleans, etc.)\n- Cases are compared using value equality\n- Fall-through is supported (C-style) - cases without `break` continue to next case\n- `break` exits the switch statement\n- `default` case matches when no other case matches\n- `default` can appear anywhere in the switch body\n- Expressions are allowed in both switch value and case values\n\n### Bitwise Operators\n\nHemlock provides bitwise operators for integer manipulation at the bit level. These operators work **only with integer types** (i8-i64, u8-u64) and preserve the original type of the operands.\n\n**Binary bitwise operators:**\n- `&` - Bitwise AND\n- `|` - Bitwise OR\n- `^` - Bitwise XOR (exclusive OR)\n- `<<` - Left shift\n- `>>` - Right shift\n\n**Unary bitwise operator:**\n- `~` - Bitwise NOT (complement)\n\n**Basic operations:**\n```hemlock\nlet a = 12;  // 1100 in binary\nlet b = 10;  // 1010 in binary\n\nprint(a & b);   // 8  (1000) - AND\nprint(a | b);   // 14 (1110) - OR\nprint(a ^ b);   // 6  (0110) - XOR\nprint(a << 2);  // 48 (110000) - left shift by 2\nprint(a >> 1);  // 6  (110) - right shift by 1\nprint(~a);      // -13 (two's complement)\n```\n\n**With unsigned types:**\n```hemlock\nlet c: u8 = 15;   // 00001111 in binary\nlet d: u8 = 7;    // 00000111 in binary\n\nprint(c & d);     // 7  (00000111)\nprint(c | d);     // 15 (00001111)\nprint(c ^ d);     // 8  (00001000)\nprint(~c);        // 240 (11110000) - in u8\n```\n\n**Type preservation:**\n```hemlock\n// Bitwise operations preserve the type of operands\nlet x: u8 = 255;\nlet result = ~x;  // result is u8 with value 0\n\nlet y: i32 = 100;\nlet result2 = y << 2;  // result2 is i32 with value 400\n```\n\n**Operator precedence:**\nBitwise operators follow C-style precedence:\n1. `~` (unary NOT) - highest, same level as `!` and `-`\n2. `<<`, `>>` (shifts) - higher than comparisons, lower than `+`/`-`\n3. `&` (bitwise AND) - higher than `^` and `|`\n4. `^` (bitwise XOR) - between `&` and `|`\n5. `|` (bitwise OR) - lower than `&` and `^`, higher than `&&`\n6. `&&`, `||` (logical) - lowest precedence\n\n**Precedence examples:**\n```hemlock\n// & has higher precedence than |\nlet result1 = 12 | 10 & 8;  // (10 & 8) | 12 = 8 | 12 = 12\n\n// Shift has higher precedence than bitwise operators\nlet result2 = 8 | 1 << 2;   // 8 | (1 << 2) = 8 | 4 = 12\n\n// Use parentheses for clarity\nlet result3 = (5 & 3) | (2 << 1);  // 1 | 4 = 5\n```\n\n**Important notes:**\n- Bitwise operators only work with integer types (not floats, strings, etc.)\n- Type promotion follows standard rules (smaller types promote to larger)\n- Right shift (`>>`) is arithmetic for signed types, logical for unsigned\n- Shift amounts are not range-checked (behavior is platform-dependent for large shifts)\n- Bitwise NOT (`~`) returns the one's complement (all bits flipped)\n\n### Modulo Operator\n\nThe modulo operator `%` returns the remainder after integer division. It works **only with integer types** (i8-i64, u8-u64) and follows C-style semantics.\n\n**Basic usage:**\n```hemlock\nlet a = 10 % 3;   // 1\nlet b = 15 % 4;   // 3\nlet c = 20 % 5;   // 0\nlet d = 100 % 7;  // 2\n```\n\n**C-style modulo behavior:**\nThe sign of the result follows the sign of the **dividend** (left operand):\n```hemlock\nlet a = -10 % 3;   // -1 (negative dividend)\nlet b = 10 % -3;   // 1  (positive dividend)\nlet c = -10 % -3;  // -1 (negative dividend)\n```\n\n**Type support:**\n```hemlock\n// Works with all integer types\nlet a: i8 = 10 % 3;       // i8\nlet b: i32 = 100 % 7;     // i32\nlet c: i64 = 1000 % 13;   // i64\nlet d: u8 = 255 % 10;     // u8\nlet e: u32 = 50000 % 19;  // u32\n```\n\n**Type promotion:**\nModulo follows the same type promotion rules as other arithmetic operators:\n```hemlock\nlet a: i8 = 10;\nlet b: i32 = 3;\nlet c = a % b;  // i32 (promoted to larger type)\n```\n\n**Operator precedence:**\nModulo has the same precedence as multiplication and division (higher than addition/subtraction):\n```hemlock\nlet a = 10 % 3 + 5;  // 6  (1 + 5)\nlet b = 10 * 3 % 7;  // 2  (30 % 7, left-to-right)\nlet c = 20 % 3 * 4;  // 8  (2 * 4, left-to-right)\n```\n\n**Division by zero:**\nModulo by zero causes a runtime error:\n```hemlock\nlet a = 10 % 0;  // Runtime error: Division by zero\n```\n\n**Important notes:**\n- Modulo only works with integer types (not floats)\n- Result sign follows dividend (C-style semantics)\n- Type promotion follows standard rules (smaller types promote to larger)\n- Division by zero is checked at runtime and throws an error\n\n---\n\n## Defer Statement\n\nThe `defer` statement schedules a function call to be executed when the surrounding function returns, providing explicit resource cleanup without RAII.\n\n### Syntax\n\n```hemlock\ndefer expression;\n```\n\nThe expression is typically a function call that performs cleanup (e.g., closing files, releasing resources).\n\n### Basic Usage\n\n```hemlock\nfn process_data() {\n    print(\"start\");\n    defer print(\"cleanup\");\n    print(\"work\");\n    // \"cleanup\" executes here, before function returns\n}\n\nprocess_data();\n// Output: start, work, cleanup\n```\n\n### Multiple Defers (LIFO Order)\n\nWhen multiple `defer` statements are used, they execute in **LIFO (last-in, first-out)** order:\n\n```hemlock\nfn example() {\n    defer print(\"first\");\n    defer print(\"second\");\n    defer print(\"third\");\n}\n\nexample();\n// Output: third, second, first\n```\n\n### Defer with Return\n\nDeferred calls execute **before** the function returns, but **after** the return value is evaluated:\n\n```hemlock\nfn process(): i32 {\n    defer print(\"cleanup\");\n    print(\"work\");\n    return 42;\n    // \"cleanup\" executes here, then returns 42\n}\n```\n\n### Defer with Exceptions\n\nDeferred calls execute **even when exceptions are thrown**, making them ideal for cleanup:\n\n```hemlock\nfn risky() {\n    defer print(\"cleanup 1\");\n    defer print(\"cleanup 2\");\n    print(\"work\");\n    throw \"error\";\n    // Both defers execute here, then exception propagates\n}\n\ntry {\n    risky();\n} catch (e) {\n    print(\"Caught: \" + e);\n}\n// Output: work, cleanup 2, cleanup 1, Caught: error\n```\n\n### Resource Cleanup Pattern\n\nThe primary use case for `defer` is automatic resource cleanup:\n\n```hemlock\nfn process_file(filename: string) {\n    let file = open(filename, \"r\");\n    defer file.close();  // Guaranteed to execute\n\n    let content = file.read();\n    // Process content...\n\n    // File automatically closed when function returns\n}\n```\n\n### Defer with Closures\n\nDeferred expressions capture the environment at the time of deferral:\n\n```hemlock\nfn example() {\n    let x = 10;\n    defer print(\"x = \" + typeof(x));  // Captures environment\n    x = 20;\n    // Defer sees x = 20 when it executes\n}\n```\n\n### Nested Functions\n\nEach function maintains its own defer stack:\n\n```hemlock\nfn inner() {\n    defer print(\"inner defer\");\n    print(\"inner body\");\n}\n\nfn outer() {\n    defer print(\"outer defer\");\n    inner();\n    print(\"outer body\");\n}\n\nouter();\n// Output: inner body, inner defer, outer body, outer defer\n```\n\n### Important Notes\n\n- **Explicit over implicit:** `defer` is visible in code, not hidden like RAII\n- **LIFO order:** Last defer executes first\n- **Always executes:** Runs on normal return, early return, or exception\n- **No implicit cleanup:** You must explicitly defer cleanup calls\n- **Scope:** Defers are tied to function scope, not block scope\n\n### When to Use Defer\n\n**Good use cases:**\n- Closing files and network connections\n- Releasing locks or other resources\n- Cleanup operations that must always run\n- Ensuring paired operations (open/close, lock/unlock)\n\n**Example patterns:**\n```hemlock\n// File I/O\nfn read_config(path: string) {\n    let f = open(path, \"r\");\n    defer f.close();\n    return f.read();\n}\n\n// Multiple cleanup steps\nfn complex_operation() {\n    let resource1 = acquire_resource1();\n    defer release_resource1(resource1);\n\n    let resource2 = acquire_resource2();\n    defer release_resource2(resource2);\n\n    // Use resources...\n    // Both resources guaranteed to be released in reverse order\n}\n```\n\n---\n\n## Error Handling\n\nHemlock supports exception-based error handling with `try`, `catch`, `finally`, and `throw` statements.\n\n### Syntax\n\n**Basic try/catch:**\n```hemlock\ntry {\n    // risky code\n} catch (e) {\n    // handle error, e contains the thrown value\n}\n```\n\n**Try/finally:**\n```hemlock\ntry {\n    // risky code\n} finally {\n    // always executes, even if exception thrown\n}\n```\n\n**Try/catch/finally:**\n```hemlock\ntry {\n    // risky code\n} catch (e) {\n    // handle error\n} finally {\n    // cleanup code\n}\n```\n\n**Throw statement:**\n```hemlock\nthrow expression;\n```\n\n### Semantics\n\n**1. Throw Statement**\n- `throw <expr>;` evaluates `<expr>` and throws it as an exception\n- Any value can be thrown: strings, numbers, objects, null, etc.\n- Execution immediately jumps to the nearest enclosing `catch` block\n- If no `catch` exists, propagates up the call stack\n\n```hemlock\nthrow \"file not found\";\nthrow 404;\nthrow { code: 500, message: \"Internal error\" };\nthrow null;\n```\n\n**2. Try Block**\n- Executes statements sequentially\n- If exception thrown, immediately jumps to `catch` (if present) or `finally` (if no catch)\n- If no exception, executes `finally` (if present) then continues\n\n**3. Catch Block**\n- Receives thrown value in the parameter variable (e.g., `e`)\n- Can use the caught value however needed\n- Can re-throw: `throw e;`\n- Can throw new exception: `throw \"different error\";`\n- Catch parameter is scoped to the catch block only\n\n```hemlock\ntry {\n    throw \"oops\";\n} catch (error) {\n    print(\"Caught: \" + error);\n    // error only accessible here\n}\n// error not accessible here\n```\n\n**4. Finally Block**\n- **Always executes**, regardless of whether exception was thrown\n- Runs after try block (if no exception) or after catch block (if exception caught)\n- Runs even if try/catch contains `return`, `break`, or `continue`\n- If finally block throws, that exception replaces any previous exception\n\n**Execution order example:**\n```hemlock\ntry {\n    print(\"1: try\");\n    throw \"error\";\n} catch (e) {\n    print(\"2: catch\");\n} finally {\n    print(\"3: finally\");\n}\nprint(\"4: after\");\n\n// Output: 1: try, 2: catch, 3: finally, 4: after\n```\n\n**5. Uncaught Exceptions**\n- If exception propagates to top of call stack without being caught: **crash**\n- Print error message (stack trace to be added)\n- Exit with non-zero status code\n\n```hemlock\nfn foo() {\n    throw \"uncaught!\";\n}\n\nfoo();  // Crashes with: Runtime error: uncaught!\n```\n\n### Panic - Unrecoverable Errors\n\nHemlock provides `panic(message?)` for **unrecoverable errors** that should immediately terminate the program.\n\n**Syntax:**\n```hemlock\npanic();                    // Default message: \"panic!\"\npanic(\"custom message\");    // Custom message\npanic(42);                  // Non-string values are printed\n```\n\n**Semantics:**\n- `panic()` **immediately exits** the program with exit code 1\n- Prints error message to stderr in format: `panic: <message>`\n- **NOT catchable** with try/catch (unlike `throw`)\n- Use for bugs and unrecoverable errors (e.g., invalid state, unreachable code)\n\n**Panic vs Throw:**\n```hemlock\n// throw - Recoverable error (can be caught)\ntry {\n    throw \"recoverable error\";\n} catch (e) {\n    print(\"Caught: \" + e);  //  Caught successfully\n}\n\n// panic - Unrecoverable error (cannot be caught)\ntry {\n    panic(\"unrecoverable error\");  //  Program exits immediately\n} catch (e) {\n    print(\"This never runs\");       //  Never executes\n}\n```\n\n**When to use panic:**\n- **Bugs**: Unreachable code was reached\n- **Invalid state**: Data structure corruption detected\n- **Unrecoverable errors**: Critical resource unavailable\n- **Assertion failures**: When `assert()` isn't sufficient\n\n**Examples:**\n```hemlock\n// Unreachable code\nfn process_state(state: i32) {\n    if (state == 1) {\n        return \"ready\";\n    } else if (state == 2) {\n        return \"running\";\n    } else if (state == 3) {\n        return \"stopped\";\n    } else {\n        panic(\"invalid state: \" + typeof(state));  // Should never happen\n    }\n}\n\n// Critical resource check\nfn init_system() {\n    let config = read_file(\"config.json\");\n    if (config == null) {\n        panic(\"config.json not found - cannot start\");\n    }\n    // ...\n}\n```\n\n### Control Flow Interactions\n\n**Return inside try/catch/finally:**\n```hemlock\nfn example() {\n    try {\n        return 1;  //  Returns 1 after finally runs\n    } finally {\n        print(\"cleanup\");\n    }\n}\n\nfn example2() {\n    try {\n        return 1;\n    } finally {\n        return 2;  //  Finally return overrides try return - returns 2\n    }\n}\n```\n\n**Rule:** Finally block return values override try/catch return values.\n\n**Break/continue inside try/catch/finally:**\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    try {\n        if (i == 5) { break; }  //  Breaks after finally runs\n    } finally {\n        print(\"cleanup \" + typeof(i));\n    }\n}\n```\n\n**Rule:** Break/continue execute after finally block.\n\n**Nested try/catch:**\n```hemlock\ntry {\n    try {\n        throw \"inner\";\n    } catch (e) {\n        print(\"Caught: \" + e);  // Prints: Caught: inner\n        throw \"outer\";  // Re-throw different error\n    }\n} catch (e) {\n    print(\"Caught: \" + e);  // Prints: Caught: outer\n}\n```\n\n**Rule:** Nested try/catch blocks work as expected, inner catches happen first.\n\n### Examples\n\n**Basic error handling:**\n```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division by zero\";\n    }\n    return a / b;\n}\n\ntry {\n    print(divide(10, 0));\n} catch (e) {\n    print(\"Error: \" + e);  // Prints: Error: division by zero\n}\n```\n\n**Resource cleanup:**\n```hemlock\nfn process_file(filename) {\n    let file = null;\n    try {\n        file = open(filename);\n        let content = read(file);\n        process(content);\n    } catch (e) {\n        print(\"Error processing file: \" + e);\n    } finally {\n        if (file != null) {\n            close(file);  // Always closes, even on error\n        }\n    }\n}\n```\n\n**Re-throwing:**\n```hemlock\nfn wrapper() {\n    try {\n        risky_operation();\n    } catch (e) {\n        print(\"Logging error: \" + e);\n        throw e;  // Re-throw to caller\n    }\n}\n\ntry {\n    wrapper();\n} catch (e) {\n    print(\"Caught in main: \" + e);\n}\n```\n\n### Current Limitations\n\n- No stack trace on uncaught exceptions (planned)\n- Memory allocation failures and internal errors still call `exit()` (intentional - these indicate unrecoverable system failures)\n- No custom exception types yet (any value can be thrown)\n\n**Note:** All user-facing runtime errors are now catchable with try/catch, including:\n- Array/string indexing out of bounds\n- Type conversion errors\n- Function arity mismatches\n- Stack overflow (infinite recursion)\n- Async task errors (join/detach)\n\n---\n\n## Functions\n\nFunctions are **first-class values** that can be assigned, passed, and returned:\n\n```hemlock\n// Named function syntax\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\n// Anonymous function\nlet multiply = fn(x, y) {\n    return x * y;\n};\n\n// Recursion\nfn factorial(n: i32): i32 {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\n// Closures\nfn makeAdder(x) {\n    return fn(y) {\n        return x + y;\n    };\n}\n\nlet add5 = makeAdder(5);\nprint(add5(3));  // 8\n```\n\n**Features:**\n- **First-class:** Functions can be assigned to variables, passed as arguments, and returned\n- **Lexical scoping:** Functions can read (not write) outer scope variables\n- **Closures:** Functions capture their defining environment\n- **Recursion:** Fully supported (no tail call optimization yet)\n- **Type annotations:** Optional for parameters and return type\n- **Optional parameters:** Parameters can have default values\n- **Pass-by-value:** All arguments are copied\n\n**Return semantics:**\n- Functions with return type annotation MUST return a value\n- Functions without return type annotation implicitly return `null` if no return statement\n- `return;` without a value returns `null`\n\n**Type checking:**\n- Parameter types are checked at call time if annotated\n- Return types are checked when function returns if annotated\n- Implicit type conversions follow standard promotion rules\n\n**Named vs Anonymous:**\n- `fn name(...) {}` desugars to `let name = fn(...) {};`\n- Both forms are equivalent\n\n### Optional Parameters\n\nFunctions can have optional parameters with default values using the `?:` syntax:\n\n```hemlock\n// Basic optional parameter\nfn greet(name: string, greeting?: \"Hello\") {\n    print(greeting + \" \" + name);\n}\n\ngreet(\"Alice\");              // Hello Alice\ngreet(\"Bob\", \"Hi\");          // Hi Bob\n\n// Multiple optional parameters\nfn format_name(first: string, middle?: \"\", last?: \"Doe\") {\n    if (middle == \"\") {\n        return first + \" \" + last;\n    }\n    return first + \" \" + middle + \" \" + last;\n}\n\nprint(format_name(\"John\"));                    // John Doe\nprint(format_name(\"John\", \"Q\", \"Adams\"));      // John Q Adams\n\n// Optional parameter with type annotation\nfn multiply(x: i32, factor?: 2): i32 {\n    return x * factor;\n}\n\nprint(multiply(5));      // 10\nprint(multiply(5, 3));   // 15\n\n// Default expressions can be complex\nfn power(base: i32, exp?: 2 + 1) {\n    let result = 1;\n    let i = 0;\n    while (i < exp) {\n        result = result * base;\n        i = i + 1;\n    }\n    return result;\n}\n\nprint(power(2));      // 8 (2^3)\nprint(power(2, 4));   // 16 (2^4)\n\n// Works with closures\nfn make_multiplier(factor?: 10) {\n    return fn(n) {\n        return n * factor;\n    };\n}\n\nlet mult = make_multiplier();\nprint(mult(5));  // 50\n\n// All optional parameters - 0 args is valid\nfn test(a?: 1, b?: 2, c?: 3) {\n    return a + b + c;\n}\n\nprint(test());            // 6\nprint(test(10));          // 15\nprint(test(10, 20));      // 33\nprint(test(10, 20, 30));  // 60\n```\n\n**Optional parameter rules:**\n- Optional parameters must come after all required parameters\n- Syntax: `param?: default_value` or `param: type?: default_value`\n- Default expressions are evaluated at call time, not function definition time\n- Default expressions are evaluated in the closure environment\n- Function calls validate argument count: `required  provided  total`\n- Error messages show the valid range: \"Function expects 2-4 arguments, got 1\"\n\n**Known limitations (v0.1):**\n- Closure environments are never freed (memory leak, to be fixed with refcounting in v0.2)\n- No pass-by-reference yet (`ref` keyword parsed but not implemented)\n- No variadic functions\n- No function overloading\n- No tail call optimization\n\n---\n\n## Enums\n\nHemlock supports **C-style enumerations** with explicit or auto-incrementing values:\n\n```hemlock\n// Simple enum (auto values: 0, 1, 2, ...)\nenum Color {\n    RED,\n    GREEN,\n    BLUE\n}\n\n// Enum with explicit values\nenum Status {\n    OK = 0,\n    ERROR = 1,\n    PENDING = 2\n}\n\n// Mixed auto and explicit values\nenum Code {\n    A,        // 0\n    B = 10,   // 10\n    C,        // 11 (auto-increments from last explicit value)\n    D = 20,   // 20\n    E         // 21\n}\n```\n\n### Usage\n\n**Accessing enum variants:**\n```hemlock\nprint(Color.RED);     // 0\nprint(Status.ERROR);  // 1\nprint(Code.C);        // 11\n```\n\n**Type annotations:**\n```hemlock\nlet color: Color = Color.RED;\nlet status: Status = Status.OK;\n\n// Type checking ensures values match\ncolor = Color.BLUE;  //  OK\n```\n\n**Comparisons:**\n```hemlock\nlet status = Status.OK;\n\nif (status == Status.OK) {\n    print(\"Success\");\n}\n\nif (status != Status.ERROR) {\n    print(\"Not an error\");\n}\n```\n\n**Switch statements:**\n```hemlock\nlet color = Color.GREEN;\n\nswitch (color) {\n    case Color.RED:\n        print(\"Red\");\n        break;\n    case Color.GREEN:\n        print(\"Green\");\n        break;\n    case Color.BLUE:\n        print(\"Blue\");\n        break;\n}\n```\n\n**Function parameters:**\n```hemlock\nfn process(s: Status): string {\n    if (s == Status.OK) {\n        return \"Success\";\n    }\n    if (s == Status.ERROR) {\n        return \"Failed\";\n    }\n    return \"Waiting\";\n}\n\nprint(process(Status.OK));      // \"Success\"\nprint(process(Status.ERROR));   // \"Failed\"\nprint(process(Status.PENDING)); // \"Waiting\"\n```\n\n### Implementation Details\n\n- Enum variants are **i32 values** at runtime\n- Enums create a **const namespace object** with variant fields\n- Type checking validates enum types during assignment and function calls\n- Auto-incrementing starts at 0, or continues from last explicit value\n- Variant values must be compile-time constants (i32 expressions)\n\n**Example of namespace object:**\n```hemlock\nenum Status {\n    OK,\n    ERROR,\n    PENDING\n}\n\n// Internally creates:\n// const Status = {\n//     OK: 0,\n//     ERROR: 1,\n//     PENDING: 2\n// }\n\n// So you can access:\nprint(Status.OK);  // 0\n```\n\n**Current Limitations:**\n- No enum variant validation at runtime (can assign any i32 to enum-typed variable)\n- No discriminated unions or associated data\n- No pattern matching (use switch statements)\n- Enum values must fit in i32 range\n\n---\n\n## Objects\n\nHemlock implements JavaScript-style objects with heap allocation, dynamic fields, methods, and duck typing.\n\n### Object Literals\n```hemlock\n// Anonymous object\nlet person = { name: \"Alice\", age: 30, city: \"NYC\" };\nprint(person.name);  // \"Alice\"\n\n// Empty object\nlet obj = {};\n\n// Nested objects\nlet user = {\n    info: { name: \"Bob\", age: 25 },\n    active: true\n};\nprint(user.info.name);  // \"Bob\"\n```\n\n### Field Access and Assignment\n```hemlock\n// Access\nlet x = person.name;\n\n// Modify existing field\nperson.age = 31;\n\n// Add new field dynamically\nperson.email = \"alice@example.com\";\n```\n\n### Methods and `self` Keyword\n```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    },\n    get: fn() {\n        return self.count;\n    }\n};\n\ncounter.increment();\ncounter.increment();\nprint(counter.get());  // 2\n```\n\n**How `self` works:**\n- When a function is called as a method (e.g., `obj.method()`), `self` is automatically bound to the object\n- `self` is read-only in the current implementation\n- Method calls are detected at runtime by checking if the function expression is a property access\n\n### Type Definitions with `define`\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active: bool,\n}\n\n// Create object and assign to typed variable\nlet p = { name: \"Alice\", age: 30, active: true };\nlet typed_p: Person = p;  // Duck typing validates structure\n\nprint(typeof(typed_p));  // \"Person\"\n```\n\n### Duck Typing\nObjects are validated against `define` statements using **structural compatibility** (duck typing):\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\n// OK: Has all required fields\nlet p1: Person = { name: \"Alice\", age: 30 };\n\n// OK: Extra fields are allowed\nlet p2: Person = { name: \"Bob\", age: 25, city: \"NYC\", active: true };\n\n// ERROR: Missing required field 'age'\nlet p3: Person = { name: \"Carol\" };\n\n// ERROR: Wrong type for 'age'\nlet p4: Person = { name: \"Dave\", age: \"thirty\" };\n```\n\n**Type checking happens:**\n- At assignment time (when assigning to a typed variable)\n- Validates all required fields are present\n- Validates field types match\n- Extra fields are allowed and preserved\n- Sets the object's type name for `typeof()`\n\n### Optional Fields\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,       // Optional with default value\n    nickname?: string,   // Optional, defaults to null\n}\n\n// Object with only required fields\nlet p = { name: \"Alice\", age: 30 };\nlet typed_p: Person = p;\n\nprint(typed_p.active);    // true (default applied)\nprint(typed_p.nickname);  // null (no default)\n\n// Can override optional fields\nlet p2: Person = { name: \"Bob\", age: 25, active: false };\nprint(p2.active);  // false (overridden)\n```\n\n**Optional field syntax:**\n- `field?: default_value` - Optional field with default\n- `field?: type` - Optional field with type annotation, defaults to null\n- Optional fields are added to objects during duck typing if missing\n\n### JSON Serialization\n\nObjects can be serialized to JSON strings using the `.serialize()` method, and JSON strings can be deserialized back to objects using the `.deserialize()` method on strings:\n\n```hemlock\n// obj.serialize() - Convert object to JSON string\nlet obj = { x: 10, y: 20, name: \"test\" };\nlet json = obj.serialize();\nprint(json);  // {\"x\":10,\"y\":20,\"name\":\"test\"}\n\n// Nested objects\nlet nested = { inner: { a: 1, b: 2 }, outer: 3 };\nprint(nested.serialize());  // {\"inner\":{\"a\":1,\"b\":2},\"outer\":3}\n\n// json.deserialize() - Parse JSON string to object\nlet json_str = obj.serialize();\nlet restored = json_str.deserialize();\nprint(restored.name);  // \"test\"\n```\n\n**Cycle Detection:**\n```hemlock\nlet obj = { x: 10 };\nobj.me = obj;  // Create circular reference\nobj.serialize();  // ERROR: serialize() detected circular reference\n```\n\n**Supported types in JSON:**\n- Numbers (i8-i32, u8-u32, f32, f64)\n- Booleans\n- Strings (with escape sequences)\n- Null\n- Objects (nested)\n- Arrays\n- Not supported: functions, pointers, buffers\n\n**Object Methods:**\n- `obj.serialize()` - Convert object to JSON string (with cycle detection)\n\n**String Methods (for JSON):**\n- `json_string.deserialize()` - Parse JSON string to object/value\n\n### Built-in Functions\n- `typeof(value)` - Returns type name string\n  - Anonymous objects: `\"object\"`\n  - Typed objects: custom type name (e.g., `\"Person\"`)\n\n### Implementation Details\n- Objects are heap-allocated\n- Shallow copy semantics (assignment copies the reference)\n- Fields stored as dynamic arrays (name/value pairs)\n- Methods are just functions stored in object fields\n- Duck typing validates at assignment time\n- Type names are stored in objects for `typeof()`\n\n**Current Limitations:**\n- No deep copy built-in\n- No reference counting (objects are never freed automatically)\n- No pass-by-value for objects\n- No object spread syntax\n- No computed property names\n- `self` is read-only (cannot reassign in methods)\n\n---\n\n## Arrays\n\nHemlock provides **dynamic arrays** with comprehensive methods for data manipulation and processing:\n\n```hemlock\n// Array literals\nlet arr = [1, 2, 3, 4, 5];\nprint(arr[0]);         // 1\nprint(arr.length);     // 5\n\n// Mixed types allowed\nlet mixed = [1, \"hello\", true, null];\n```\n\n**Properties:**\n- Dynamic sizing (grow automatically)\n- Zero-indexed\n- Mixed types allowed (unless using typed arrays)\n- `.length` property\n- Heap-allocated\n\n### Typed Arrays\n\nHemlock supports **typed arrays** - arrays with element type constraints enforced at runtime:\n\n```hemlock\n// Declare a typed array with element type constraint\nlet numbers: array<i32> = [1, 2, 3, 4, 5];\nlet strings: array<string> = [\"hello\", \"world\"];\nlet bools: array<bool> = [true, false, true];\n\n// Declare an explicitly untyped array (allows mixed types)\nlet mixed: array = [\"hello\", 42, 3.14, true];\n\n// Fully dynamic array (no type annotation)\nlet dynamic = [1, \"two\", 3.0];  // Same as untyped, but not annotated\n```\n\n**Type enforcement:**\n```hemlock\nlet arr: array<i32> = [1, 2, 3];\n\n// OK: Adding correct type\narr.push(4);         //  i32\narr[0] = 10;         //  i32\narr.unshift(0);      //  i32\narr.insert(2, 99);   //  i32\n\n// ERROR: Type mismatch\narr.push(\"string\");  //  Runtime error: Type mismatch in typed array\narr[0] = 3.14;       //  Runtime error: Type mismatch in typed array\n```\n\n**Supported element types:**\n- All primitive numeric types: `i8`, `i16`, `i32`, `i64`, `u8`, `u16`, `u32`, `u64`, `f32`, `f64`\n- `bool`, `string`, `rune`\n- `ptr`, `buffer`\n\n**Type checking applies to:**\n- Direct index assignment (`arr[i] = value`)\n- `push(value)` method\n- `unshift(value)` method\n- `insert(index, value)` method\n\n**Type checking behavior:**\n- Type constraints are enforced at runtime\n- All array operations that add elements validate the type\n- Mixed-type operations are not allowed in typed arrays\n- Three syntaxes for arrays:\n  - `let arr: array<type> = [...]` - Typed array (strict element type checking)\n  - `let arr: array = [...]` - Explicitly untyped array (allows mixed types)\n  - `let arr = [...]` - Implicitly untyped array (allows mixed types, no annotation)\n\n**Example - type safety:**\n```hemlock\nlet bytes: array<u8> = [255, 128, 64];\nbytes.push(200);     //  OK\nbytes.push(-1);      //  Error: u8 cannot be negative (enforced during array literal conversion)\nbytes.push(256);     //  Error: out of range for u8\n\nlet names: array<string> = [\"Alice\", \"Bob\"];\nnames.push(\"Charlie\");  //  OK\nnames.push(42);         //  Error: expected string\n```\n\n**Implementation notes:**\n- Type constraint is stored in the array structure\n- Type checking happens at every mutation operation\n- No automatic type conversion (strict type matching)\n- Type validation uses exact type matching (i32  u8)\n\n### Array Methods\n\n**Stack & Queue Operations:**\n```hemlock\nlet arr = [1, 2, 3];\narr.push(4);           // Add to end: [1, 2, 3, 4]\nlet last = arr.pop();  // Remove from end: 4\n\nlet first = arr.shift();   // Remove from start: 1\narr.unshift(0);            // Add to start: [0, 2, 3]\n```\n\n**Array Manipulation:**\n```hemlock\nlet arr = [1, 2, 4, 5];\narr.insert(2, 3);      // Insert at index: [1, 2, 3, 4, 5]\nlet removed = arr.remove(0);  // Remove at index: 1\n\narr.reverse();         // Reverse in-place: [5, 4, 3, 2]\narr.clear();           // Remove all elements: []\n```\n\n**Slicing & Extraction:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet sub = arr.slice(1, 4);   // [2, 3, 4] (end exclusive)\nlet f = arr.first();         // 1 (without removing)\nlet l = arr.last();          // 5 (without removing)\n```\n\n**Search & Find:**\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet idx = arr.find(30);      // 2 (index of first occurrence)\nlet idx2 = arr.find(99);     // -1 (not found)\nlet has = arr.contains(20);  // true\n```\n\n**Array Combination:**\n```hemlock\nlet a = [1, 2, 3];\nlet b = [4, 5, 6];\nlet combined = a.concat(b);  // [1, 2, 3, 4, 5, 6] (new array)\n```\n\n**String Conversion:**\n```hemlock\nlet words = [\"hello\", \"world\", \"foo\"];\nlet joined = words.join(\" \");  // \"hello world foo\"\n\nlet numbers = [1, 2, 3];\nlet csv = numbers.join(\",\");   // \"1,2,3\"\n\n// Works with mixed types\nlet mixed = [1, \"hello\", true, null];\nprint(mixed.join(\" | \"));  // \"1 | hello | true | null\"\n```\n\n**Method Chaining:**\n```hemlock\nlet result = [1, 2, 3]\n    .concat([4, 5, 6])\n    .slice(2, 5);  // [3, 4, 5]\n\nlet text = [\"apple\", \"banana\", \"cherry\"]\n    .slice(0, 2)\n    .join(\" and \");  // \"apple and banana\"\n```\n\n**Available Array Methods:**\n- `push(value)` - Add element to end\n- `pop()` - Remove and return last element\n- `shift()` - Remove and return first element\n- `unshift(value)` - Add element to beginning\n- `insert(index, value)` - Insert element at index\n- `remove(index)` - Remove and return element at index\n- `find(value)` - Find first occurrence, returns index or -1\n- `contains(value)` - Check if array contains value\n- `slice(start, end)` - Extract subarray (end exclusive, returns new array)\n- `join(delimiter)` - Join elements into string\n- `concat(other)` - Concatenate with another array (returns new array)\n- `reverse()` - Reverse array in-place\n- `first()` - Get first element (without removing)\n- `last()` - Get last element (without removing)\n- `clear()` - Remove all elements\n- `map(callback)` - Transform each element, returns new array\n- `filter(predicate)` - Keep elements that pass test, returns new array\n- `reduce(reducer, initial?)` - Accumulate to single value\n\n### Higher-Order Functions\n\n**map(callback) - Transform Elements:**\n```hemlock\n// Double each number\nlet nums = [1, 2, 3, 4, 5];\nlet doubled = nums.map(fn(x) {\n    return x * 2;\n});\nprint(doubled[0]);  // 2\nprint(doubled[2]);  // 6\n\n// Transform to different type\nlet strings = [1, 2, 3].map(fn(n) {\n    return \"num_\" + typeof(n);\n});\nprint(strings[0]);  // \"num_1\"\n```\n\n**filter(predicate) - Select Elements:**\n```hemlock\n// Keep even numbers\nlet nums = [1, 2, 3, 4, 5, 6];\nlet evens = nums.filter(fn(x) {\n    return x % 2 == 0;\n});\nprint(evens.length);  // 3\nprint(evens[0]);  // 2\n\n// Filter strings by length\nlet words = [\"apple\", \"banana\", \"cherry\", \"date\"];\nlet long_words = words.filter(fn(w) {\n    return w.length > 5;\n});\nprint(long_words[0]);  // \"banana\"\n```\n\n**reduce(reducer, initial?) - Accumulate Values:**\n```hemlock\n// Sum array\nlet nums = [1, 2, 3, 4, 5];\nlet sum = nums.reduce(fn(acc, x) {\n    return acc + x;\n}, 0);\nprint(sum);  // 15\n\n// Product (without initial value - uses first element)\nlet product = [1, 2, 3, 4].reduce(fn(acc, x) {\n    return acc * x;\n});\nprint(product);  // 24\n\n// Find maximum\nlet max = [3, 7, 2, 9, 5].reduce(fn(acc, x) {\n    if (x > acc) {\n        return x;\n    } else {\n        return acc;\n    }\n}, 0);\nprint(max);  // 9\n```\n\n**Chaining Higher-Order Functions:**\n```hemlock\n// Complex data pipeline\nlet result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    .filter(fn(x) { return x % 2 == 1; })  // Get odds\n    .map(fn(x) { return x * x; })           // Square them\n    .reduce(fn(acc, x) { return acc + x; }, 0);  // Sum\nprint(result);  // 165 (1+9+25+49+81)\n```\n\n### Implementation Details\n- Arrays are heap-allocated with dynamic capacity\n- Automatic growth when capacity exceeded (doubles capacity)\n- Value comparison for `find()` and `contains()` works correctly for primitives and strings\n- `join()` converts all elements to strings automatically\n- Methods like `slice()` and `concat()` return new arrays (no mutation)\n- Methods like `reverse()`, `push()`, `insert()` mutate in-place\n\n**Current Limitations:**\n- No reference counting (arrays are never freed automatically)\n- No bounds checking on direct index access (use methods for safety)\n- Comparing objects/arrays in `find()` uses reference equality\n\n---\n\n## Command-Line Arguments\n\nHemlock programs can access command-line arguments via a built-in **`args` array** that is automatically populated at program startup.\n\n### The `args` Array\n\n```hemlock\n// args[0] is always the script filename\n// args[1] through args[n-1] are the actual arguments\nprint(args[0]);        // \"script.hml\"\nprint(args.length);    // Total number of arguments (including script name)\n```\n\n**Example usage:**\n```bash\n./hemlock script.hml hello world \"test 123\"\n```\n\n```hemlock\n// In script.hml\nprint(\"Script name: \" + args[0]);     // \"script.hml\"\nprint(\"Total args: \" + typeof(args.length));  // \"4\"\nprint(\"First arg: \" + args[1]);       // \"hello\"\nprint(\"Second arg: \" + args[2]);      // \"world\"\nprint(\"Third arg: \" + args[3]);       // \"test 123\"\n```\n\n### Iteration Pattern\n\n```hemlock\n// Skip args[0] (script name) and process actual arguments\nlet i = 1;\nwhile (i < args.length) {\n    print(\"Argument \" + typeof(i) + \": \" + args[i]);\n    i = i + 1;\n}\n```\n\n### Properties\n- **Always present:** `args` is a global array available in all Hemlock programs\n- **Script name included:** `args[0]` always contains the script path/name\n- **Type:** `args` is an array of strings\n- **Minimum length:** Always at least 1 (the script name)\n- **REPL behavior:** In the REPL, `args.length` is 0 (empty array)\n\n### Implementation Details\n- `args` is registered as a built-in global variable during environment initialization\n- Arguments are passed from `main()` through to `register_builtins()`\n- Each argument is stored as a string value in the array\n- Arguments with spaces are preserved if quoted in the shell\n\n### Common Use Cases\n\n**Simple argument processing:**\n```hemlock\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <filename>\");\n} else {\n    let filename = args[1];\n    // ... process file\n}\n```\n\n**Named arguments (simple pattern):**\n```hemlock\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--verbose\") {\n        let verbose = true;\n    }\n    if (args[i] == \"--output\") {\n        i = i + 1;\n        let output_file = args[i];\n    }\n    i = i + 1;\n}\n```\n\n---\n\n## Command Execution\n\nHemlock provides the **`exec()` builtin function** to execute shell commands and capture their output.\n\n### The `exec()` Function\n\n```hemlock\nlet result = exec(\"echo hello\");\nprint(result.output);      // \"hello\\n\"\nprint(result.exit_code);   // 0\n```\n\n**Signature:**\n- `exec(command: string): object`\n\n**Returns:** An object with two fields:\n- `output` (string): The command's stdout output (as a string)\n- `exit_code` (i32): The command's exit status code\n\n### Basic Usage\n\n```hemlock\n// Simple command\nlet r = exec(\"ls -la\");\nprint(r.output);\nprint(\"Exit code: \" + typeof(r.exit_code));\n\n// Check exit status\nlet r2 = exec(\"grep pattern file.txt\");\nif (r2.exit_code == 0) {\n    print(\"Found: \" + r2.output);\n} else {\n    print(\"Pattern not found\");\n}\n\n// Commands with pipes\nlet r3 = exec(\"ps aux | grep hemlock\");\nprint(r3.output);\n```\n\n### Result Object\n\nThe object returned by `exec()` has the following structure:\n\n```hemlock\n{\n    output: string,      // Command stdout (captured output)\n    exit_code: i32       // Process exit status (0 = success)\n}\n```\n\n**Field details:**\n- **`output`**: Contains all text written to stdout by the command\n  - Empty string if command produces no output\n  - Includes newlines and whitespace as-is\n  - Multi-line output preserved\n  - Not limited in size (dynamically allocated)\n\n- **`exit_code`**: The command's exit status\n  - `0` typically indicates success\n  - Non-zero values indicate errors (convention: 1-255)\n  - `-1` if command could not be executed or terminated abnormally\n\n### Advanced Examples\n\n**Handling failures:**\n```hemlock\nlet r = exec(\"ls /nonexistent\");\nif (r.exit_code != 0) {\n    print(\"Command failed with code: \" + typeof(r.exit_code));\n    print(\"Error output: \" + r.output);  // Note: stderr not captured\n}\n```\n\n**Processing multi-line output:**\n```hemlock\nlet r = exec(\"cat file.txt\");\nlet lines = r.output.split(\"\\n\");\nlet i = 0;\nwhile (i < lines.length) {\n    print(\"Line \" + typeof(i) + \": \" + lines[i]);\n    i = i + 1;\n}\n```\n\n**Command chaining:**\n```hemlock\n// Multiple commands with && and ||\nlet r1 = exec(\"mkdir -p /tmp/test && touch /tmp/test/file.txt\");\nif (r1.exit_code == 0) {\n    print(\"Setup complete\");\n}\n\n// Pipes and redirections work\nlet r2 = exec(\"echo 'data' | base64\");\nprint(\"Base64: \" + r2.output);\n```\n\n**Exit code patterns:**\n```hemlock\n// Different exit codes indicate different conditions\nlet r = exec(\"test -f myfile.txt\");\nif (r.exit_code == 0) {\n    print(\"File exists\");\n} else if (r.exit_code == 1) {\n    print(\"File does not exist\");\n} else {\n    print(\"Test command failed: \" + typeof(r.exit_code));\n}\n```\n\n### Error Handling\n\nThe `exec()` function throws an exception if the command cannot be executed:\n\n```hemlock\ntry {\n    let r = exec(\"nonexistent_command_xyz\");\n} catch (e) {\n    print(\"Failed to execute: \" + e);\n}\n```\n\n**When exceptions are thrown:**\n- `popen()` fails (e.g., cannot create pipe)\n- System resource limits exceeded\n- Memory allocation failures\n\n**When exceptions are NOT thrown:**\n- Command runs but returns non-zero exit code (check `exit_code` field)\n- Command produces no output (returns empty string in `output`)\n- Command not found by shell (returns non-zero `exit_code`)\n\n### Implementation Details\n\n**How it works:**\n- Uses `popen()` to execute commands via `/bin/sh`\n- Captures stdout only (stderr is not captured)\n- Output buffered dynamically (starts at 4KB, grows as needed)\n- Exit status extracted using `WIFEXITED()` and `WEXITSTATUS()` macros\n- Output string is properly null-terminated\n\n**Performance considerations:**\n- Creates a new shell process for each call\n- Output stored entirely in memory\n- No streaming support (waits for command completion)\n- Suitable for commands with reasonable output sizes\n\n**Security considerations:**\n-  **Shell injection risk**: The command is executed by the shell (`/bin/sh`)\n-  Always validate/sanitize user input before passing to `exec()`\n- Commands have full shell access (pipes, redirects, variables, etc.)\n- Runs with the same permissions as the Hemlock process\n\n### Limitations\n\n- **No stderr capture**: Only stdout is captured, stderr goes to terminal\n- **No streaming**: Must wait for command completion\n- **No timeout**: Commands can run indefinitely\n- **No signal handling**: Cannot send signals to running commands\n- **No process control**: Cannot interact with command after starting\n\n### Use Cases\n\n**Good use cases:**\n- Running system utilities (ls, grep, find, etc.)\n- Quick data processing with Unix tools\n- Checking system state or file existence\n- Generating reports from command-line tools\n- Automation scripts\n\n**Not recommended for:**\n- Long-running services or daemons\n- Interactive commands requiring input\n- Commands producing gigabytes of output\n- Real-time streaming data processing\n- Mission-critical error handling (stderr not captured)\n\n---\n\n## Async/Concurrency\n\nHemlock provides **structured concurrency** with `async fn` syntax, task spawning, and channels for communication. The implementation uses POSIX threads (pthreads) for **TRUE multi-threaded parallelism**.\n\n**Implementation Status**\n-  `async fn` - Fully implemented, functions can be spawned as tasks\n-  `spawn()` / `join()` / `detach()` - Fully implemented with true parallelism\n-  `await` - Automatically joins task handles, returns result\n-  Channels - Thread-safe communication with `send()` / `recv()` / `close()`\n\n**What this means:**\n-  **Real OS threads** - Each spawned task runs on a separate pthread (POSIX thread)\n-  **True parallelism** - Tasks execute simultaneously on multiple CPU cores\n-  **Kernel-scheduled** - The OS scheduler distributes tasks across available cores\n-  **Thread-safe channels** - Uses pthread mutexes and condition variables for synchronization\n\n**What this is NOT:**\n-  **NOT green threads** - Not user-space cooperative multitasking\n-  **NOT async/await coroutines** - Not single-threaded event loop like JavaScript/Python asyncio\n-  **NOT emulated concurrency** - Not simulated parallelism\n\nThis is the **same threading model as C, C++, and Rust** when using OS threads. You get actual parallel execution across multiple cores.\n\n### Async Functions\n\nFunctions can be declared as `async` to indicate they're designed for concurrent execution:\n\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n```\n\n**Key points:**\n- `async fn` declares an asynchronous function\n- Async functions can be spawned as concurrent tasks using `spawn()`\n- Async functions can also be called directly (runs synchronously in current thread)\n- When spawned, each task runs on its **own OS thread** (not a coroutine!)\n- `await task_handle` automatically joins the task and returns its result\n- Can use either `await task` or explicit `join(task)` - both are equivalent\n\n### Task Spawning\n\nUse `spawn()` to run async functions **in parallel on separate OS threads**:\n\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\n// Spawn multiple tasks - these run in PARALLEL on different CPU cores!\nlet t1 = spawn(factorial, 5);  // Thread 1\nlet t2 = spawn(factorial, 6);  // Thread 2\nlet t3 = spawn(factorial, 7);  // Thread 3\n\n// All three are computing simultaneously right now!\n\n// Wait for results\nlet f5 = join(t1);  // 120\nlet f6 = join(t2);  // 720\nlet f7 = join(t3);  // 5040\n```\n\n**Built-in functions:**\n- `spawn(async_fn, arg1, arg2, ...)` - Create a new task on a new pthread, returns task handle\n- `join(task)` - Wait for task completion (blocks until thread finishes), returns result\n- `detach(task)` - Fire-and-forget execution (thread runs independently, no join allowed)\n\n### Await Syntax\n\nThe `await` keyword provides convenient syntax for waiting on task results:\n\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Spawn multiple tasks\nlet task1 = spawn(compute, 10);\nlet task2 = spawn(compute, 20);\nlet task3 = spawn(compute, 30);\n\n// Await results (automatically joins tasks)\nlet result1 = await task1;  // Equivalent to join(task1)\nlet result2 = await task2;  // Equivalent to join(task2)\nlet result3 = await task3;  // Equivalent to join(task3)\n\nprint(result1 + result2 + result3);\n\n// Can also await inline\nlet result4 = await spawn(compute, 40);\n```\n\n**How `await` works:**\n- If the expression evaluates to a task handle, `await` automatically calls `join()` on it\n- If the expression is any other value, `await` just returns that value unchanged\n- `await task` and `join(task)` are functionally equivalent\n- Exceptions thrown in awaited tasks are propagated to the caller\n\n### Channels\n\nChannels provide thread-safe communication between tasks:\n\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Create channel with buffer size\nlet ch = channel(10);\n\n// Spawn producer and consumer\nlet p = spawn(producer, ch, 5);\nlet c = spawn(consumer, ch, 5);\n\n// Wait for completion\njoin(p);\nlet total = join(c);  // 100 (0+10+20+30+40)\n```\n\n**Channel methods:**\n- `channel(capacity)` - Create buffered channel\n- `ch.send(value)` - Send value (blocks if full)\n- `ch.recv()` - Receive value (blocks if empty)\n- `ch.close()` - Close channel (recv on closed channel returns null)\n\n### Exception Propagation\n\nExceptions thrown in spawned tasks are propagated when joined:\n\n```hemlock\nasync fn risky_operation(should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Task failed!\";\n    }\n    return 42;\n}\n\nlet t = spawn(risky_operation, 1);\ntry {\n    let result = join(t);\n} catch (e) {\n    print(\"Caught: \" + e);  // \"Caught: Task failed!\"\n}\n```\n\n### Verifying True Parallelism\n\nYou can verify that Hemlock's async implementation uses true multi-core parallelism by running CPU-intensive tasks:\n\n```bash\n# Run with time to measure CPU vs wall clock time\ntime ./hemlock my_concurrent_program.hml\n```\n\n**Example output showing true parallelism:**\n```\nreal    0m1.981s   # Wall clock time (actual elapsed time)\nuser    0m7.160s   # CPU time (sum across all cores)\nsys     0m0.020s\n```\n\n**Interpretation:**\n- **Real time:** How long the program took to run (wall clock)\n- **User time:** Total CPU time spent across all cores\n- **Ratio (user/real):** 7.16 / 1.98 = **3.6x speedup**\n\nIf `user time > real time`, this proves **true parallel execution**:\n- Single-threaded would show `user  real`\n- Green threads would show `user  real` (one core)\n- **True parallelism shows `user >> real`** (multiple cores working simultaneously)\n\nThe ratio indicates how many cores were utilized: 3.6x means ~3-4 CPU cores were actively computing in parallel.\n\n### Implementation Details\n\n**Threading Model:**\n- **1:1 threading** - Each spawned task creates a dedicated OS thread via `pthread_create()`\n- **Kernel-scheduled** - The OS kernel schedules threads across available CPU cores\n- **Pre-emptive multitasking** - The OS can interrupt and switch between threads\n- **No GIL** - Unlike Python, there's no Global Interpreter Lock limiting parallelism\n\n**Synchronization:**\n- **Mutexes** - Channels use `pthread_mutex_t` for thread-safe access\n- **Condition variables** - Blocking send/recv use `pthread_cond_t` for efficient waiting\n- **Lock-free operations** - Task state transitions are atomic\n\n**Performance Characteristics:**\n- **True parallelism** - N spawned tasks can utilize N CPU cores simultaneously\n- **Proven speedup** - Stress tests show 3.6x-9x CPU time vs wall time (multiple cores working)\n- **Verified parallel execution** - CPU time exceeds wall clock time, proving multi-core utilization\n- **Thread overhead** - Each task has ~8KB stack + pthread overhead\n- **Blocking I/O safe** - Blocking operations in one task don't block others\n\n**Memory & Cleanup:**\n- Joined tasks are automatically cleaned up after `join()` returns\n- Detached tasks: pthread is cleaned up by OS, but Task struct (~64-96 bytes) currently leaks\n- Channels are reference-counted and freed when no longer used\n\n**Current limitations:**\n- No `select()` for multiplexing multiple channels (planned)\n- No work-stealing scheduler (uses 1 thread per task, can be inefficient for many short tasks)\n- No async I/O integration yet (file/network operations still block)\n- Channel capacity is fixed at creation time (no dynamic resizing)\n\n---\n\n## File I/O\n\nHemlock provides a **File object API** for file operations with proper error handling and resource management.\n\n### Opening Files\n\nUse `open(path, mode?)` to open a file:\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");     // Read mode (default)\nlet f2 = open(\"output.txt\", \"w\");  // Write mode (truncate)\nlet f3 = open(\"log.txt\", \"a\");     // Append mode\nlet f4 = open(\"data.bin\", \"r+\");   // Read/write mode\n```\n\n**Modes:**\n- `\"r\"` - Read (default)\n- `\"w\"` - Write (truncate existing file)\n- `\"a\"` - Append\n- `\"r+\"` - Read and write\n- `\"w+\"` - Read and write (truncate)\n- `\"a+\"` - Read and append\n\n**Important:** Files must be manually closed with `f.close()` to avoid file descriptor leaks.\n\n### File Methods\n\n**Reading:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\n// Read entire file\nlet all = f.read();              // Read from current position to EOF\n\n// Read specific number of bytes\nlet chunk = f.read(1024);        // Read up to 1024 bytes\n\n// Read binary data\nlet binary = f.read_bytes(256);  // Returns buffer with 256 bytes\n\nf.close();\n```\n\n**Writing:**\n```hemlock\nlet f = open(\"output.txt\", \"w\");\n\n// Write text (returns bytes written)\nlet written = f.write(\"Hello, World!\\n\");  // Returns i32\n\n// Write binary data\nlet buf = buffer(10);\nbuf[0] = 65;  // 'A'\nlet bytes = f.write_bytes(buf);  // Returns i32\n\nf.close();\n```\n\n**Seeking:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\n// Get current position\nlet pos = f.tell();  // Returns i32\n\n// Move to specific position\nf.seek(100);         // Move to byte 100\nf.seek(0);           // Reset to beginning\n\nf.close();\n```\n\n**Closing:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nf.close();\nf.close();  // Safe - idempotent, can call multiple times\n```\n\n### File Properties (Read-Only)\n\n```hemlock\nlet f = open(\"/path/to/file.txt\", \"r\");\n\nprint(f.path);    // \"/path/to/file.txt\" - file path\nprint(f.mode);    // \"r\" - open mode\nprint(f.closed);  // false - whether file is closed\n\nf.close();\nprint(f.closed);  // true\n```\n\n### Error Handling\n\nAll file operations include proper error messages with context:\n\n```hemlock\n// Errors include filename for better debugging\nlet f = open(\"missing.txt\", \"r\");\n// Error: Failed to open 'missing.txt': No such file or directory\n\nlet f2 = open(\"data.txt\", \"r\");\nf2.close();\nf2.read();\n// Error: Cannot read from closed file 'data.txt'\n\nlet f3 = open(\"readonly.txt\", \"r\");\nf3.write(\"data\");\n// Error: Cannot write to file 'readonly.txt' opened in read-only mode\n```\n\n### Resource Management Pattern\n\n**Always close files explicitly:**\n\n```hemlock\n// Basic pattern\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n\n// With error handling\nlet f = open(\"data.txt\", \"r\");\ntry {\n    let content = f.read();\n    process(content);\n} finally {\n    f.close();  // Always close, even on error\n}\n```\n\n### Complete File API\n\n**Methods:**\n- `read(size?: i32): string` - Read text (optional size parameter)\n- `read_bytes(size: i32): buffer` - Read binary data\n- `write(data: string): i32` - Write text, returns bytes written\n- `write_bytes(data: buffer): i32` - Write binary data, returns bytes written\n- `seek(position: i32): i32` - Seek to position, returns new position\n- `tell(): i32` - Get current position\n- `close()` - Close file (idempotent)\n\n**Properties (read-only):**\n- `file.path: string` - File path\n- `file.mode: string` - Open mode\n- `file.closed: bool` - Whether file is closed\n\n**Note:** The old global functions (`read_file()`, `write_file()`, `append_file()`, `read_bytes()`, `write_bytes()`, `file_exists()`) have been removed in favor of the File object API. Use `open()` and file methods instead.\n\n---\n\n## Signal Handling\n\nHemlock provides **POSIX signal handling** for managing system signals like SIGINT (Ctrl+C), SIGTERM, and custom signals. This enables low-level process control and inter-process communication.\n\n### Signal API\n\n**Register Signal Handler:**\n```hemlock\nsignal(signum, handler_fn)\n```\n- `signum` - Signal number (i32 constant like SIGINT, SIGTERM)\n- `handler_fn` - Function to call when signal is received (or `null` to reset to default)\n- Returns the previous handler function (or `null` if none)\n\n**Raise Signal:**\n```hemlock\nraise(signum)\n```\n- `signum` - Signal number to send to current process\n- Returns `null`\n\n### Signal Constants\n\nHemlock provides standard POSIX signal constants as i32 values:\n\n**Interrupt & Termination:**\n- `SIGINT` (2) - Interrupt from keyboard (Ctrl+C)\n- `SIGTERM` (15) - Termination request\n- `SIGQUIT` (3) - Quit from keyboard (Ctrl+\\)\n- `SIGHUP` (1) - Hangup detected on controlling terminal\n- `SIGABRT` (6) - Abort signal\n\n**User-Defined:**\n- `SIGUSR1` (10) - User-defined signal 1\n- `SIGUSR2` (12) - User-defined signal 2\n\n**Process Control:**\n- `SIGALRM` (14) - Alarm clock timer\n- `SIGCHLD` (17) - Child process status change\n- `SIGCONT` (18) - Continue if stopped\n- `SIGSTOP` (19) - Stop process (cannot be caught)\n- `SIGTSTP` (20) - Terminal stop (Ctrl+Z)\n\n**I/O:**\n- `SIGPIPE` (13) - Broken pipe\n- `SIGTTIN` (21) - Background read from terminal\n- `SIGTTOU` (22) - Background write to terminal\n\n### Basic Signal Handling\n\n**Catch Ctrl+C:**\n```hemlock\nlet interrupted = false;\n\nfn handle_interrupt(sig) {\n    print(\"Caught SIGINT!\");\n    interrupted = true;\n}\n\nsignal(SIGINT, handle_interrupt);\n\n// Program continues running...\n// User presses Ctrl+C -> handle_interrupt() is called\n```\n\n**Handler Arguments:**\nSignal handlers receive one argument: the signal number (i32)\n```hemlock\nfn my_handler(signum) {\n    print(\"Received signal: \" + typeof(signum));\n    // signum contains the signal number (e.g., 2 for SIGINT)\n}\n```\n\n### Multiple Signals\n\nDifferent handlers for different signals:\n```hemlock\nfn handle_int(sig) {\n    print(\"SIGINT received\");\n}\n\nfn handle_term(sig) {\n    print(\"SIGTERM received\");\n}\n\nsignal(SIGINT, handle_int);\nsignal(SIGTERM, handle_term);\n```\n\n### Resetting to Default\n\nPass `null` as the handler to reset to default behavior:\n```hemlock\n// Register custom handler\nsignal(SIGINT, my_handler);\n\n// Later, reset to default (terminate on SIGINT)\nsignal(SIGINT, null);\n```\n\n### Raising Signals\n\nSend signals to your own process:\n```hemlock\nlet count = 0;\n\nfn increment(sig) {\n    count = count + 1;\n}\n\nsignal(SIGUSR1, increment);\n\n// Trigger handler manually\nraise(SIGUSR1);\nraise(SIGUSR1);\n\nprint(count);  // 2\n```\n\n### Graceful Shutdown Pattern\n\nCommon pattern for cleanup on termination:\n```hemlock\nlet should_exit = false;\n\nfn handle_shutdown(sig) {\n    print(\"Shutting down gracefully...\");\n    should_exit = true;\n}\n\nsignal(SIGINT, handle_shutdown);\nsignal(SIGTERM, handle_shutdown);\n\n// Main loop\nwhile (!should_exit) {\n    // Do work...\n    // Check should_exit flag periodically\n}\n\nprint(\"Cleanup complete\");\n```\n\n### Signal Handler Behavior\n\n**Important notes:**\n- Handlers are called **synchronously** when the signal is received\n- Handlers execute in the current process context\n- Signal handlers share the closure environment of the function they're defined in\n- Handlers can access and modify outer scope variables (like globals or captured variables)\n- Keep handlers simple and quick - avoid long-running operations\n\n**What signals can be caught:**\n- Most signals can be caught and handled (SIGINT, SIGTERM, SIGUSR1, etc.)\n- **Cannot catch:** SIGKILL (9), SIGSTOP (19) - these always terminate/stop\n- Some signals have default behaviors that may differ by system\n\n### Safety Considerations\n\nSignal handling is **inherently unsafe** in Hemlock's philosophy:\n- Handlers can be called at any time, interrupting normal execution\n- No async-signal-safety guarantees (handlers can call any Hemlock code)\n- Race conditions are possible if handler modifies shared state\n- The user is responsible for proper synchronization\n\n**Example of potential issues:**\n```hemlock\nlet counter = 0;\n\nfn increment(sig) {\n    counter = counter + 1;  // Race condition if called during counter update\n}\n\nsignal(SIGUSR1, increment);\n\n// Main code also modifies counter\ncounter = counter + 1;  // Could be interrupted by signal handler\n```\n\n**Best practices:**\n- Keep handlers simple and fast\n- Use atomic flags (simple boolean assignments)\n- Avoid complex logic in handlers\n- Be aware that handlers can interrupt any operation\n\n### Complete Example\n\n```hemlock\nlet running = true;\nlet signal_count = 0;\n\nfn handle_signal(signum) {\n    signal_count = signal_count + 1;\n\n    if (signum == SIGINT) {\n        print(\"Interrupt detected (Ctrl+C)\");\n        running = false;\n    }\n\n    if (signum == SIGUSR1) {\n        print(\"User signal 1 received\");\n    }\n}\n\n// Register handlers\nsignal(SIGINT, handle_signal);\nsignal(SIGUSR1, handle_signal);\n\n// Simulate some work\nlet i = 0;\nwhile (running && i < 100) {\n    print(\"Working... \" + typeof(i));\n\n    // Trigger SIGUSR1 every 10 iterations\n    if (i == 10 || i == 20) {\n        raise(SIGUSR1);\n    }\n\n    i = i + 1;\n}\n\nprint(\"Total signals received: \" + typeof(signal_count));\n```\n\n---\n\n## Standard Library\n\nHemlock provides a comprehensive standard library with modules for common programming tasks. All stdlib modules use the `@stdlib/` import prefix and are documented in `stdlib/docs/`.\n\n### Import Syntax\n\n```hemlock\n// Import specific functions\nimport { sin, cos, PI } from \"@stdlib/math\";\nimport { now, sleep } from \"@stdlib/time\";\nimport { read_file, write_file } from \"@stdlib/fs\";\nimport { TcpListener, TcpStream, UdpSocket } from \"@stdlib/net\";\nimport { compile, test } from \"@stdlib/regex\";\n\n// Import all as namespace\nimport * as math from \"@stdlib/math\";\nimport * as fs from \"@stdlib/fs\";\nimport * as net from \"@stdlib/net\";\nimport * as regex from \"@stdlib/regex\";\n\n// Use imported functions\nlet angle = math.PI / 4.0;\nlet x = math.sin(angle);\nlet content = fs.read_file(\"data.txt\");\nlet stream = net.TcpStream(\"example.com\", 80);\nlet valid = regex.test(\"^[a-z]+$\", \"hello\", null);\n```\n\n### Available Modules\n\n#### 1. **Collections** (`@stdlib/collections`) \n**Status:** Production-ready, fully optimized\n\nComprehensive data structures for efficient data manipulation:\n- **HashMap** - O(1) hash table with djb2 algorithm\n- **Queue** - O(1) FIFO with circular buffer\n- **Stack** - O(1) LIFO\n- **Set** - O(1) unique values (HashMap-based)\n- **LinkedList** - O(1) insertion/deletion with bidirectional traversal\n\n```hemlock\nimport { HashMap, Queue, Stack, Set, LinkedList } from \"@stdlib/collections\";\n\nlet map = HashMap();\nmap.set(\"key\", \"value\");\nmap.set(\"count\", 42);\nprint(map.get(\"key\"));  // \"value\"\n\nlet queue = Queue();\nqueue.enqueue(\"first\");\nqueue.enqueue(\"second\");\nprint(queue.dequeue());  // \"first\"\n\nlet set = Set();\nset.add(10);\nset.add(20);\nset.add(10);  // Duplicate ignored\nprint(set.size);  // 2\n```\n\n**Documentation:** `stdlib/docs/collections.md`\n**Features:** All collections support `.each(callback)` iterators, automatic resizing, optimal performance\n\n---\n\n#### 2. **Math** (`@stdlib/math`)\n**Status:** Complete\n\nMathematical functions and constants:\n- **Trigonometry:** sin, cos, tan, asin, acos, atan, atan2\n- **Exponential/Log:** sqrt, pow, exp, log, log10, log2\n- **Rounding:** floor, ceil, round, trunc\n- **Utility:** abs, min, max, clamp\n- **Random:** rand, rand_range, seed\n- **Constants:** PI, E, TAU, INF, NAN\n\n```hemlock\nimport { sin, cos, sqrt, pow, PI } from \"@stdlib/math\";\n\n// Trigonometry\nlet angle = PI / 4.0;\nlet x = cos(angle);  // 0.707...\nlet y = sin(angle);  // 0.707...\n\n// Math operations\nlet dist = sqrt(pow(3.0, 2.0) + pow(4.0, 2.0));  // 5.0\n\n// Random numbers\nimport { rand, rand_range, seed } from \"@stdlib/math\";\nseed(42);  // Reproducible\nlet random = rand();  // 0.0 to 1.0\nlet dice = rand_range(1.0, 7.0);  // 1.0 to 6.999...\n```\n\n**Documentation:** `stdlib/docs/math.md`\n**Notes:** All functions return f64, angles are in radians\n\n---\n\n#### 3. **Time** (`@stdlib/time`)\n**Status:** Basic\n\nTime measurement and delays:\n- `now()` - Unix timestamp in seconds (i64)\n- `time_ms()` - Milliseconds since epoch (i64)\n- `clock()` - CPU time in seconds (f64)\n- `sleep(seconds)` - Pause execution (supports sub-second precision)\n\n```hemlock\nimport { time_ms, sleep, now } from \"@stdlib/time\";\n\n// Benchmark code\nlet start = time_ms();\n// ... do work ...\nlet elapsed = time_ms() - start;\nprint(\"Took \" + typeof(elapsed) + \"ms\");\n\n// Rate limiting\nfn process_items(items: array): null {\n    let i = 0;\n    while (i < items.length) {\n        process(items[i]);\n        sleep(0.1);  // 100ms between items\n        i = i + 1;\n    }\n    return null;\n}\n```\n\n**Documentation:** `stdlib/docs/time.md`\n**Notes:** `sleep()` uses nanosleep() for precision\n\n---\n\n#### 4. **Environment** (`@stdlib/env`)\n**Status:** Complete\n\nEnvironment variables and process control:\n- `getenv(name)` - Read environment variable\n- `setenv(name, value)` - Set environment variable\n- `unsetenv(name)` - Remove environment variable\n- `exit(code?)` - Exit process with status code\n- `get_pid()` - Get process ID\n\n```hemlock\nimport { getenv, setenv, exit, get_pid } from \"@stdlib/env\";\n\n// Configuration from environment\nlet port = getenv(\"PORT\");\nif (port == null) {\n    port = \"8080\";  // Default\n}\n\n// Set environment for child processes\nlet path = getenv(\"PATH\");\nsetenv(\"PATH\", path + \":/usr/local/bin\");\n\n// Process ID\nlet pid = get_pid();\nprint(\"Running as PID: \" + typeof(pid));\n\n// Graceful exit\nif (error_occurred) {\n    exit(1);\n}\n```\n\n**Documentation:** `stdlib/docs/env.md`\n**Notes:** Environment changes affect current process and children only\n\n---\n\n#### 5. **Filesystem** (`@stdlib/fs`)\n**Status:** Comprehensive\n\nFile and directory operations:\n\n**File operations:**\n- `exists(path)` - Check if file/directory exists\n- `read_file(path)` - Read entire file as string\n- `write_file(path, content)` - Write/overwrite file\n- `append_file(path, content)` - Append to file\n- `remove_file(path)` - Delete file\n- `rename(old, new)` - Rename/move file\n- `copy_file(src, dest)` - Copy file\n\n**Directory operations:**\n- `make_dir(path, mode?)` - Create directory\n- `remove_dir(path)` - Remove empty directory\n- `list_dir(path)` - List directory contents\n\n**File information:**\n- `is_file(path)` - Check if regular file\n- `is_dir(path)` - Check if directory\n- `file_stat(path)` - Get file metadata\n\n**Path operations:**\n- `cwd()` - Get current directory\n- `chdir(path)` - Change directory\n- `absolute_path(path)` - Resolve to absolute path\n\n```hemlock\nimport {\n    read_file, write_file, exists,\n    list_dir, is_file, is_dir,\n    copy_file\n} from \"@stdlib/fs\";\n\n// File operations\nif (exists(\"config.json\")) {\n    let config = read_file(\"config.json\");\n    print(\"Config loaded\");\n} else {\n    write_file(\"config.json\", \"{}\");\n}\n\n// Directory listing\nlet files = list_dir(\".\");\nlet i = 0;\nwhile (i < files.length) {\n    if (is_file(files[i])) {\n        print(\"File: \" + files[i]);\n    }\n    i = i + 1;\n}\n\n// Backup\ncopy_file(\"important.txt\", \"important.txt.backup\");\n```\n\n**Documentation:** `stdlib/docs/fs.md`\n**Notes:** All operations throw exceptions on errors (use try/catch)\n\n---\n\n#### 6. **Networking** (`@stdlib/net`)\n**Status:** Complete\n\nTCP/UDP networking with ergonomic wrappers over raw socket builtins:\n- **TcpListener** - TCP server socket for accepting connections\n- **TcpStream** - TCP client/connection with read/write methods\n- **UdpSocket** - UDP datagram socket with send_to/recv_from\n- **DNS:** resolve() - Hostname to IP resolution\n\n```hemlock\nimport { TcpListener, TcpStream, UdpSocket, resolve } from \"@stdlib/net\";\n\n// TCP Server\nlet listener = TcpListener(\"0.0.0.0\", 8080);\ndefer listener.close();\n\nwhile (true) {\n    let stream = listener.accept();\n    spawn(handle_client, stream);\n}\n\n// TCP Client\nlet stream = TcpStream(\"example.com\", 80);\ndefer stream.close();\n\nstream.write(\"GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\");\nlet response = stream.read(4096);\n\n// UDP Socket\nlet sock = UdpSocket(\"0.0.0.0\", 5000);\ndefer sock.close();\n\nlet packet = sock.recv_from(1024);\nsock.send_to(packet.address, packet.port, packet.data);  // Echo\n\n// DNS Resolution\nlet ip = resolve(\"example.com\");  // \"93.184.216.34\"\n```\n\n**Documentation:** `stdlib/docs/net.md`\n**Features:** IPv4 support, async-compatible, manual resource management with defer, exception-based errors\n\n---\n\n#### 7. **Regular Expressions** (`@stdlib/regex`)\n**Status:** Basic (via FFI)\n\nPOSIX Extended Regular Expression pattern matching via FFI to system regex library:\n- `compile(pattern, flags)` - Compile reusable regex object\n- `test(pattern, text, flags)` - One-shot pattern matching\n- `matches()`, `find()` - Convenience aliases\n- Case-insensitive matching with `REG_ICASE` flag\n- Manual memory management (explicit `.free()` required)\n\n```hemlock\nimport { compile, test, REG_ICASE } from \"@stdlib/regex\";\n\n// One-shot matching\nif (test(\"^[a-z]+$\", \"hello\", null)) {\n    print(\"Valid lowercase string\");\n}\n\n// Case-insensitive matching\nif (test(\"^hello\", \"HELLO WORLD\", REG_ICASE)) {\n    print(\"Matches!\");\n}\n\n// Compiled regex for reuse\nlet email_pattern = compile(\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$\", null);\nprint(email_pattern.test(\"user@example.com\"));  // true\nprint(email_pattern.test(\"invalid\"));           // false\nemail_pattern.free();  // Manual cleanup required\n```\n\n**Documentation:** `stdlib/docs/regex.md`\n**Notes:** Uses POSIX ERE syntax, manual memory management required\n\n---\n\n### JSON Serialization\n\nHemlock has built-in JSON support through object/string methods (no separate module needed):\n\n```hemlock\n// Object to JSON\nlet data = { name: \"Alice\", age: 30, active: true };\nlet json = data.serialize();\nprint(json);  // {\"name\":\"Alice\",\"age\":30,\"active\":true}\n\n// JSON to object\nlet json_str = '{\"x\":10,\"y\":20}';\nlet obj = json_str.deserialize();\nprint(obj.x);  // 10\n\n// Nested objects work\nlet nested = { user: { name: \"Bob\" }, items: [1, 2, 3] };\nlet json2 = nested.serialize();\nlet restored = json2.deserialize();\n```\n\n**Features:**\n- Supports objects, arrays, strings, numbers, booleans, null\n- Automatic cycle detection (throws on circular references)\n- No explicit import needed (methods on objects/strings)\n\n---\n\n### Module Organization\n\n```\nstdlib/\n README.md              # Module overview\n collections.hml        # Data structures\n math.hml               # Mathematical functions\n time.hml               # Time/date operations\n env.hml                # Environment variables\n fs.hml                 # Filesystem operations\n net.hml                # Networking (TCP/UDP)\n regex.hml              # Regular expressions (via FFI)\n docs/\n     collections.md     # Collections API reference\n     math.md            # Math API reference\n     time.md            # Time API reference\n     env.md             # Environment API reference\n     fs.md              # Filesystem API reference\n     net.md             # Networking API reference\n     regex.md           # Regex API reference\n```\n\n### Testing\n\nAll stdlib modules have comprehensive test coverage:\n\n```bash\n# Run all tests\nmake test\n\n# Run specific module tests\nmake test | grep stdlib_collections\nmake test | grep stdlib_math\nmake test | grep stdlib_time\nmake test | grep stdlib_env\nmake test | grep stdlib_net\nmake test | grep stdlib_regex\n```\n\n**Test locations:**\n- `tests/stdlib_collections/` - Collections tests\n- `tests/stdlib_math/` - Math tests\n- `tests/stdlib_time/` - Time tests\n- `tests/stdlib_env/` - Environment tests\n- `tests/stdlib_net/` - Networking tests (TCP/UDP)\n- `tests/stdlib_regex/` - Regular expression tests\n\n### Future Stdlib Modules\n\nPlanned additions:\n- **http** - HTTP client/server (building on @stdlib/net) - **IN PROGRESS**\n- **websocket** - WebSocket protocol (building on @stdlib/http) - **IN PROGRESS**\n- **strings** - String utilities (pad, join, is_alpha, reverse, lines, words)\n- **path** - Path manipulation (join, basename, dirname, extname, normalize)\n- **json** - Formalized JSON module (wrapper around serialize/deserialize)\n- **encoding** - Base64, hex, URL encoding/decoding\n- **testing** - Test framework with describe/test/expect/assertions\n- **datetime** - Date/time formatting and parsing\n- **crypto** - Cryptographic functions (via FFI + OpenSSL)\n- **compression** - zlib/gzip compression (via FFI)\n\nSee `stdlib/README.md`, `STDLIB_ANALYSIS_UPDATED.md`, and `STDLIB_NETWORKING_DESIGN.md` for detailed roadmap.\n\n---\n\n## Implementation Details\n\n### Project Structure\n```\nhemlock/\n include/              # Public headers\n    ast.h\n    lexer.h\n    parser.h\n    interpreter.h\n src/                  # Implementation\n    ast.c             # AST node constructors and cleanup\n    lexer.c           # Tokenization\n    parser.c          # Parsing (tokens  AST)\n    main.c            # CLI entry point, REPL\n    interpreter/      # Interpreter subsystem (modular)\n        internal.h        # Internal API shared between modules\n        environment.c     # Variable scoping (121 lines)\n        values.c          # Value constructors, data structures (394 lines)\n        types.c           # Type system, conversions, duck typing (440 lines)\n        builtins.c        # Builtin functions, registration (955 lines)\n        io.c              # File I/O, serialization (449 lines)\n        runtime.c         # eval_expr, eval_stmt, control flow (865 lines)\n tests/                # Test suite, ran by tests/run_tests.sh\n examples/             # Example programs\n```\n\n**Modular Design Benefits:**\n- **Separation of concerns** - Each module has a single, clear responsibility\n- **Faster incremental builds** - Only modified modules recompile\n- **Easier navigation** - Find features quickly by module name\n- **Testable** - Modules can be tested in isolation\n- **Scalable** - New features can be added to specific modules without growing monolithic files\n\n### Compilation Pipeline\n1. **Lexer**  tokens\n2. **Parser**  AST\n3. **Interpreter**  tree-walking execution (current)\n4. **Compiler**  C code generation (future)\n\n### Current Runtime\n- Tree-walking interpreter\n- Tagged union for values (`Value` struct)\n- Environment-based variable storage\n- No optimization yet\n\n### Future Runtime\n- Compile to C code\n- Keep runtime library for dynamic features\n- Optional `--no-tags` flag for fully static builds\n\n---\n\n## Testing Philosophy\n\n- **Test-driven development** for new features\n- Comprehensive test suite in `tests/`\n- Test both success and error cases\n- Run `make test` before committing\n\nExample test structure:\n```bash\ntests/\n primitives/       # Type system tests\n conversions/      # Implicit conversion tests\n memory/           # Pointer/buffer tests\n strings/          # String operation tests\n control/          # Control flow tests\n functions/        # Function and closure tests\n objects/          # Object, method, and serialization tests\n arrays/           # Array operations tests\n loops/            # For, while, break, continue tests\n exceptions/       # Try/catch/finally/throw tests\n io/               # File I/O tests\n args/             # Command-line argument tests\n run_tests.sh      # Test runner\n```\n\n---\n\n## Common Patterns\n\n### Error Handling\n```hemlock\n// Use try/catch for recoverable errors\nfn safe_divide(a, b) {\n    try {\n        if (b == 0) {\n            throw \"division by zero\";\n        }\n        return a / b;\n    } catch (e) {\n        print(\"Error: \" + e);\n        return null;\n    }\n}\n\n// Use finally for cleanup\nfn process_data(filename) {\n    let file = null;\n    try {\n        file = open(filename);\n        // ... process file\n    } finally {\n        if (file != null) {\n            close(file);\n        }\n    }\n}\n```\n\n### Memory Patterns\n```hemlock\n// Pattern: Allocate, use, free\nlet data = alloc(1024);\n// ... use data\nfree(data);\n\n// Pattern: Safe buffer usage\nlet buf = buffer(256);\nlet i = 0;\nwhile (i < buf.length) {\n    buf[i] = i;\n    i = i + 1;\n}\nfree(buf);\n```\n\n### Type Patterns\n```hemlock\n// Pattern: Let types infer when obvious\nlet count = 0;\nlet sum = 0.0;\n\n// Pattern: Annotate when precision matters\nlet byte: u8 = 255;\nlet precise: f64 = 3.14159265359;\n```\n\n---\n\n## What NOT to Do\n\n###  Don't Add Implicit Behavior\n```hemlock\n// BAD: Automatic semicolon insertion\nlet x = 5\nlet y = 10\n\n// BAD: Automatic memory management\nlet s = \"hello\"  // String auto-freed at end of scope? NO!\n\n// BAD: Implicit type conversions that lose precision\nlet x: i32 = 3.14  // Should truncate or error?\n```\n\n###  Don't Hide Complexity\n```hemlock\n// BAD: Magic behind-the-scenes optimization\nlet arr = [1, 2, 3]  // Is this stack or heap? User should know!\n\n// BAD: Automatic reference counting\nlet p = create_thing()  // Does this increment a refcount? NO!\n```\n\n###  Don't Break Existing Semantics\n- Semicolons are mandatory - don't make them optional\n- Manual memory management - don't add GC\n- Mutable strings - don't make them immutable\n- Runtime type checking - don't remove it\n\n---\n\n## Future Considerations\n\n### Maybe Add (Under Discussion)\n- Array/list types (not just buffers) - Note: Basic arrays are implemented\n- Pattern matching\n- Error types (`Result<T, E>`)\n\n### Probably Never Add\n- Garbage collection\n- Automatic memory management\n- Implicit type conversions that lose data\n- Operator overloading (maybe for user types)\n- Macros (too complex)\n\n---\n\n## Philosophy on Safety\n\n**Hemlock's take on safety:**\n\n\"We give you the tools to be safe (`buffer`, type annotations, bounds checking) but we don't force you to use them (`ptr`, manual memory, unsafe operations).\n\nThe default should guide toward safety, but the escape hatch should always be available.\"\n\n**Examples:**\n- Default to `buffer` in docs, but `ptr` exists for FFI\n- Encourage type annotations, but don't require them\n- Provide bounds checking, but allow raw pointer math\n- Include `sizeof()` and typed allocation to reduce errors\n\n---\n\n## Contributing Guidelines (Future)\n\nWhen adding features to Hemlock:\n\n1. **Read this document first**\n2. **Write tests before implementation**\n3. **Keep it explicit** - no magic\n4. **Document the unsafe parts** - be honest\n5. **Follow existing patterns** - consistency matters\n6. **Update CLAUDE.md** - keep this doc current\n\n---\n\n## Version History\n\n- **v0.1** - Primitives, memory management, UTF-8 strings, control flow, functions, closures, recursion, objects, arrays, enums, error handling, file I/O, signal handling, command-line arguments, async/await, structured concurrency, FFI (current)\n  - Type system: i8-i64, u8-u64, f32/f64, bool, string, rune, null, ptr, buffer, array, object, enum, file, task, channel, void\n  - **64-bit integer support:** i64 and u64 types with full type promotion, conversion, and FFI support\n  - **UTF-8 first-class strings:** Full Unicode support (U+0000 to U+10FFFF), codepoint-based indexing and operations, `.length` (codepoints) and `.byte_length` (bytes) properties\n  - **Rune type:** Unicode codepoints as distinct 32-bit type, rune literals with escape sequences and Unicode escapes ('\\u{XXXX}'), string + rune concatenation, integer  rune conversions\n  - Memory: alloc, free, memset, memcpy, realloc, talloc, sizeof\n  - Objects: literals, methods, duck typing, optional fields, serialize/deserialize\n  - **Enums:** C-style enumerations with auto-incrementing or explicit values, type checking, namespace objects\n  - **Strings:** 18 methods including substr, slice, find, contains, split, trim, to_upper, to_lower, starts_with, ends_with, replace, replace_all, repeat, char_at, byte_at, chars, bytes, to_bytes\n  - **Arrays:** 18 methods including push, pop, shift, unshift, insert, remove, find, contains, slice, join, concat, reverse, first, last, clear, **map, filter, reduce** (higher-order functions for functional programming)\n  - Control flow: if/else, while, for, for-in, break, continue, switch, bitwise operators (&, |, ^, <<, >>, ~), **defer**\n  - **Error handling:** try/catch/finally/throw, panic - **all user-facing runtime errors are catchable** (array bounds, type conversions, arity mismatches, stack overflow, async errors)\n  - **File I/O:** File object API with methods (read, read_bytes, write, write_bytes, seek, tell, close) and properties (path, mode, closed)\n  - **Signal Handling:** POSIX signal handling with signal(signum, handler) and raise(signum), 15 signal constants (SIGINT, SIGTERM, SIGUSR1, SIGUSR2, etc.)\n  - Command-line arguments: built-in `args` array\n  - **Async/Concurrency:** async/await syntax, spawn/join/detach (supports both fire-and-forget and spawn-then-detach patterns), channels with send/recv/close, pthread-based true parallelism, exception propagation\n  - **FFI (Foreign Function Interface):** Call C functions from shared libraries using libffi, support for all primitive types, automatic type conversion\n  - **Architecture:** Modular interpreter (environment, values, types, builtins, io, runtime, ffi)\n  - **394 tests** - 369 passing + 25 expected error tests (100% test success rate including async, FFI, i64/u64, signals, defer, map/filter/reduce, edge cases)\n- **v0.2** - Compiler backend, optimization (planned)\n- **v0.3** - Advanced features (planned)\n\n---\n\n## Final Thoughts\n\nHemlock is about **trust and responsibility**. We trust the programmer to:\n- Manage memory correctly\n- Use types appropriately\n- Handle errors properly\n- Understand the tradeoffs\n\nIn return, Hemlock provides:\n- No hidden costs\n- No surprise behavior\n- Full control when needed\n- Safety tools when wanted\n\n**If you're not sure whether a feature fits Hemlock, ask: \"Does this give the programmer more explicit control, or does it hide something?\"**\n\nIf it hides, it probably doesn't belong in Hemlock.\n"}, "Getting Started  Installation": {"id": "getting-started-installation", "content": "# Installation\n\nThis guide will help you build and install Hemlock on your system.\n\n## Prerequisites\n\n### Required Dependencies\n\nHemlock requires the following dependencies to build:\n\n- **C Compiler**: GCC or Clang\n- **Make**: GNU Make\n- **libffi-dev**: Foreign Function Interface library (for FFI support)\n\n### Installing Dependencies\n\n**Ubuntu/Debian:**\n```bash\nsudo apt-get update\nsudo apt-get install build-essential libffi-dev\n```\n\n**Fedora/RHEL:**\n```bash\nsudo dnf install gcc make libffi-devel\n```\n\n**Arch Linux:**\n```bash\nsudo pacman -S base-devel libffi\n```\n\n**macOS:**\n```bash\n# Install Xcode Command Line Tools\nxcode-select --install\n\n# Install libffi via Homebrew\nbrew install libffi\n```\n\n## Building from Source\n\n### 1. Clone the Repository\n\n```bash\ngit clone https://github.com/nbeerbower/hemlock.git\ncd hemlock\n```\n\n### 2. Build Hemlock\n\n```bash\nmake\n```\n\nThis will compile the Hemlock interpreter and place the executable in the current directory.\n\n### 3. Verify Installation\n\n```bash\n./hemlock --version\n```\n\nYou should see the Hemlock version information.\n\n### 4. Test the Build\n\nRun the test suite to ensure everything works correctly:\n\n```bash\nmake test\n```\n\nAll tests should pass. If you see any failures, please report them as an issue.\n\n## Installing System-Wide (Optional)\n\nTo install Hemlock system-wide (e.g., to `/usr/local/bin`):\n\n```bash\nsudo make install\n```\n\nThis allows you to run `hemlock` from anywhere without specifying the full path.\n\n## Running Hemlock\n\n### Interactive REPL\n\nStart the Read-Eval-Print Loop:\n\n```bash\n./hemlock\n```\n\nYou'll see a prompt where you can type Hemlock code:\n\n```\nHemlock REPL\n> print(\"Hello, World!\");\nHello, World!\n> let x = 42;\n> print(x * 2);\n84\n>\n```\n\nExit the REPL with `Ctrl+D` or `Ctrl+C`.\n\n### Running Programs\n\nExecute a Hemlock script:\n\n```bash\n./hemlock program.hml\n```\n\nWith command-line arguments:\n\n```bash\n./hemlock program.hml arg1 arg2 \"argument with spaces\"\n```\n\n## Directory Structure\n\nAfter building, your Hemlock directory will look like this:\n\n```\nhemlock/\n hemlock           # Compiled interpreter executable\n src/              # Source code\n include/          # Header files\n tests/            # Test suite\n examples/         # Example programs\n docs/             # Documentation\n stdlib/           # Standard library\n Makefile          # Build configuration\n README.md         # Project README\n```\n\n## Build Options\n\n### Debug Build\n\nBuild with debug symbols and no optimization:\n\n```bash\nmake debug\n```\n\n### Clean Build\n\nRemove all compiled files:\n\n```bash\nmake clean\n```\n\nRebuild from scratch:\n\n```bash\nmake clean && make\n```\n\n## Troubleshooting\n\n### libffi Not Found\n\nIf you get errors about missing `ffi.h` or `-lffi`:\n\n1. Ensure `libffi-dev` is installed (see dependencies above)\n2. Check if `pkg-config` can find it:\n   ```bash\n   pkg-config --cflags --libs libffi\n   ```\n3. If not found, you may need to set `PKG_CONFIG_PATH`:\n   ```bash\n   export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH\n   ```\n\n### Compilation Errors\n\nIf you encounter compilation errors:\n\n1. Ensure you have a C99-compatible compiler\n2. Try using GCC instead of Clang (or vice versa):\n   ```bash\n   make CC=gcc\n   ```\n3. Check that all dependencies are installed\n\n### Test Failures\n\nIf tests fail:\n\n1. Check that you have the latest version of the code\n2. Try rebuilding from scratch:\n   ```bash\n   make clean && make test\n   ```\n3. Report the issue on GitHub with the test output\n\n## Next Steps\n\n- [Quick Start Guide](quick-start.md) - Write your first Hemlock program\n- [Tutorial](tutorial.md) - Learn Hemlock step-by-step\n- [Language Guide](../language-guide/syntax.md) - Explore Hemlock features\n"}, "Getting Started  Quick Start": {"id": "getting-started-quick-start", "content": "# Quick Start\n\nGet up and running with Hemlock in minutes!\n\n## Your First Program\n\nCreate a file called `hello.hml`:\n\n```hemlock\nprint(\"Hello, Hemlock!\");\n```\n\nRun it:\n\n```bash\n./hemlock hello.hml\n```\n\nOutput:\n```\nHello, Hemlock!\n```\n\n## Basic Syntax\n\n### Variables\n\n```hemlock\n// Variables are declared with 'let'\nlet x = 42;\nlet name = \"Alice\";\nlet pi = 3.14159;\n\n// Type annotations are optional\nlet count: i32 = 100;\nlet ratio: f64 = 0.618;\n```\n\n**Important**: Semicolons are **mandatory** in Hemlock!\n\n### Types\n\nHemlock has a rich type system:\n\n```hemlock\n// Integers\nlet small: i8 = 127;          // 8-bit signed\nlet byte: u8 = 255;           // 8-bit unsigned\nlet num: i32 = 2147483647;    // 32-bit signed (default)\nlet big: i64 = 9223372036854775807;  // 64-bit signed\n\n// Floats\nlet f: f32 = 3.14;            // 32-bit float\nlet d: f64 = 2.71828;         // 64-bit float (default)\n\n// Strings and characters\nlet text: string = \"Hello\";   // UTF-8 string\nlet emoji: rune = '';       // Unicode codepoint\n\n// Boolean and null\nlet flag: bool = true;\nlet empty = null;\n```\n\n### Control Flow\n\n```hemlock\n// If statements\nif (x > 0) {\n    print(\"positive\");\n} else if (x < 0) {\n    print(\"negative\");\n} else {\n    print(\"zero\");\n}\n\n// While loops\nlet i = 0;\nwhile (i < 5) {\n    print(i);\n    i = i + 1;\n}\n\n// For loops\nfor (let j = 0; j < 10; j = j + 1) {\n    print(j);\n}\n```\n\n### Functions\n\n```hemlock\n// Named function\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nlet result = add(5, 3);  // 8\n\n// Anonymous function\nlet multiply = fn(x, y) {\n    return x * y;\n};\n\nprint(multiply(4, 7));  // 28\n```\n\n## Working with Strings\n\nStrings in Hemlock are **mutable** and **UTF-8**:\n\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';              // Now \"Hello\"\nprint(s);\n\n// String methods\nlet upper = s.to_upper();     // \"HELLO\"\nlet words = \"a,b,c\".split(\",\"); // [\"a\", \"b\", \"c\"]\nlet sub = s.substr(1, 3);     // \"ell\"\n\n// Concatenation\nlet greeting = \"Hello\" + \", \" + \"World!\";\nprint(greeting);  // \"Hello, World!\"\n```\n\n## Arrays\n\nDynamic arrays with mixed types:\n\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nprint(numbers[0]);      // 1\nprint(numbers.length);  // 5\n\n// Array methods\nnumbers.push(6);        // [1, 2, 3, 4, 5, 6]\nlet last = numbers.pop();  // 6\nlet slice = numbers.slice(1, 4);  // [2, 3, 4]\n\n// Mixed types allowed\nlet mixed = [1, \"two\", true, null];\n```\n\n## Objects\n\nJavaScript-style objects:\n\n```hemlock\n// Object literal\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"NYC\"\n};\n\nprint(person.name);  // \"Alice\"\nperson.age = 31;     // Modify field\n\n// Methods with 'self'\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    }\n};\n\ncounter.increment();\nprint(counter.count);  // 1\n```\n\n## Memory Management\n\nHemlock uses **manual memory management**:\n\n```hemlock\n// Safe buffer (recommended)\nlet buf = buffer(64);   // Allocate 64 bytes\nbuf[0] = 65;            // Set first byte to 'A'\nprint(buf[0]);          // 65\nfree(buf);              // Free memory\n\n// Raw pointer (advanced)\nlet ptr = alloc(100);\nmemset(ptr, 0, 100);    // Fill with zeros\nfree(ptr);\n```\n\n**Important**: You must `free()` what you `alloc()`!\n\n## Error Handling\n\n```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division by zero\";\n    }\n    return a / b;\n}\n\ntry {\n    let result = divide(10, 0);\n    print(result);\n} catch (e) {\n    print(\"Error: \" + e);\n} finally {\n    print(\"Done\");\n}\n```\n\n## Command-Line Arguments\n\nAccess program arguments via the `args` array:\n\n```hemlock\n// script.hml\nprint(\"Script: \" + args[0]);\nprint(\"Arguments: \" + typeof(args.length - 1));\n\nlet i = 1;\nwhile (i < args.length) {\n    print(\"  arg \" + typeof(i) + \": \" + args[i]);\n    i = i + 1;\n}\n```\n\nRun with:\n```bash\n./hemlock script.hml hello world\n```\n\nOutput:\n```\nScript: script.hml\nArguments: 2\n  arg 1: hello\n  arg 2: world\n```\n\n## File I/O\n\n```hemlock\n// Write to file\nlet f = open(\"data.txt\", \"w\");\nf.write(\"Hello, File!\");\nf.close();\n\n// Read from file\nlet f2 = open(\"data.txt\", \"r\");\nlet content = f2.read();\nprint(content);  // \"Hello, File!\"\nf2.close();\n```\n\n## What's Next?\n\nNow that you've seen the basics, explore more:\n\n- [Tutorial](tutorial.md) - Comprehensive step-by-step guide\n- [Language Guide](../language-guide/syntax.md) - Deep dive into all features\n- [Examples](../../examples/) - Real-world example programs\n- [API Reference](../reference/builtins.md) - Complete API documentation\n\n## Common Pitfalls\n\n### Forgetting Semicolons\n\n```hemlock\n//  ERROR: Missing semicolon\nlet x = 42\nlet y = 10\n\n//  CORRECT\nlet x = 42;\nlet y = 10;\n```\n\n### Forgetting to Free Memory\n\n```hemlock\n//  MEMORY LEAK\nlet buf = buffer(100);\n// ... use buf ...\n// Forgot to call free(buf)!\n\n//  CORRECT\nlet buf = buffer(100);\n// ... use buf ...\nfree(buf);\n```\n\n### Braces Are Required\n\n```hemlock\n//  ERROR: Missing braces\nif (x > 0)\n    print(\"positive\");\n\n//  CORRECT\nif (x > 0) {\n    print(\"positive\");\n}\n```\n\n## Getting Help\n\n- Read the [full documentation](../README.md)\n- Check [examples directory](../../examples/)\n- Look at [test files](../../tests/) for usage patterns\n- Report issues on GitHub\n"}, "Getting Started  Tutorial": {"id": "getting-started-tutorial", "content": "# Hemlock Tutorial\n\nA comprehensive step-by-step guide to learning Hemlock.\n\n## Table of Contents\n\n1. [Hello World](#hello-world)\n2. [Variables and Types](#variables-and-types)\n3. [Arithmetic and Operations](#arithmetic-and-operations)\n4. [Control Flow](#control-flow)\n5. [Functions](#functions)\n6. [Strings and Runes](#strings-and-runes)\n7. [Arrays](#arrays)\n8. [Objects](#objects)\n9. [Memory Management](#memory-management)\n10. [Error Handling](#error-handling)\n11. [File I/O](#file-io)\n12. [Putting It All Together](#putting-it-all-together)\n\n## Hello World\n\nLet's start with the traditional first program:\n\n```hemlock\nprint(\"Hello, World!\");\n```\n\nSave this as `hello.hml` and run:\n\n```bash\n./hemlock hello.hml\n```\n\n**Key Points:**\n- `print()` is a built-in function that outputs to stdout\n- Strings are enclosed in double quotes\n- Semicolons are **mandatory**\n\n## Variables and Types\n\n### Declaring Variables\n\n```hemlock\n// Basic variable declaration\nlet x = 42;\nlet name = \"Alice\";\nlet pi = 3.14159;\n\nprint(x);      // 42\nprint(name);   // Alice\nprint(pi);     // 3.14159\n```\n\n### Type Annotations\n\nWhile types are inferred by default, you can be explicit:\n\n```hemlock\nlet age: i32 = 30;\nlet height: f64 = 5.9;\nlet initial: rune = 'A';\nlet active: bool = true;\n```\n\n### Type Inference\n\nHemlock infers types based on values:\n\n```hemlock\nlet small = 42;              // i32 (fits in 32-bit)\nlet large = 5000000000;      // i64 (too big for i32)\nlet decimal = 3.14;          // f64 (default for floats)\nlet text = \"hello\";          // string\nlet flag = true;             // bool\n```\n\n### Type Checking\n\n```hemlock\n// Check types with typeof()\nprint(typeof(42));        // \"i32\"\nprint(typeof(3.14));      // \"f64\"\nprint(typeof(\"hello\"));   // \"string\"\nprint(typeof(true));      // \"bool\"\nprint(typeof(null));      // \"null\"\n```\n\n## Arithmetic and Operations\n\n### Basic Arithmetic\n\n```hemlock\nlet a = 10;\nlet b = 3;\n\nprint(a + b);   // 13\nprint(a - b);   // 7\nprint(a * b);   // 30\nprint(a / b);   // 3 (integer division)\nprint(a == b);  // false\nprint(a > b);   // true\n```\n\n### Type Promotion\n\nWhen mixing types, Hemlock promotes to the larger/more precise type:\n\n```hemlock\nlet x: i32 = 10;\nlet y: f64 = 3.5;\nlet result = x + y;  // result is f64 (10.0 + 3.5 = 13.5)\n\nprint(result);       // 13.5\nprint(typeof(result)); // \"f64\"\n```\n\n### Bitwise Operations\n\n```hemlock\nlet a = 12;  // 1100 in binary\nlet b = 10;  // 1010 in binary\n\nprint(a & b);   // 8  (AND)\nprint(a | b);   // 14 (OR)\nprint(a ^ b);   // 6  (XOR)\nprint(a << 1);  // 24 (left shift)\nprint(a >> 1);  // 6  (right shift)\nprint(~a);      // -13 (NOT)\n```\n\n## Control Flow\n\n### If Statements\n\n```hemlock\nlet x = 10;\n\nif (x > 0) {\n    print(\"positive\");\n} else if (x < 0) {\n    print(\"negative\");\n} else {\n    print(\"zero\");\n}\n```\n\n**Note:** Braces are **always required**, even for single statements.\n\n### While Loops\n\n```hemlock\nlet count = 0;\nwhile (count < 5) {\n    print(\"Count: \" + typeof(count));\n    count = count + 1;\n}\n```\n\n### For Loops\n\n```hemlock\n// C-style for loop\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n\n// For-in loop (arrays)\nlet items = [10, 20, 30, 40];\nfor (let item in items) {\n    print(\"Item: \" + typeof(item));\n}\n```\n\n### Switch Statements\n\n```hemlock\nlet day = 3;\n\nswitch (day) {\n    case 1:\n        print(\"Monday\");\n        break;\n    case 2:\n        print(\"Tuesday\");\n        break;\n    case 3:\n        print(\"Wednesday\");\n        break;\n    default:\n        print(\"Other day\");\n        break;\n}\n```\n\n### Break and Continue\n\n```hemlock\n// Break: exit loop early\nlet i = 0;\nwhile (i < 10) {\n    if (i == 5) {\n        break;\n    }\n    print(i);\n    i = i + 1;\n}\n// Prints: 0, 1, 2, 3, 4\n\n// Continue: skip to next iteration\nfor (let j = 0; j < 5; j = j + 1) {\n    if (j == 2) {\n        continue;\n    }\n    print(j);\n}\n// Prints: 0, 1, 3, 4\n```\n\n## Functions\n\n### Named Functions\n\n```hemlock\nfn greet(name: string): string {\n    return \"Hello, \" + name + \"!\";\n}\n\nlet message = greet(\"Alice\");\nprint(message);  // \"Hello, Alice!\"\n```\n\n### Anonymous Functions\n\n```hemlock\nlet add = fn(a, b) {\n    return a + b;\n};\n\nprint(add(5, 3));  // 8\n```\n\n### Recursion\n\n```hemlock\nfn factorial(n: i32): i32 {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nprint(factorial(5));  // 120\n```\n\n### Closures\n\nFunctions capture their environment:\n\n```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\nprint(counter());  // 3\n```\n\n### Higher-Order Functions\n\n```hemlock\nfn apply(f, x) {\n    return f(x);\n}\n\nfn double(n) {\n    return n * 2;\n}\n\nlet result = apply(double, 21);\nprint(result);  // 42\n```\n\n## Strings and Runes\n\n### String Basics\n\nStrings are **mutable** and **UTF-8**:\n\n```hemlock\nlet s = \"hello\";\nprint(s.length);      // 5 (character count)\nprint(s.byte_length); // 5 (byte count)\n\n// Mutation\ns[0] = 'H';\nprint(s);  // \"Hello\"\n```\n\n### String Methods\n\n```hemlock\nlet text = \"  Hello, World!  \";\n\n// Case conversion\nprint(text.to_upper());  // \"  HELLO, WORLD!  \"\nprint(text.to_lower());  // \"  hello, world!  \"\n\n// Trimming\nprint(text.trim());      // \"Hello, World!\"\n\n// Substring extraction\nlet hello = text.substr(2, 5);  // \"Hello\"\nlet world = text.slice(9, 14);  // \"World\"\n\n// Searching\nlet pos = text.find(\"World\");   // 9\nlet has = text.contains(\"o\");   // true\n\n// Splitting\nlet parts = \"a,b,c\".split(\",\"); // [\"a\", \"b\", \"c\"]\n\n// Replacement\nlet s = \"hello world\".replace(\"world\", \"there\");\nprint(s);  // \"hello there\"\n```\n\n### Runes (Unicode Codepoints)\n\n```hemlock\nlet ch: rune = 'A';\nlet emoji: rune = '';\n\nprint(ch);      // 'A'\nprint(emoji);   // U+1F680\n\n// Rune + String concatenation\nlet msg = '>' + \" Important\";\nprint(msg);  // \"> Important\"\n\n// Convert between rune and integer\nlet code: i32 = ch;     // 65 (ASCII code)\nlet r: rune = 128640;   // U+1F680 ()\n```\n\n## Arrays\n\n### Array Basics\n\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nprint(numbers[0]);      // 1\nprint(numbers.length);  // 5\n\n// Modify elements\nnumbers[2] = 99;\nprint(numbers[2]);  // 99\n```\n\n### Array Methods\n\n```hemlock\nlet arr = [10, 20, 30];\n\n// Add/remove at end\narr.push(40);           // [10, 20, 30, 40]\nlet last = arr.pop();   // 40, arr is now [10, 20, 30]\n\n// Add/remove at beginning\narr.unshift(5);         // [5, 10, 20, 30]\nlet first = arr.shift(); // 5, arr is now [10, 20, 30]\n\n// Insert/remove at index\narr.insert(1, 15);      // [10, 15, 20, 30]\nlet removed = arr.remove(2);  // 20\n\n// Search\nlet index = arr.find(15);     // 1\nlet has = arr.contains(10);   // true\n\n// Slice\nlet slice = arr.slice(0, 2);  // [10, 15]\n\n// Join to string\nlet text = arr.join(\", \");    // \"10, 15, 30\"\n```\n\n### Iteration\n\n```hemlock\nlet items = [\"apple\", \"banana\", \"cherry\"];\n\n// For-in loop\nfor (let item in items) {\n    print(item);\n}\n\n// Manual iteration\nlet i = 0;\nwhile (i < items.length) {\n    print(items[i]);\n    i = i + 1;\n}\n```\n\n## Objects\n\n### Object Literals\n\n```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"NYC\"\n};\n\nprint(person.name);  // \"Alice\"\nprint(person.age);   // 30\n\n// Add/modify fields\nperson.email = \"alice@example.com\";\nperson.age = 31;\n```\n\n### Methods and `self`\n\n```hemlock\nlet calculator = {\n    value: 0,\n    add: fn(x) {\n        self.value = self.value + x;\n    },\n    get: fn() {\n        return self.value;\n    }\n};\n\ncalculator.add(10);\ncalculator.add(5);\nprint(calculator.get());  // 15\n```\n\n### Type Definitions (Duck Typing)\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,  // Optional with default\n}\n\nlet p = { name: \"Bob\", age: 25 };\nlet typed: Person = p;  // Duck typing validates structure\n\nprint(typeof(typed));   // \"Person\"\nprint(typed.active);    // true (default applied)\n```\n\n### JSON Serialization\n\n```hemlock\nlet obj = { x: 10, y: 20, name: \"test\" };\n\n// Object to JSON\nlet json = obj.serialize();\nprint(json);  // {\"x\":10,\"y\":20,\"name\":\"test\"}\n\n// JSON to Object\nlet restored = json.deserialize();\nprint(restored.name);  // \"test\"\n```\n\n## Memory Management\n\n### Safe Buffers (Recommended)\n\n```hemlock\n// Allocate buffer\nlet buf = buffer(10);\nprint(buf.length);    // 10\nprint(buf.capacity);  // 10\n\n// Set values (bounds-checked)\nbuf[0] = 65;  // 'A'\nbuf[1] = 66;  // 'B'\nbuf[2] = 67;  // 'C'\n\n// Access values\nprint(buf[0]);  // 65\n\n// Must free when done\nfree(buf);\n```\n\n### Raw Pointers (Advanced)\n\n```hemlock\n// Allocate raw memory\nlet ptr = alloc(100);\n\n// Fill with zeros\nmemset(ptr, 0, 100);\n\n// Copy data\nlet src = alloc(50);\nmemcpy(ptr, src, 50);\n\n// Free both\nfree(src);\nfree(ptr);\n```\n\n### Memory Functions\n\n```hemlock\n// Reallocate\nlet p = alloc(64);\np = realloc(p, 128);  // Resize to 128 bytes\nfree(p);\n\n// Typed allocation (future)\n// let arr = talloc(i32, 100);  // Array of 100 i32s\n```\n\n## Error Handling\n\n### Try/Catch\n\n```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division by zero\";\n    }\n    return a / b;\n}\n\ntry {\n    let result = divide(10, 0);\n    print(result);\n} catch (e) {\n    print(\"Error: \" + e);\n}\n// Output: Error: division by zero\n```\n\n### Finally Block\n\n```hemlock\nlet file = null;\n\ntry {\n    file = open(\"data.txt\", \"r\");\n    let content = file.read();\n    print(content);\n} catch (e) {\n    print(\"Error: \" + e);\n} finally {\n    // Always runs\n    if (file != null) {\n        file.close();\n    }\n}\n```\n\n### Throwing Objects\n\n```hemlock\ntry {\n    throw { code: 404, message: \"Not found\" };\n} catch (e) {\n    print(\"Error \" + typeof(e.code) + \": \" + e.message);\n}\n// Output: Error 404: Not found\n```\n\n### Panic (Unrecoverable Errors)\n\n```hemlock\nfn validate(x) {\n    if (x < 0) {\n        panic(\"x must be non-negative\");\n    }\n    return x * 2;\n}\n\nvalidate(-5);  // Program exits with: panic: x must be non-negative\n```\n\n## File I/O\n\n### Reading Files\n\n```hemlock\n// Read entire file\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nprint(content);\nf.close();\n\n// Read specific number of bytes\nlet f2 = open(\"data.txt\", \"r\");\nlet chunk = f2.read(100);  // Read 100 bytes\nf2.close();\n```\n\n### Writing Files\n\n```hemlock\n// Write text\nlet f = open(\"output.txt\", \"w\");\nf.write(\"Hello, File!\\n\");\nf.write(\"Second line\\n\");\nf.close();\n\n// Append to file\nlet f2 = open(\"output.txt\", \"a\");\nf2.write(\"Appended line\\n\");\nf2.close();\n```\n\n### Binary I/O\n\n```hemlock\n// Write binary data\nlet buf = buffer(256);\nbuf[0] = 255;\nbuf[1] = 128;\n\nlet f = open(\"data.bin\", \"w\");\nf.write_bytes(buf);\nf.close();\n\n// Read binary data\nlet f2 = open(\"data.bin\", \"r\");\nlet data = f2.read_bytes(256);\nprint(data[0]);  // 255\nf2.close();\n\nfree(buf);\nfree(data);\n```\n\n### File Properties\n\n```hemlock\nlet f = open(\"/path/to/file.txt\", \"r\");\n\nprint(f.path);    // \"/path/to/file.txt\"\nprint(f.mode);    // \"r\"\nprint(f.closed);  // false\n\nf.close();\nprint(f.closed);  // true\n```\n\n## Putting It All Together\n\nLet's build a simple word counter program:\n\n```hemlock\n// wordcount.hml - Count words in a file\n\nfn count_words(filename: string): i32 {\n    let file = null;\n    let count = 0;\n\n    try {\n        file = open(filename, \"r\");\n        let content = file.read();\n\n        // Split by whitespace and count\n        let words = content.split(\" \");\n        count = words.length;\n\n    } catch (e) {\n        print(\"Error reading file: \" + e);\n        return -1;\n    } finally {\n        if (file != null) {\n            file.close();\n        }\n    }\n\n    return count;\n}\n\n// Main program\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <filename>\");\n} else {\n    let filename = args[1];\n    let words = count_words(filename);\n\n    if (words >= 0) {\n        print(\"Word count: \" + typeof(words));\n    }\n}\n```\n\nRun with:\n```bash\n./hemlock wordcount.hml data.txt\n```\n\n## Next Steps\n\nCongratulations! You've learned the basics of Hemlock. Here's what to explore next:\n\n- [Async & Concurrency](../advanced/async-concurrency.md) - True multi-threading\n- [FFI](../advanced/ffi.md) - Call C functions\n- [Signal Handling](../advanced/signals.md) - Process signals\n- [API Reference](../reference/builtins.md) - Complete API docs\n- [Examples](../../examples/) - More real-world programs\n\n## Practice Exercises\n\nTry building these programs to practice:\n\n1. **Calculator**: Implement a simple calculator with +, -, *, /\n2. **File Copy**: Copy one file to another\n3. **Fibonacci**: Generate Fibonacci numbers\n4. **JSON Parser**: Read and parse JSON files\n5. **Text Processor**: Find and replace text in files\n\nHappy coding with Hemlock! \n"}, "Language Guide  Arrays": {"id": "language-guide-arrays", "content": "# Arrays\n\nHemlock provides **dynamic arrays** with comprehensive methods for data manipulation and processing. Arrays can hold mixed types and grow automatically as needed.\n\n## Overview\n\n```hemlock\n// Array literals\nlet arr = [1, 2, 3, 4, 5];\nprint(arr[0]);         // 1\nprint(arr.length);     // 5\n\n// Mixed types allowed\nlet mixed = [1, \"hello\", true, null];\n\n// Dynamic sizing\narr.push(6);           // Grows automatically\narr.push(7);\nprint(arr.length);     // 7\n```\n\n## Array Literals\n\n### Basic Syntax\n\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nlet strings = [\"apple\", \"banana\", \"cherry\"];\nlet booleans = [true, false, true];\n```\n\n### Empty Arrays\n\n```hemlock\nlet arr = [];  // Empty array\n\n// Add elements later\narr.push(1);\narr.push(2);\narr.push(3);\n```\n\n### Mixed Types\n\nArrays can contain different types:\n\n```hemlock\nlet mixed = [\n    42,\n    \"hello\",\n    true,\n    null,\n    [1, 2, 3],\n    { x: 10, y: 20 }\n];\n\nprint(mixed[0]);  // 42\nprint(mixed[1]);  // \"hello\"\nprint(mixed[4]);  // [1, 2, 3] (nested array)\n```\n\n### Nested Arrays\n\n```hemlock\nlet matrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n];\n\nprint(matrix[0][0]);  // 1\nprint(matrix[1][2]);  // 6\nprint(matrix[2][1]);  // 8\n```\n\n## Indexing\n\n### Reading Elements\n\nZero-indexed access:\n\n```hemlock\nlet arr = [10, 20, 30, 40, 50];\n\nprint(arr[0]);  // 10 (first element)\nprint(arr[4]);  // 50 (last element)\n\n// Out of bounds returns null (no error)\nprint(arr[10]);  // null\n```\n\n### Writing Elements\n\n```hemlock\nlet arr = [1, 2, 3];\n\narr[0] = 10;    // Modify existing\narr[1] = 20;\nprint(arr);     // [10, 20, 3]\n\n// Can assign beyond current length (grows array)\narr[5] = 60;    // Creates [10, 20, 3, null, null, 60]\n```\n\n### Negative Indices\n\n**Not supported** - Use positive indices only:\n\n```hemlock\nlet arr = [1, 2, 3];\nprint(arr[-1]);  // ERROR or undefined behavior\n\n// Use length for last element\nprint(arr[arr.length - 1]);  // 3\n```\n\n## Properties\n\n### `.length` Property\n\nReturns the number of elements:\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr.length);  // 5\n\n// Empty array\nlet empty = [];\nprint(empty.length);  // 0\n\n// After modifications\narr.push(6);\nprint(arr.length);  // 6\n```\n\n## Array Methods\n\nHemlock provides 15 array methods for comprehensive manipulation.\n\n### Stack Operations\n\n**`push(value)`** - Add element to end:\n```hemlock\nlet arr = [1, 2, 3];\narr.push(4);           // [1, 2, 3, 4]\narr.push(5);           // [1, 2, 3, 4, 5]\n\nprint(arr.length);     // 5\n```\n\n**`pop()`** - Remove and return last element:\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet last = arr.pop();  // Returns 5, arr is now [1, 2, 3, 4]\n\nprint(last);           // 5\nprint(arr.length);     // 4\n```\n\n### Queue Operations\n\n**`shift()`** - Remove and return first element:\n```hemlock\nlet arr = [1, 2, 3];\nlet first = arr.shift();   // Returns 1, arr is now [2, 3]\n\nprint(first);              // 1\nprint(arr);                // [2, 3]\n```\n\n**`unshift(value)`** - Add element to beginning:\n```hemlock\nlet arr = [2, 3];\narr.unshift(1);            // [1, 2, 3]\narr.unshift(0);            // [0, 1, 2, 3]\n```\n\n### Insertion and Removal\n\n**`insert(index, value)`** - Insert element at index:\n```hemlock\nlet arr = [1, 2, 4, 5];\narr.insert(2, 3);      // Insert 3 at index 2: [1, 2, 3, 4, 5]\n\narr.insert(0, 0);      // Insert at beginning: [0, 1, 2, 3, 4, 5]\n```\n\n**`remove(index)`** - Remove and return element at index:\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet removed = arr.remove(2);  // Returns 3, arr is now [1, 2, 4, 5]\n\nprint(removed);               // 3\nprint(arr);                   // [1, 2, 4, 5]\n```\n\n### Search Operations\n\n**`find(value)`** - Find first occurrence:\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet idx = arr.find(30);      // 2 (index of first occurrence)\nlet idx2 = arr.find(99);     // -1 (not found)\n\n// Works with any type\nlet words = [\"apple\", \"banana\", \"cherry\"];\nlet idx3 = words.find(\"banana\");  // 1\n```\n\n**`contains(value)`** - Check if array contains value:\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet has = arr.contains(20);  // true\nlet has2 = arr.contains(99); // false\n```\n\n### Extraction Operations\n\n**`slice(start, end)`** - Extract subarray (end exclusive):\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet sub = arr.slice(1, 4);   // [2, 3, 4] (indices 1, 2, 3)\nlet first = arr.slice(0, 2); // [1, 2]\n\n// Original unchanged\nprint(arr);                  // [1, 2, 3, 4, 5]\n```\n\n**`first()`** - Get first element (without removing):\n```hemlock\nlet arr = [1, 2, 3];\nlet f = arr.first();         // 1 (without removing)\nprint(arr);                  // [1, 2, 3] (unchanged)\n```\n\n**`last()`** - Get last element (without removing):\n```hemlock\nlet arr = [1, 2, 3];\nlet l = arr.last();          // 3 (without removing)\nprint(arr);                  // [1, 2, 3] (unchanged)\n```\n\n### Transformation Operations\n\n**`reverse()`** - Reverse array in-place:\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.reverse();               // [5, 4, 3, 2, 1]\n\nprint(arr);                  // [5, 4, 3, 2, 1] (modified)\n```\n\n**`join(delimiter)`** - Join elements into string:\n```hemlock\nlet words = [\"hello\", \"world\", \"foo\"];\nlet joined = words.join(\" \");  // \"hello world foo\"\n\nlet numbers = [1, 2, 3];\nlet csv = numbers.join(\",\");   // \"1,2,3\"\n\n// Works with mixed types\nlet mixed = [1, \"hello\", true, null];\nprint(mixed.join(\" | \"));  // \"1 | hello | true | null\"\n```\n\n**`concat(other)`** - Concatenate with another array:\n```hemlock\nlet a = [1, 2, 3];\nlet b = [4, 5, 6];\nlet combined = a.concat(b);  // [1, 2, 3, 4, 5, 6] (new array)\n\n// Originals unchanged\nprint(a);                    // [1, 2, 3]\nprint(b);                    // [4, 5, 6]\n```\n\n### Utility Operations\n\n**`clear()`** - Remove all elements:\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.clear();                 // []\n\nprint(arr.length);           // 0\nprint(arr);                  // []\n```\n\n## Method Chaining\n\nMethods that return arrays or values enable chaining:\n\n```hemlock\nlet result = [1, 2, 3]\n    .concat([4, 5, 6])\n    .slice(2, 5);  // [3, 4, 5]\n\nlet text = [\"apple\", \"banana\", \"cherry\"]\n    .slice(0, 2)\n    .join(\" and \");  // \"apple and banana\"\n\nlet numbers = [5, 3, 8, 1, 9]\n    .slice(1, 4)\n    .concat([10, 11]);  // [3, 8, 1, 10, 11]\n```\n\n## Complete Method Reference\n\n| Method | Parameters | Returns | Mutates | Description |\n|--------|-----------|---------|---------|-------------|\n| `push(value)` | any | void | Yes | Add element to end |\n| `pop()` | - | any | Yes | Remove and return last |\n| `shift()` | - | any | Yes | Remove and return first |\n| `unshift(value)` | any | void | Yes | Add element to beginning |\n| `insert(index, value)` | i32, any | void | Yes | Insert at index |\n| `remove(index)` | i32 | any | Yes | Remove and return at index |\n| `find(value)` | any | i32 | No | Find first occurrence (-1 if not found) |\n| `contains(value)` | any | bool | No | Check if contains value |\n| `slice(start, end)` | i32, i32 | array | No | Extract subarray (new array) |\n| `join(delimiter)` | string | string | No | Join into string |\n| `concat(other)` | array | array | No | Concatenate (new array) |\n| `reverse()` | - | void | Yes | Reverse in-place |\n| `first()` | - | any | No | Get first element |\n| `last()` | - | any | No | Get last element |\n| `clear()` | - | void | Yes | Remove all elements |\n\n## Implementation Details\n\n### Memory Model\n\n- **Heap-allocated** - Dynamic capacity\n- **Automatic growth** - Doubles capacity when exceeded\n- **No automatic shrinking** - Capacity doesn't decrease\n- **No bounds checking on indexing** - Use methods for safety\n\n### Capacity Management\n\n```hemlock\nlet arr = [];  // Initial capacity: 0\n\narr.push(1);   // Grows to capacity 1\narr.push(2);   // Grows to capacity 2\narr.push(3);   // Grows to capacity 4 (doubles)\narr.push(4);   // Still capacity 4\narr.push(5);   // Grows to capacity 8 (doubles)\n```\n\n### Value Comparison\n\n`find()` and `contains()` use value equality:\n\n```hemlock\n// Primitives: compare by value\nlet arr = [1, 2, 3];\narr.contains(2);  // true\n\n// Strings: compare by value\nlet words = [\"hello\", \"world\"];\nwords.contains(\"hello\");  // true\n\n// Objects: compare by reference\nlet obj1 = { x: 10 };\nlet obj2 = { x: 10 };\nlet arr2 = [obj1];\narr2.contains(obj1);  // true (same reference)\narr2.contains(obj2);  // false (different reference)\n```\n\n## Common Patterns\n\n### Pattern: Map (Transform)\n\n```hemlock\nfn map(arr, f) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        result.push(f(arr[i]));\n        i = i + 1;\n    }\n    return result;\n}\n\nfn double(x) { return x * 2; }\n\nlet numbers = [1, 2, 3, 4, 5];\nlet doubled = map(numbers, double);  // [2, 4, 6, 8, 10]\n```\n\n### Pattern: Filter\n\n```hemlock\nfn filter(arr, predicate) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        if (predicate(arr[i])) {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nfn is_even(x) { return x % 2 == 0; }\n\nlet numbers = [1, 2, 3, 4, 5, 6];\nlet evens = filter(numbers, is_even);  // [2, 4, 6]\n```\n\n### Pattern: Reduce (Fold)\n\n```hemlock\nfn reduce(arr, f, initial) {\n    let accumulator = initial;\n    let i = 0;\n    while (i < arr.length) {\n        accumulator = f(accumulator, arr[i]);\n        i = i + 1;\n    }\n    return accumulator;\n}\n\nfn add(a, b) { return a + b; }\n\nlet numbers = [1, 2, 3, 4, 5];\nlet sum = reduce(numbers, add, 0);  // 15\n```\n\n### Pattern: Array as Stack\n\n```hemlock\nlet stack = [];\n\n// Push onto stack\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\n// Pop from stack\nlet top = stack.pop();    // 3\nlet next = stack.pop();   // 2\n```\n\n### Pattern: Array as Queue\n\n```hemlock\nlet queue = [];\n\n// Enqueue (add to end)\nqueue.push(1);\nqueue.push(2);\nqueue.push(3);\n\n// Dequeue (remove from front)\nlet first = queue.shift();   // 1\nlet second = queue.shift();  // 2\n```\n\n## Best Practices\n\n1. **Use methods over direct indexing** - Bounds checking and clarity\n2. **Check bounds** - Direct indexing doesn't bounds-check\n3. **Prefer immutable operations** - Use `slice()` and `concat()` over mutation\n4. **Initialize with capacity** - If you know the size (not currently supported)\n5. **Use `contains()` for membership** - Clearer than manual loops\n6. **Chain methods** - More readable than nested calls\n\n## Common Pitfalls\n\n### Pitfall: Direct Index Out of Bounds\n\n```hemlock\nlet arr = [1, 2, 3];\n\n// No bounds checking!\narr[10] = 99;  // Creates sparse array with nulls\nprint(arr.length);  // 11 (not 3!)\n\n// Better: Use push() or check length\nif (arr.length <= 10) {\n    arr.push(99);\n}\n```\n\n### Pitfall: Mutation vs. New Array\n\n```hemlock\nlet arr = [1, 2, 3];\n\n// Mutates original\narr.reverse();\nprint(arr);  // [3, 2, 1]\n\n// Returns new array\nlet sub = arr.slice(0, 2);\nprint(arr);  // [3, 2, 1] (unchanged)\nprint(sub);  // [3, 2]\n```\n\n### Pitfall: Reference Equality\n\n```hemlock\nlet obj = { x: 10 };\nlet arr = [obj];\n\n// Same reference: true\narr.contains(obj);  // true\n\n// Different reference: false\narr.contains({ x: 10 });  // false (different object)\n```\n\n### Pitfall: Memory Leaks\n\n```hemlock\n// Arrays are never freed in v0.1\nfn create_large_array() {\n    let arr = [];\n    let i = 0;\n    while (i < 1000000) {\n        arr.push(i);\n        i = i + 1;\n    }\n    // arr never freed - memory leak\n}\n\ncreate_large_array();  // Leaks memory\n```\n\n## Examples\n\n### Example: Array Statistics\n\n```hemlock\nfn mean(arr) {\n    let sum = 0;\n    let i = 0;\n    while (i < arr.length) {\n        sum = sum + arr[i];\n        i = i + 1;\n    }\n    return sum / arr.length;\n}\n\nfn max(arr) {\n    if (arr.length == 0) {\n        return null;\n    }\n\n    let max_val = arr[0];\n    let i = 1;\n    while (i < arr.length) {\n        if (arr[i] > max_val) {\n            max_val = arr[i];\n        }\n        i = i + 1;\n    }\n    return max_val;\n}\n\nlet numbers = [3, 7, 2, 9, 1];\nprint(mean(numbers));  // 4.4\nprint(max(numbers));   // 9\n```\n\n### Example: Array Deduplication\n\n```hemlock\nfn unique(arr) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        if (!result.contains(arr[i])) {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nlet numbers = [1, 2, 2, 3, 1, 4, 3, 5];\nlet uniq = unique(numbers);  // [1, 2, 3, 4, 5]\n```\n\n### Example: Array Chunking\n\n```hemlock\nfn chunk(arr, size) {\n    let result = [];\n    let i = 0;\n\n    while (i < arr.length) {\n        let chunk = arr.slice(i, i + size);\n        result.push(chunk);\n        i = i + size;\n    }\n\n    return result;\n}\n\nlet numbers = [1, 2, 3, 4, 5, 6, 7, 8];\nlet chunks = chunk(numbers, 3);\n// [[1, 2, 3], [4, 5, 6], [7, 8]]\n```\n\n### Example: Array Flattening\n\n```hemlock\nfn flatten(arr) {\n    let result = [];\n    let i = 0;\n\n    while (i < arr.length) {\n        if (typeof(arr[i]) == \"array\") {\n            // Nested array - flatten it\n            let nested = flatten(arr[i]);\n            let j = 0;\n            while (j < nested.length) {\n                result.push(nested[j]);\n                j = j + 1;\n            }\n        } else {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n\n    return result;\n}\n\nlet nested = [1, [2, 3], [4, [5, 6]], 7];\nlet flat = flatten(nested);  // [1, 2, 3, 4, 5, 6, 7]\n```\n\n### Example: Sorting (Bubble Sort)\n\n```hemlock\nfn sort(arr) {\n    let n = arr.length;\n    let i = 0;\n\n    while (i < n) {\n        let j = 0;\n        while (j < n - i - 1) {\n            if (arr[j] > arr[j + 1]) {\n                // Swap\n                let temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n            j = j + 1;\n        }\n        i = i + 1;\n    }\n}\n\nlet numbers = [5, 2, 8, 1, 9];\nsort(numbers);  // Modifies in-place\nprint(numbers);  // [1, 2, 5, 8, 9]\n```\n\n## Limitations (v0.1)\n\nCurrent limitations:\n\n- **No reference counting** - Arrays never freed automatically\n- **No bounds checking on indexing** - Direct access is unchecked\n- **Reference equality for objects** - `find()` and `contains()` use reference comparison\n- **No built-in sort** - Must implement manually\n- **No map/filter/reduce** - Must implement as functions\n- **No array destructuring** - No `let [a, b] = arr` syntax\n- **No spread operator** - No `[...arr1, ...arr2]` syntax\n\n## Related Topics\n\n- [Strings](strings.md) - String methods similar to array methods\n- [Objects](objects.md) - Arrays are also object-like\n- [Functions](functions.md) - Higher-order functions with arrays\n- [Control Flow](control-flow.md) - Iterating over arrays\n\n## See Also\n\n- **Dynamic Sizing**: Arrays grow automatically with capacity doubling\n- **Methods**: 15 comprehensive methods for manipulation\n- **Memory**: See [Memory](memory.md) for array allocation details\n"}, "Language Guide  Control Flow": {"id": "language-guide-control-flow", "content": "# Control Flow\n\nHemlock provides familiar C-style control flow with mandatory braces and explicit syntax. This guide covers conditionals, loops, switch statements, and operators.\n\n## Overview\n\nAvailable control flow features:\n\n- `if`/`else`/`else if` - Conditional branches\n- `while` loops - Condition-based iteration\n- `for` loops - C-style and for-in iteration\n- `switch` statements - Multi-way branching\n- `break`/`continue` - Loop control\n- Boolean operators: `&&`, `||`, `!`\n- Comparison operators: `==`, `!=`, `<`, `>`, `<=`, `>=`\n- Bitwise operators: `&`, `|`, `^`, `<<`, `>>`, `~`\n\n## If Statements\n\n### Basic If/Else\n\n```hemlock\nif (x > 10) {\n    print(\"large\");\n} else {\n    print(\"small\");\n}\n```\n\n**Rules:**\n- Braces are **always required** for all branches\n- Conditions must be enclosed in parentheses\n- No optional braces (unlike C)\n\n### If Without Else\n\n```hemlock\nif (x > 0) {\n    print(\"positive\");\n}\n// No else branch needed\n```\n\n### Else-If Chains\n\n```hemlock\nif (x > 100) {\n    print(\"very large\");\n} else if (x > 50) {\n    print(\"large\");\n} else if (x > 10) {\n    print(\"medium\");\n} else {\n    print(\"small\");\n}\n```\n\n**Note:** `else if` is syntactic sugar for nested if statements. These are equivalent:\n\n```hemlock\n// else if (syntactic sugar)\nif (a) {\n    foo();\n} else if (b) {\n    bar();\n}\n\n// Equivalent nested if\nif (a) {\n    foo();\n} else {\n    if (b) {\n        bar();\n    }\n}\n```\n\n### Nested If Statements\n\n```hemlock\nif (x > 0) {\n    if (x < 10) {\n        print(\"single digit positive\");\n    } else {\n        print(\"multi-digit positive\");\n    }\n} else {\n    print(\"non-positive\");\n}\n```\n\n## While Loops\n\nCondition-based iteration:\n\n```hemlock\nlet i = 0;\nwhile (i < 10) {\n    print(i);\n    i = i + 1;\n}\n```\n\n**Infinite loops:**\n```hemlock\nwhile (true) {\n    // ... do work\n    if (should_exit) {\n        break;\n    }\n}\n```\n\n## For Loops\n\n### C-Style For\n\nClassic three-part for loop:\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n```\n\n**Components:**\n- **Initializer**: `let i = 0` - Runs once before loop\n- **Condition**: `i < 10` - Checked before each iteration\n- **Update**: `i = i + 1` - Runs after each iteration\n\n**Scope:**\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n// i not accessible here (loop-scoped)\n```\n\n### For-In Loops\n\nIterate over array elements:\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nfor (let item in arr) {\n    print(item);  // Prints each element\n}\n```\n\n**With index and value:**\n```hemlock\nlet arr = [\"a\", \"b\", \"c\"];\nfor (let i = 0; i < arr.length; i = i + 1) {\n    print(\"Index: \" + typeof(i) + \", Value: \" + arr[i]);\n}\n```\n\n## Switch Statements\n\nMulti-way branching based on value:\n\n### Basic Switch\n\n```hemlock\nlet x = 2;\n\nswitch (x) {\n    case 1:\n        print(\"one\");\n        break;\n    case 2:\n        print(\"two\");\n        break;\n    case 3:\n        print(\"three\");\n        break;\n}\n```\n\n### Switch with Default\n\n```hemlock\nlet color = \"blue\";\n\nswitch (color) {\n    case \"red\":\n        print(\"stop\");\n        break;\n    case \"yellow\":\n        print(\"slow\");\n        break;\n    case \"green\":\n        print(\"go\");\n        break;\n    default:\n        print(\"unknown color\");\n        break;\n}\n```\n\n**Rules:**\n- `default` matches when no other case matches\n- `default` can appear anywhere in the switch body\n- Only one default case allowed\n\n### Fall-Through Behavior\n\nCases without `break` fall through to the next case (C-style):\n\n```hemlock\nlet grade = 85;\n\nswitch (grade) {\n    case 100:\n    case 95:\n    case 90:\n        print(\"A\");\n        break;\n    case 85:\n    case 80:\n        print(\"B\");\n        break;\n    default:\n        print(\"C or below\");\n        break;\n}\n```\n\n### Switch with Return\n\nIn functions, `return` exits the switch immediately:\n\n```hemlock\nfn get_day_name(day: i32): string {\n    switch (day) {\n        case 1:\n            return \"Monday\";\n        case 2:\n            return \"Tuesday\";\n        case 3:\n            return \"Wednesday\";\n        default:\n            return \"Unknown\";\n    }\n}\n```\n\n### Switch Value Types\n\nSwitch works with any value type:\n\n```hemlock\n// Integers\nswitch (count) {\n    case 0: print(\"zero\"); break;\n    case 1: print(\"one\"); break;\n}\n\n// Strings\nswitch (name) {\n    case \"Alice\": print(\"A\"); break;\n    case \"Bob\": print(\"B\"); break;\n}\n\n// Booleans\nswitch (flag) {\n    case true: print(\"on\"); break;\n    case false: print(\"off\"); break;\n}\n```\n\n**Note:** Cases are compared using value equality.\n\n## Break and Continue\n\n### Break\n\nExit the innermost loop or switch:\n\n```hemlock\n// In loops\nlet i = 0;\nwhile (true) {\n    if (i >= 10) {\n        break;  // Exit loop\n    }\n    print(i);\n    i = i + 1;\n}\n\n// In switch\nswitch (x) {\n    case 1:\n        print(\"one\");\n        break;  // Exit switch\n    case 2:\n        print(\"two\");\n        break;\n}\n```\n\n### Continue\n\nSkip to next iteration of loop:\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        continue;  // Skip iteration when i is 5\n    }\n    print(i);  // Prints 0,1,2,3,4,6,7,8,9\n}\n```\n\n**Difference:**\n- `break` - Exits loop entirely\n- `continue` - Skips to next iteration\n\n## Boolean Operators\n\n### Logical AND (`&&`)\n\nBoth conditions must be true:\n\n```hemlock\nif (x > 0 && x < 10) {\n    print(\"single digit positive\");\n}\n```\n\n**Short-circuit evaluation:**\n```hemlock\nif (false && expensive_check()) {\n    // expensive_check() never called\n}\n```\n\n### Logical OR (`||`)\n\nAt least one condition must be true:\n\n```hemlock\nif (x < 0 || x > 100) {\n    print(\"out of range\");\n}\n```\n\n**Short-circuit evaluation:**\n```hemlock\nif (true || expensive_check()) {\n    // expensive_check() never called\n}\n```\n\n### Logical NOT (`!`)\n\nNegates boolean value:\n\n```hemlock\nif (!is_valid) {\n    print(\"invalid\");\n}\n\nif (!(x > 10)) {\n    // Same as: if (x <= 10)\n}\n```\n\n## Comparison Operators\n\n### Equality\n\n```hemlock\nif (x == 10) { }    // Equal\nif (x != 10) { }    // Not equal\n```\n\nWorks with all types:\n```hemlock\n\"hello\" == \"hello\"  // true\ntrue == false       // false\nnull == null        // true\n```\n\n### Relational\n\n```hemlock\nif (x < 10) { }     // Less than\nif (x > 10) { }     // Greater than\nif (x <= 10) { }    // Less than or equal\nif (x >= 10) { }    // Greater than or equal\n```\n\n**Type promotion applies:**\n```hemlock\nlet a: i32 = 10;\nlet b: i64 = 10;\nif (a == b) { }     // true (i32 promoted to i64)\n```\n\n## Bitwise Operators\n\nHemlock provides bitwise operators for integer manipulation. These work **only with integer types** (i8-i64, u8-u64).\n\n### Binary Bitwise Operators\n\n**Bitwise AND (`&`)**\n```hemlock\nlet a = 12;  // 1100 in binary\nlet b = 10;  // 1010 in binary\nprint(a & b);   // 8 (1000)\n```\n\n**Bitwise OR (`|`)**\n```hemlock\nprint(a | b);   // 14 (1110)\n```\n\n**Bitwise XOR (`^`)**\n```hemlock\nprint(a ^ b);   // 6 (0110)\n```\n\n**Left Shift (`<<`)**\n```hemlock\nprint(a << 2);  // 48 (110000) - shift left by 2\n```\n\n**Right Shift (`>>`)**\n```hemlock\nprint(a >> 1);  // 6 (110) - shift right by 1\n```\n\n### Unary Bitwise Operator\n\n**Bitwise NOT (`~`)**\n```hemlock\nlet a = 12;\nprint(~a);      // -13 (two's complement)\n\nlet c: u8 = 15;   // 00001111 in binary\nprint(~c);        // 240 (11110000) in u8\n```\n\n### Bitwise Examples\n\n**With unsigned types:**\n```hemlock\nlet c: u8 = 15;   // 00001111 in binary\nlet d: u8 = 7;    // 00000111 in binary\n\nprint(c & d);     // 7  (00000111)\nprint(c | d);     // 15 (00001111)\nprint(c ^ d);     // 8  (00001000)\nprint(~c);        // 240 (11110000) - in u8\n```\n\n**Type preservation:**\n```hemlock\n// Bitwise operations preserve the type of operands\nlet x: u8 = 255;\nlet result = ~x;  // result is u8 with value 0\n\nlet y: i32 = 100;\nlet result2 = y << 2;  // result2 is i32 with value 400\n```\n\n**Common patterns:**\n```hemlock\n// Check if bit is set\nif (flags & 0x04) {\n    print(\"bit 2 is set\");\n}\n\n// Set a bit\nflags = flags | 0x08;\n\n// Clear a bit\nflags = flags & ~0x02;\n\n// Toggle a bit\nflags = flags ^ 0x01;\n```\n\n### Operator Precedence\n\nBitwise operators follow C-style precedence:\n\n1. `~` (unary NOT) - highest, same level as `!` and `-`\n2. `<<`, `>>` (shifts) - higher than comparisons, lower than `+`/`-`\n3. `&` (bitwise AND) - higher than `^` and `|`\n4. `^` (bitwise XOR) - between `&` and `|`\n5. `|` (bitwise OR) - lower than `&` and `^`, higher than `&&`\n6. `&&`, `||` (logical) - lowest precedence\n\n**Examples:**\n```hemlock\n// & has higher precedence than |\nlet result1 = 12 | 10 & 8;  // (10 & 8) | 12 = 8 | 12 = 12\n\n// Shift has higher precedence than bitwise operators\nlet result2 = 8 | 1 << 2;   // 8 | (1 << 2) = 8 | 4 = 12\n\n// Use parentheses for clarity\nlet result3 = (5 & 3) | (2 << 1);  // 1 | 4 = 5\n```\n\n**Important notes:**\n- Bitwise operators only work with integer types (not floats, strings, etc.)\n- Type promotion follows standard rules (smaller types promote to larger)\n- Right shift (`>>`) is arithmetic for signed types, logical for unsigned\n- Shift amounts are not range-checked (behavior is platform-dependent for large shifts)\n\n## Operator Precedence (Complete)\n\nFrom highest to lowest precedence:\n\n1. **Unary**: `!`, `-`, `~`\n2. **Multiplicative**: `*`, `/`, `%`\n3. **Additive**: `+`, `-`\n4. **Shift**: `<<`, `>>`\n5. **Relational**: `<`, `>`, `<=`, `>=`\n6. **Equality**: `==`, `!=`\n7. **Bitwise AND**: `&`\n8. **Bitwise XOR**: `^`\n9. **Bitwise OR**: `|`\n10. **Logical AND**: `&&`\n11. **Logical OR**: `||`\n\n**Use parentheses for clarity:**\n```hemlock\n// Unclear\nif (a || b && c) { }\n\n// Clear\nif (a || (b && c)) { }\nif ((a || b) && c) { }\n```\n\n## Common Patterns\n\n### Pattern: Input Validation\n\n```hemlock\nfn validate_age(age: i32): bool {\n    if (age < 0 || age > 150) {\n        return false;\n    }\n    return true;\n}\n```\n\n### Pattern: Range Checking\n\n```hemlock\nfn in_range(value: i32, min: i32, max: i32): bool {\n    return value >= min && value <= max;\n}\n\nif (in_range(score, 0, 100)) {\n    print(\"valid score\");\n}\n```\n\n### Pattern: State Machine\n\n```hemlock\nlet state = \"start\";\n\nwhile (true) {\n    switch (state) {\n        case \"start\":\n            print(\"Starting...\");\n            state = \"running\";\n            break;\n\n        case \"running\":\n            if (should_pause) {\n                state = \"paused\";\n            } else if (should_stop) {\n                state = \"stopped\";\n            }\n            break;\n\n        case \"paused\":\n            if (should_resume) {\n                state = \"running\";\n            }\n            break;\n\n        case \"stopped\":\n            print(\"Stopped\");\n            break;\n    }\n\n    if (state == \"stopped\") {\n        break;\n    }\n}\n```\n\n### Pattern: Iteration with Filtering\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n// Print only even numbers\nfor (let i = 0; i < arr.length; i = i + 1) {\n    if (arr[i] % 2 != 0) {\n        continue;  // Skip odd numbers\n    }\n    print(arr[i]);\n}\n```\n\n### Pattern: Early Exit\n\n```hemlock\nfn find_first_negative(arr: array): i32 {\n    for (let i = 0; i < arr.length; i = i + 1) {\n        if (arr[i] < 0) {\n            return i;  // Early exit\n        }\n    }\n    return -1;  // Not found\n}\n```\n\n## Best Practices\n\n1. **Always use braces** - Even for single-statement blocks (enforced by syntax)\n2. **Explicit conditions** - Use `x == 0` instead of `!x` for clarity\n3. **Avoid deep nesting** - Extract nested conditions into functions\n4. **Use early returns** - Reduce nesting with guard clauses\n5. **Break complex conditions** - Split into named boolean variables\n6. **Default in switch** - Always include a default case\n7. **Comment fall-through** - Make intentional fall-through explicit\n\n## Common Pitfalls\n\n### Pitfall: Assignment in Condition\n\n```hemlock\n// This is NOT allowed (no assignment in conditions)\nif (x = 10) { }  // ERROR: Syntax error\n\n// Use comparison instead\nif (x == 10) { }  // OK\n```\n\n### Pitfall: Missing Break in Switch\n\n```hemlock\n// Unintentional fall-through\nswitch (x) {\n    case 1:\n        print(\"one\");\n        // Missing break - falls through!\n    case 2:\n        print(\"two\");  // Executes for both 1 and 2\n        break;\n}\n\n// Fix: Add break\nswitch (x) {\n    case 1:\n        print(\"one\");\n        break;  // Now correct\n    case 2:\n        print(\"two\");\n        break;\n}\n```\n\n### Pitfall: Loop Variable Scope\n\n```hemlock\n// i is scoped to the loop\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\nprint(i);  // ERROR: i not defined here\n```\n\n## Examples\n\n### Example: FizzBuzz\n\n```hemlock\nfor (let i = 1; i <= 100; i = i + 1) {\n    if (i % 15 == 0) {\n        print(\"FizzBuzz\");\n    } else if (i % 3 == 0) {\n        print(\"Fizz\");\n    } else if (i % 5 == 0) {\n        print(\"Buzz\");\n    } else {\n        print(i);\n    }\n}\n```\n\n### Example: Prime Checker\n\n```hemlock\nfn is_prime(n: i32): bool {\n    if (n < 2) {\n        return false;\n    }\n\n    let i = 2;\n    while (i * i <= n) {\n        if (n % i == 0) {\n            return false;\n        }\n        i = i + 1;\n    }\n\n    return true;\n}\n```\n\n### Example: Menu System\n\n```hemlock\nfn menu() {\n    while (true) {\n        print(\"1. Start\");\n        print(\"2. Settings\");\n        print(\"3. Exit\");\n\n        let choice = get_input();\n\n        switch (choice) {\n            case 1:\n                start_game();\n                break;\n            case 2:\n                show_settings();\n                break;\n            case 3:\n                print(\"Goodbye!\");\n                return;\n            default:\n                print(\"Invalid choice\");\n                break;\n        }\n    }\n}\n```\n\n## Related Topics\n\n- [Functions](functions.md) - Control flow with function calls and returns\n- [Error Handling](error-handling.md) - Control flow with exceptions\n- [Types](types.md) - Type conversions in conditions\n\n## See Also\n\n- **Syntax**: See [Syntax](syntax.md) for statement syntax details\n- **Operators**: See [Types](types.md) for type promotion in operations\n"}, "Language Guide  Error Handling": {"id": "language-guide-error-handling", "content": "# Error Handling\n\nHemlock supports exception-based error handling with `try`, `catch`, `finally`, `throw`, and `panic`. This guide covers recoverable errors with exceptions and unrecoverable errors with panic.\n\n## Overview\n\n```hemlock\n// Basic error handling\ntry {\n    risky_operation();\n} catch (e) {\n    print(\"Error: \" + e);\n}\n\n// With cleanup\ntry {\n    process_file();\n} catch (e) {\n    print(\"Failed: \" + e);\n} finally {\n    cleanup();\n}\n\n// Throwing errors\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division by zero\";\n    }\n    return a / b;\n}\n```\n\n## Try-Catch-Finally\n\n### Syntax\n\n**Basic try/catch:**\n```hemlock\ntry {\n    // risky code\n} catch (e) {\n    // handle error, e contains the thrown value\n}\n```\n\n**Try/finally:**\n```hemlock\ntry {\n    // risky code\n} finally {\n    // always executes, even if exception thrown\n}\n```\n\n**Try/catch/finally:**\n```hemlock\ntry {\n    // risky code\n} catch (e) {\n    // handle error\n} finally {\n    // cleanup code\n}\n```\n\n### Try Block\n\nThe try block executes statements sequentially:\n\n```hemlock\ntry {\n    print(\"Starting...\");\n    risky_operation();\n    print(\"Success!\");  // Only if no exception\n}\n```\n\n**Behavior:**\n- Executes statements in order\n- If exception thrown: jumps to `catch` or `finally`\n- If no exception: executes `finally` (if present) then continues\n\n### Catch Block\n\nThe catch block receives the thrown value:\n\n```hemlock\ntry {\n    throw \"oops\";\n} catch (error) {\n    print(\"Caught: \" + error);  // error = \"oops\"\n    // error only accessible here\n}\n// error not accessible here\n```\n\n**Catch parameter:**\n- Receives the thrown value (any type)\n- Scoped to the catch block\n- Can be named anything (conventionally `e`, `err`, or `error`)\n\n**What you can do in catch:**\n```hemlock\ntry {\n    risky_operation();\n} catch (e) {\n    // Log the error\n    print(\"Error: \" + e);\n\n    // Re-throw same error\n    throw e;\n\n    // Throw different error\n    throw \"different error\";\n\n    // Return a default value\n    return null;\n\n    // Handle and continue\n    // (no re-throw)\n}\n```\n\n### Finally Block\n\nThe finally block **always executes**:\n\n```hemlock\ntry {\n    print(\"1: try\");\n    throw \"error\";\n} catch (e) {\n    print(\"2: catch\");\n} finally {\n    print(\"3: finally\");  // Always runs\n}\nprint(\"4: after\");\n\n// Output: 1: try, 2: catch, 3: finally, 4: after\n```\n\n**When finally runs:**\n- After try block (if no exception)\n- After catch block (if exception caught)\n- Even if try/catch contains `return`, `break`, or `continue`\n- Before control flow exits the try/catch\n\n**Finally with return:**\n```hemlock\nfn example() {\n    try {\n        return 1;  //  Returns 1 after finally runs\n    } finally {\n        print(\"cleanup\");  // Runs before returning\n    }\n}\n\nfn example2() {\n    try {\n        return 1;\n    } finally {\n        return 2;  //  Finally return overrides - returns 2\n    }\n}\n```\n\n**Finally with control flow:**\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    try {\n        if (i == 5) {\n            break;  //  Breaks after finally runs\n        }\n    } finally {\n        print(\"cleanup \" + typeof(i));\n    }\n}\n```\n\n## Throw Statement\n\n### Basic Throw\n\nThrow any value as an exception:\n\n```hemlock\nthrow \"error message\";\nthrow 404;\nthrow { code: 500, message: \"Internal error\" };\nthrow null;\nthrow [\"error\", \"details\"];\n```\n\n**Execution:**\n1. Evaluates the expression\n2. Immediately jumps to nearest enclosing `catch`\n3. If no `catch`, propagates up the call stack\n\n### Throwing Errors\n\n```hemlock\nfn validate_age(age: i32) {\n    if (age < 0) {\n        throw \"Age cannot be negative\";\n    }\n    if (age > 150) {\n        throw \"Age is unrealistic\";\n    }\n}\n\ntry {\n    validate_age(-5);\n} catch (e) {\n    print(\"Validation error: \" + e);\n}\n```\n\n### Throwing Error Objects\n\nCreate structured error information:\n\n```hemlock\nfn read_file(path: string) {\n    if (!file_exists(path)) {\n        throw {\n            type: \"FileNotFound\",\n            path: path,\n            message: \"File does not exist\"\n        };\n    }\n    // ... read file\n}\n\ntry {\n    read_file(\"missing.txt\");\n} catch (e) {\n    if (e.type == \"FileNotFound\") {\n        print(\"File not found: \" + e.path);\n    }\n}\n```\n\n### Re-throwing\n\nCatch and re-throw errors:\n\n```hemlock\nfn wrapper() {\n    try {\n        risky_operation();\n    } catch (e) {\n        print(\"Logging error: \" + e);\n        throw e;  // Re-throw to caller\n    }\n}\n\ntry {\n    wrapper();\n} catch (e) {\n    print(\"Caught in main: \" + e);\n}\n```\n\n## Uncaught Exceptions\n\nIf an exception propagates to the top of the call stack without being caught:\n\n```hemlock\nfn foo() {\n    throw \"uncaught!\";\n}\n\nfoo();  // Crashes with: Runtime error: uncaught!\n```\n\n**Behavior:**\n- Program crashes\n- Prints error message to stderr\n- Exits with non-zero status code\n- Stack trace to be added in future versions\n\n## Panic - Unrecoverable Errors\n\n### What is Panic?\n\n`panic()` is for **unrecoverable errors** that should immediately terminate the program:\n\n```hemlock\npanic();                    // Default message: \"panic!\"\npanic(\"custom message\");    // Custom message\npanic(42);                  // Non-string values are printed\n```\n\n**Semantics:**\n- **Immediately exits** the program with exit code 1\n- Prints error message to stderr: `panic: <message>`\n- **NOT catchable** with try/catch\n- Use for bugs and unrecoverable errors\n\n### Panic vs Throw\n\n```hemlock\n// throw - Recoverable error (can be caught)\ntry {\n    throw \"recoverable error\";\n} catch (e) {\n    print(\"Caught: \" + e);  //  Caught successfully\n}\n\n// panic - Unrecoverable error (cannot be caught)\ntry {\n    panic(\"unrecoverable error\");  //  Program exits immediately\n} catch (e) {\n    print(\"This never runs\");       //  Never executes\n}\n```\n\n### When to Use Panic\n\n**Use panic for:**\n- **Bugs**: Unreachable code was reached\n- **Invalid state**: Data structure corruption detected\n- **Unrecoverable errors**: Critical resource unavailable\n- **Assertion failures**: When `assert()` isn't sufficient\n\n**Examples:**\n```hemlock\n// Unreachable code\nfn process_state(state: i32) {\n    if (state == 1) {\n        return \"ready\";\n    } else if (state == 2) {\n        return \"running\";\n    } else if (state == 3) {\n        return \"stopped\";\n    } else {\n        panic(\"invalid state: \" + typeof(state));  // Should never happen\n    }\n}\n\n// Critical resource check\nfn init_system() {\n    let config = read_file(\"config.json\");\n    if (config == null) {\n        panic(\"config.json not found - cannot start\");\n    }\n    // ...\n}\n\n// Data structure invariant\nfn pop_stack(stack) {\n    if (stack.length == 0) {\n        panic(\"pop() called on empty stack\");\n    }\n    return stack.pop();\n}\n```\n\n### When NOT to Use Panic\n\n**Use throw instead for:**\n- User input validation\n- File not found\n- Network errors\n- Expected error conditions\n\n```hemlock\n// BAD: Panic for expected errors\nfn divide(a, b) {\n    if (b == 0) {\n        panic(\"division by zero\");  //  Too harsh\n    }\n    return a / b;\n}\n\n// GOOD: Throw for expected errors\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division by zero\";  //  Recoverable\n    }\n    return a / b;\n}\n```\n\n## Control Flow Interactions\n\n### Return Inside Try/Catch/Finally\n\n```hemlock\nfn example() {\n    try {\n        return 1;  //  Returns 1 after finally runs\n    } finally {\n        print(\"cleanup\");\n    }\n}\n\nfn example2() {\n    try {\n        return 1;\n    } finally {\n        return 2;  //  Finally return overrides try return - returns 2\n    }\n}\n```\n\n**Rule:** Finally block return values override try/catch return values.\n\n### Break/Continue Inside Try/Catch/Finally\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    try {\n        if (i == 5) { break; }  //  Breaks after finally runs\n    } finally {\n        print(\"cleanup \" + typeof(i));\n    }\n}\n```\n\n**Rule:** Break/continue execute after finally block.\n\n### Nested Try/Catch\n\n```hemlock\ntry {\n    try {\n        throw \"inner\";\n    } catch (e) {\n        print(\"Caught: \" + e);  // Prints: Caught: inner\n        throw \"outer\";  // Re-throw different error\n    }\n} catch (e) {\n    print(\"Caught: \" + e);  // Prints: Caught: outer\n}\n```\n\n**Rule:** Nested try/catch blocks work as expected, inner catches happen first.\n\n## Common Patterns\n\n### Pattern: Resource Cleanup\n\nAlways use `finally` for cleanup:\n\n```hemlock\nfn process_file(filename) {\n    let file = null;\n    try {\n        file = open(filename);\n        let content = file.read();\n        process(content);\n    } catch (e) {\n        print(\"Error processing file: \" + e);\n    } finally {\n        if (file != null) {\n            file.close();  // Always closes, even on error\n        }\n    }\n}\n```\n\n### Pattern: Error Wrapping\n\nWrap lower-level errors with context:\n\n```hemlock\nfn load_config(path) {\n    try {\n        let content = read_file(path);\n        return parse_json(content);\n    } catch (e) {\n        throw \"Failed to load config from \" + path + \": \" + e;\n    }\n}\n```\n\n### Pattern: Error Recovery\n\nProvide fallback on error:\n\n```hemlock\nfn safe_divide(a, b) {\n    try {\n        if (b == 0) {\n            throw \"division by zero\";\n        }\n        return a / b;\n    } catch (e) {\n        print(\"Error: \" + e);\n        return null;  // Fallback value\n    }\n}\n```\n\n### Pattern: Validation\n\nUse exceptions for validation:\n\n```hemlock\nfn validate_user(user) {\n    if (user.name == null || user.name == \"\") {\n        throw \"Name is required\";\n    }\n    if (user.age < 0 || user.age > 150) {\n        throw \"Invalid age\";\n    }\n    if (user.email == null || !user.email.contains(\"@\")) {\n        throw \"Invalid email\";\n    }\n}\n\ntry {\n    validate_user({ name: \"Alice\", age: -5, email: \"invalid\" });\n} catch (e) {\n    print(\"Validation failed: \" + e);\n}\n```\n\n### Pattern: Multiple Error Types\n\nUse error objects to distinguish error types:\n\n```hemlock\nfn process_data(data) {\n    if (data == null) {\n        throw { type: \"NullData\", message: \"Data is null\" };\n    }\n\n    if (typeof(data) != \"array\") {\n        throw { type: \"TypeError\", message: \"Expected array\" };\n    }\n\n    if (data.length == 0) {\n        throw { type: \"EmptyData\", message: \"Array is empty\" };\n    }\n\n    // ... process\n}\n\ntry {\n    process_data(null);\n} catch (e) {\n    if (e.type == \"NullData\") {\n        print(\"No data provided\");\n    } else if (e.type == \"TypeError\") {\n        print(\"Wrong data type: \" + e.message);\n    } else {\n        print(\"Error: \" + e.message);\n    }\n}\n```\n\n## Best Practices\n\n1. **Use exceptions for exceptional cases** - Not for normal control flow\n2. **Throw meaningful errors** - Use strings or objects with context\n3. **Always use finally for cleanup** - Ensures resources are freed\n4. **Don't catch and ignore** - At least log the error\n5. **Re-throw when appropriate** - Let caller handle if you can't\n6. **Panic for bugs** - Use panic for unrecoverable errors\n7. **Document exceptions** - Make clear what functions can throw\n\n## Common Pitfalls\n\n### Pitfall: Swallowing Errors\n\n```hemlock\n// BAD: Silent failure\ntry {\n    risky_operation();\n} catch (e) {\n    // Error ignored - silent failure\n}\n\n// GOOD: Log or handle\ntry {\n    risky_operation();\n} catch (e) {\n    print(\"Operation failed: \" + e);\n    // Handle appropriately\n}\n```\n\n### Pitfall: Finally Override\n\n```hemlock\n// BAD: Finally overrides return\nfn get_value() {\n    try {\n        return 42;\n    } finally {\n        return 0;  //  Returns 0, not 42!\n    }\n}\n\n// GOOD: Don't return in finally\nfn get_value() {\n    try {\n        return 42;\n    } finally {\n        cleanup();  // Just cleanup, no return\n    }\n}\n```\n\n### Pitfall: Forgetting Cleanup\n\n```hemlock\n// BAD: File may not be closed on error\nfn process() {\n    let file = open(\"data.txt\");\n    let content = file.read();  // May throw\n    file.close();  // Never reached if error\n}\n\n// GOOD: Use finally\nfn process() {\n    let file = null;\n    try {\n        file = open(\"data.txt\");\n        let content = file.read();\n    } finally {\n        if (file != null) {\n            file.close();\n        }\n    }\n}\n```\n\n### Pitfall: Using Panic for Expected Errors\n\n```hemlock\n// BAD: Panic for expected error\nfn read_config(path) {\n    if (!file_exists(path)) {\n        panic(\"Config file not found\");  //  Too harsh\n    }\n    return read_file(path);\n}\n\n// GOOD: Throw for expected error\nfn read_config(path) {\n    if (!file_exists(path)) {\n        throw \"Config file not found: \" + path;  //  Recoverable\n    }\n    return read_file(path);\n}\n```\n\n## Examples\n\n### Example: Basic Error Handling\n\n```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division by zero\";\n    }\n    return a / b;\n}\n\ntry {\n    print(divide(10, 0));\n} catch (e) {\n    print(\"Error: \" + e);  // Prints: Error: division by zero\n}\n```\n\n### Example: Resource Management\n\n```hemlock\nfn copy_file(src, dst) {\n    let src_file = null;\n    let dst_file = null;\n\n    try {\n        src_file = open(src, \"r\");\n        dst_file = open(dst, \"w\");\n\n        let content = src_file.read();\n        dst_file.write(content);\n\n        print(\"File copied successfully\");\n    } catch (e) {\n        print(\"Failed to copy file: \" + e);\n        throw e;  // Re-throw\n    } finally {\n        if (src_file != null) { src_file.close(); }\n        if (dst_file != null) { dst_file.close(); }\n    }\n}\n```\n\n### Example: Nested Error Handling\n\n```hemlock\nfn process_users(users) {\n    let success_count = 0;\n    let error_count = 0;\n\n    let i = 0;\n    while (i < users.length) {\n        try {\n            validate_user(users[i]);\n            save_user(users[i]);\n            success_count = success_count + 1;\n        } catch (e) {\n            print(\"Failed to process user: \" + e);\n            error_count = error_count + 1;\n        }\n        i = i + 1;\n    }\n\n    print(\"Processed: \" + typeof(success_count) + \" success, \" + typeof(error_count) + \" errors\");\n}\n```\n\n### Example: Custom Error Types\n\n```hemlock\nfn create_error(type, message, details) {\n    return {\n        type: type,\n        message: message,\n        details: details,\n        toString: fn() {\n            return self.type + \": \" + self.message;\n        }\n    };\n}\n\nfn divide(a, b) {\n    if (typeof(a) != \"i32\" && typeof(a) != \"f64\") {\n        throw create_error(\"TypeError\", \"a must be a number\", { value: a });\n    }\n    if (typeof(b) != \"i32\" && typeof(b) != \"f64\") {\n        throw create_error(\"TypeError\", \"b must be a number\", { value: b });\n    }\n    if (b == 0) {\n        throw create_error(\"DivisionByZero\", \"Cannot divide by zero\", { a: a, b: b });\n    }\n    return a / b;\n}\n\ntry {\n    divide(10, 0);\n} catch (e) {\n    print(e.toString());\n    if (e.type == \"DivisionByZero\") {\n        print(\"Details: a=\" + typeof(e.details.a) + \", b=\" + typeof(e.details.b));\n    }\n}\n```\n\n### Example: Retry Logic\n\n```hemlock\nfn retry(operation, max_attempts) {\n    let attempt = 0;\n\n    while (attempt < max_attempts) {\n        try {\n            return operation();  // Success!\n        } catch (e) {\n            attempt = attempt + 1;\n            if (attempt >= max_attempts) {\n                throw \"Operation failed after \" + typeof(max_attempts) + \" attempts: \" + e;\n            }\n            print(\"Attempt \" + typeof(attempt) + \" failed, retrying...\");\n        }\n    }\n}\n\nfn unreliable_operation() {\n    // Simulated unreliable operation\n    if (random() < 0.7) {\n        throw \"Operation failed\";\n    }\n    return \"Success\";\n}\n\ntry {\n    let result = retry(unreliable_operation, 3);\n    print(result);\n} catch (e) {\n    print(\"All retries failed: \" + e);\n}\n```\n\n## Execution Order\n\nUnderstanding the execution order:\n\n```hemlock\ntry {\n    print(\"1: try block start\");\n    throw \"error\";\n    print(\"2: never reached\");\n} catch (e) {\n    print(\"3: catch block\");\n} finally {\n    print(\"4: finally block\");\n}\nprint(\"5: after try/catch/finally\");\n\n// Output:\n// 1: try block start\n// 3: catch block\n// 4: finally block\n// 5: after try/catch/finally\n```\n\n## Current Limitations\n\n- **No stack trace** - Uncaught exceptions don't show stack trace (planned)\n- **Some built-ins exit** - Some built-in functions still `exit()` instead of throwing (to be reviewed)\n- **No custom exception types** - Any value can be thrown, but no formal exception hierarchy\n\n## Related Topics\n\n- [Functions](functions.md) - Exceptions and function returns\n- [Control Flow](control-flow.md) - How exceptions affect control flow\n- [Memory](memory.md) - Using finally for memory cleanup\n\n## See Also\n\n- **Exception Semantics**: See CLAUDE.md section \"Error Handling\"\n- **Panic vs Throw**: Different use cases for different error types\n- **Finally Guarantee**: Always executes, even with return/break/continue\n"}, "Language Guide  Functions": {"id": "language-guide-functions", "content": "# Functions\n\nFunctions in Hemlock are **first-class values** that can be assigned to variables, passed as arguments, and returned from other functions. This guide covers function syntax, closures, recursion, and advanced patterns.\n\n## Overview\n\n```hemlock\n// Named function syntax\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\n// Anonymous function\nlet multiply = fn(x, y) {\n    return x * y;\n};\n\n// Closures\nfn makeAdder(x) {\n    return fn(y) {\n        return x + y;\n    };\n}\n\nlet add5 = makeAdder(5);\nprint(add5(3));  // 8\n```\n\n## Function Declaration\n\n### Named Functions\n\n```hemlock\nfn greet(name: string): string {\n    return \"Hello, \" + name;\n}\n\nlet msg = greet(\"Alice\");  // \"Hello, Alice\"\n```\n\n**Components:**\n- `fn` - Function keyword\n- `greet` - Function name\n- `(name: string)` - Parameters with optional types\n- `: string` - Optional return type\n- `{ ... }` - Function body\n\n### Anonymous Functions\n\nFunctions without names, assigned to variables:\n\n```hemlock\nlet square = fn(x) {\n    return x * x;\n};\n\nprint(square(5));  // 25\n```\n\n**Named vs. Anonymous:**\n```hemlock\n// These are equivalent:\nfn add(a, b) { return a + b; }\n\nlet add = fn(a, b) { return a + b; };\n```\n\n**Note:** Named functions desugar to variable assignments with anonymous functions.\n\n## Parameters\n\n### Basic Parameters\n\n```hemlock\nfn example(a, b, c) {\n    return a + b + c;\n}\n\nlet result = example(1, 2, 3);  // 6\n```\n\n### Type Annotations\n\nOptional type annotations on parameters:\n\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 10);      // OK\nadd(5, 10.5);    // Runtime type check promotes to f64\n```\n\n**Type checking:**\n- Parameter types are checked at call time if annotated\n- Implicit type conversions follow standard promotion rules\n- Type mismatches cause runtime errors\n\n### Pass-by-Value\n\nAll arguments are **copied** (pass-by-value):\n\n```hemlock\nfn modify(x) {\n    x = 100;  // Only modifies local copy\n}\n\nlet a = 10;\nmodify(a);\nprint(a);  // Still 10 (unchanged)\n```\n\n**Note:** Objects and arrays are passed by reference (the reference is copied), so their contents can be modified:\n\n```hemlock\nfn modify_array(arr) {\n    arr[0] = 99;  // Modifies original array\n}\n\nlet a = [1, 2, 3];\nmodify_array(a);\nprint(a[0]);  // 99 (modified)\n```\n\n## Return Values\n\n### Return Statement\n\n```hemlock\nfn get_max(a: i32, b: i32): i32 {\n    if (a > b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n```\n\n### Return Type Annotations\n\nOptional type annotation for return value:\n\n```hemlock\nfn calculate(): f64 {\n    return 3.14159;\n}\n\nfn get_name(): string {\n    return \"Alice\";\n}\n```\n\n**Type checking:**\n- Return types are checked when function returns (if annotated)\n- Type conversions follow standard promotion rules\n\n### Implicit Return\n\nFunctions without return type annotation implicitly return `null`:\n\n```hemlock\nfn print_message(msg) {\n    print(msg);\n    // Implicitly returns null\n}\n\nlet result = print_message(\"hello\");  // result is null\n```\n\n### Early Return\n\n```hemlock\nfn find_first_negative(arr) {\n    for (let i = 0; i < arr.length; i = i + 1) {\n        if (arr[i] < 0) {\n            return i;  // Early exit\n        }\n    }\n    return -1;  // Not found\n}\n```\n\n### Return Without Value\n\n`return;` without a value returns `null`:\n\n```hemlock\nfn maybe_process(value) {\n    if (value < 0) {\n        return;  // Returns null\n    }\n    return value * 2;\n}\n```\n\n## First-Class Functions\n\nFunctions can be assigned, passed, and returned like any other value.\n\n### Functions as Variables\n\n```hemlock\nlet operation = fn(x, y) { return x + y; };\n\nprint(operation(5, 3));  // 8\n\n// Reassign\noperation = fn(x, y) { return x * y; };\nprint(operation(5, 3));  // 15\n```\n\n### Functions as Arguments\n\n```hemlock\nfn apply(f, x) {\n    return f(x);\n}\n\nfn double(n) {\n    return n * 2;\n}\n\nlet result = apply(double, 5);  // 10\n```\n\n### Functions as Return Values\n\n```hemlock\nfn get_operation(op: string) {\n    if (op == \"add\") {\n        return fn(a, b) { return a + b; };\n    } else if (op == \"multiply\") {\n        return fn(a, b) { return a * b; };\n    } else {\n        return fn(a, b) { return 0; };\n    }\n}\n\nlet add = get_operation(\"add\");\nprint(add(5, 3));  // 8\n```\n\n## Closures\n\nFunctions capture their defining environment (lexical scoping).\n\n### Basic Closures\n\n```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\nprint(counter());  // 3\n```\n\n**How it works:**\n- Inner function captures `count` from outer scope\n- `count` persists across calls to the returned function\n- Each call to `makeCounter()` creates a new closure with its own `count`\n\n### Closure with Parameters\n\n```hemlock\nfn makeAdder(x) {\n    return fn(y) {\n        return x + y;\n    };\n}\n\nlet add5 = makeAdder(5);\nlet add10 = makeAdder(10);\n\nprint(add5(3));   // 8\nprint(add10(3));  // 13\n```\n\n### Multiple Closures\n\n```hemlock\nfn makeOperations(x) {\n    let add = fn(y) { return x + y; };\n    let multiply = fn(y) { return x * y; };\n\n    return { add: add, multiply: multiply };\n}\n\nlet ops = makeOperations(5);\nprint(ops.add(3));       // 8\nprint(ops.multiply(3));  // 15\n```\n\n### Lexical Scoping\n\nFunctions can **read** (not write) outer scope variables:\n\n```hemlock\nlet global = 10;\n\nfn outer() {\n    let outer_var = 20;\n\n    fn inner() {\n        // Can read global and outer_var\n        print(global);      // 10\n        print(outer_var);   // 20\n    }\n\n    inner();\n}\n\nouter();\n```\n\n**Current limitation:** Closures can only read outer scope variables, not write to them (except through captured references).\n\n## Recursion\n\nFunctions can call themselves.\n\n### Basic Recursion\n\n```hemlock\nfn factorial(n: i32): i32 {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nprint(factorial(5));  // 120\n```\n\n### Mutual Recursion\n\nFunctions can call each other:\n\n```hemlock\nfn is_even(n: i32): bool {\n    if (n == 0) {\n        return true;\n    }\n    return is_odd(n - 1);\n}\n\nfn is_odd(n: i32): bool {\n    if (n == 0) {\n        return false;\n    }\n    return is_even(n - 1);\n}\n\nprint(is_even(4));  // true\nprint(is_odd(4));   // false\n```\n\n### Recursive Data Processing\n\n```hemlock\nfn sum_array(arr: array, index: i32): i32 {\n    if (index >= arr.length) {\n        return 0;\n    }\n    return arr[index] + sum_array(arr, index + 1);\n}\n\nlet numbers = [1, 2, 3, 4, 5];\nprint(sum_array(numbers, 0));  // 15\n```\n\n**Note:** No tail call optimization yet - deep recursion may cause stack overflow.\n\n## Higher-Order Functions\n\nFunctions that take or return other functions.\n\n### Map Pattern\n\n```hemlock\nfn map(arr, f) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        result.push(f(arr[i]));\n        i = i + 1;\n    }\n    return result;\n}\n\nfn double(x) { return x * 2; }\n\nlet numbers = [1, 2, 3, 4, 5];\nlet doubled = map(numbers, double);  // [2, 4, 6, 8, 10]\n```\n\n### Filter Pattern\n\n```hemlock\nfn filter(arr, predicate) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        if (predicate(arr[i])) {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nfn is_even(x) { return x % 2 == 0; }\n\nlet numbers = [1, 2, 3, 4, 5, 6];\nlet evens = filter(numbers, is_even);  // [2, 4, 6]\n```\n\n### Reduce Pattern\n\n```hemlock\nfn reduce(arr, f, initial) {\n    let accumulator = initial;\n    let i = 0;\n    while (i < arr.length) {\n        accumulator = f(accumulator, arr[i]);\n        i = i + 1;\n    }\n    return accumulator;\n}\n\nfn add(a, b) { return a + b; }\n\nlet numbers = [1, 2, 3, 4, 5];\nlet sum = reduce(numbers, add, 0);  // 15\n```\n\n### Function Composition\n\n```hemlock\nfn compose(f, g) {\n    return fn(x) {\n        return f(g(x));\n    };\n}\n\nfn double(x) { return x * 2; }\nfn increment(x) { return x + 1; }\n\nlet double_then_increment = compose(increment, double);\nprint(double_then_increment(5));  // 11 (5*2 + 1)\n```\n\n## Common Patterns\n\n### Pattern: Factory Functions\n\n```hemlock\nfn createPerson(name: string, age: i32) {\n    return {\n        name: name,\n        age: age,\n        greet: fn() {\n            return \"Hi, I'm \" + self.name;\n        }\n    };\n}\n\nlet person = createPerson(\"Alice\", 30);\nprint(person.greet());  // \"Hi, I'm Alice\"\n```\n\n### Pattern: Callback Functions\n\n```hemlock\nfn process_async(data, callback) {\n    // ... do processing\n    callback(data);\n}\n\nprocess_async(\"test\", fn(result) {\n    print(\"Processing complete: \" + result);\n});\n```\n\n### Pattern: Partial Application\n\n```hemlock\nfn partial(f, x) {\n    return fn(y) {\n        return f(x, y);\n    };\n}\n\nfn multiply(a, b) {\n    return a * b;\n}\n\nlet double = partial(multiply, 2);\nlet triple = partial(multiply, 3);\n\nprint(double(5));  // 10\nprint(triple(5));  // 15\n```\n\n### Pattern: Memoization\n\n```hemlock\nfn memoize(f) {\n    let cache = {};\n\n    return fn(x) {\n        if (cache.has(x)) {\n            return cache[x];\n        }\n\n        let result = f(x);\n        cache[x] = result;\n        return result;\n    };\n}\n\nfn expensive_fibonacci(n) {\n    if (n <= 1) { return n; }\n    return expensive_fibonacci(n - 1) + expensive_fibonacci(n - 2);\n}\n\nlet fast_fib = memoize(expensive_fibonacci);\nprint(fast_fib(10));  // Much faster with caching\n```\n\n## Function Semantics\n\n### Return Type Requirements\n\nFunctions with return type annotation **must** return a value:\n\n```hemlock\nfn get_value(): i32 {\n    // ERROR: Missing return statement\n}\n\nfn get_value(): i32 {\n    return 42;  // OK\n}\n```\n\n### Type Checking\n\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 10);        // OK\nadd(5.5, 10.5);    // Promotes to f64, returns f64\nadd(\"a\", \"b\");     // Runtime error: type mismatch\n```\n\n### Scope Rules\n\n```hemlock\nlet global = \"global\";\n\nfn outer() {\n    let outer_var = \"outer\";\n\n    fn inner() {\n        let inner_var = \"inner\";\n        // Can access: inner_var, outer_var, global\n    }\n\n    // Can access: outer_var, global\n    // Cannot access: inner_var\n}\n\n// Can access: global\n// Cannot access: outer_var, inner_var\n```\n\n## Best Practices\n\n1. **Use type annotations** - Helps catch errors and documents intent\n2. **Keep functions small** - Each function should do one thing\n3. **Prefer pure functions** - Avoid side effects when possible\n4. **Name functions clearly** - Use descriptive verb names\n5. **Return early** - Use guard clauses to reduce nesting\n6. **Document complex closures** - Make captured variables explicit\n7. **Avoid deep recursion** - No tail call optimization yet\n\n## Common Pitfalls\n\n### Pitfall: Closure Environment Leaks\n\n```hemlock\n// Memory leak: closure environments are never freed in v0.1\nfn create_closures() {\n    let data = alloc(1000000);  // Large allocation\n    return fn() { return data; };  // Closure captures data\n}\n\nlet f = create_closures();  // data is never freed (memory leak)\n```\n\n**Current limitation:** Closure environments are never freed in v0.1. Will be fixed with reference counting in v0.2.\n\n### Pitfall: Recursion Depth\n\n```hemlock\n// Deep recursion may cause stack overflow\nfn count_down(n) {\n    if (n == 0) { return; }\n    count_down(n - 1);\n}\n\ncount_down(100000);  // May crash with stack overflow\n```\n\n### Pitfall: Modifying Captured Variables\n\n```hemlock\nfn make_counter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;  // Can read and modify captured variables\n        return count;\n    };\n}\n```\n\n**Note:** This works, but be aware that all closures share the same captured environment.\n\n## Examples\n\n### Example: Function Pipeline\n\n```hemlock\nfn pipeline(value, ...functions) {\n    let result = value;\n    // Note: variadic functions not supported yet\n    // This is conceptual\n    return result;\n}\n\n// Workaround: manual composition\nfn process(value) {\n    return increment(double(trim(value)));\n}\n```\n\n### Example: Event Handler\n\n```hemlock\nlet handlers = [];\n\nfn on_event(name: string, handler) {\n    handlers.push({ name: name, handler: handler });\n}\n\nfn trigger_event(name: string, data) {\n    let i = 0;\n    while (i < handlers.length) {\n        if (handlers[i].name == name) {\n            handlers[i].handler(data);\n        }\n        i = i + 1;\n    }\n}\n\non_event(\"click\", fn(data) {\n    print(\"Clicked: \" + data);\n});\n\ntrigger_event(\"click\", \"button1\");\n```\n\n### Example: Sorting with Custom Comparator\n\n```hemlock\nfn sort(arr, compare) {\n    // Bubble sort with custom comparator\n    let n = arr.length;\n    let i = 0;\n    while (i < n) {\n        let j = 0;\n        while (j < n - i - 1) {\n            if (compare(arr[j], arr[j + 1]) > 0) {\n                let temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n            j = j + 1;\n        }\n        i = i + 1;\n    }\n}\n\nfn ascending(a, b) {\n    if (a < b) { return -1; }\n    if (a > b) { return 1; }\n    return 0;\n}\n\nlet numbers = [5, 2, 8, 1, 9];\nsort(numbers, ascending);\nprint(numbers);  // [1, 2, 5, 8, 9]\n```\n\n## Limitations (v0.1)\n\nCurrent limitations to be aware of:\n\n- **Closure environments leak** - Never freed (to be fixed with refcounting in v0.2)\n- **No pass-by-reference** - `ref` keyword parsed but not implemented\n- **No variadic functions** - Can't have variable number of arguments\n- **No default arguments** - All parameters must be provided\n- **No function overloading** - One function per name\n- **No tail call optimization** - Deep recursion limited by stack size\n\n## Related Topics\n\n- [Control Flow](control-flow.md) - Using functions with control structures\n- [Objects](objects.md) - Methods are functions stored in objects\n- [Error Handling](error-handling.md) - Functions and exception handling\n- [Types](types.md) - Type annotations and conversions\n\n## See Also\n\n- **Closures**: See CLAUDE.md section \"Functions\" for closure semantics\n- **First-Class Values**: Functions are values like any other\n- **Lexical Scoping**: Functions capture their defining environment\n"}, "Language Guide  Memory": {"id": "language-guide-memory", "content": "# Memory Management\n\nHemlock embraces **manual memory management** with explicit control over allocation and deallocation. This guide covers Hemlock's memory model, the two pointer types, and the complete memory API.\n\n## Philosophy\n\nHemlock follows the principle: \"You allocated it, you free it.\" There is:\n- No garbage collection\n- No automatic resource cleanup\n- No reference counting (in v0.1)\n- Full responsibility on the programmer\n\nThis explicit approach gives you complete control but requires careful management to avoid memory leaks and dangling pointers.\n\n## The Two Pointer Types\n\nHemlock provides two distinct pointer types, each with different safety characteristics:\n\n### `ptr` - Raw Pointer (Dangerous)\n\nRaw pointers are **just addresses** with minimal safety guarantees:\n\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);  // You must remember to free\n```\n\n**Characteristics:**\n- Just an 8-byte address\n- No bounds checking\n- No length tracking\n- User manages lifetime entirely\n- For experts and FFI\n\n**Use cases:**\n- Low-level system programming\n- Foreign Function Interface (FFI)\n- Performance-critical code\n- When you need complete control\n\n**Dangers:**\n```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // Way past allocation - allowed but dangerous\nfree(p);\nlet x = *p;       // Dangling pointer - undefined behavior\nfree(p);          // Double-free - will crash\n```\n\n### `buffer` - Safe Wrapper (Recommended)\n\nBuffers provide **bounds-checked access** while still requiring manual deallocation:\n\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // bounds checked\nprint(b.length);        // 64\nfree(b);                // still manual\n```\n\n**Characteristics:**\n- Pointer + length + capacity\n- Bounds checked on access\n- Still requires manual `free()`\n- Better default for most code\n\n**Properties:**\n```hemlock\nlet buf = buffer(100);\nprint(buf.length);      // 100 (current size)\nprint(buf.capacity);    // 100 (allocated capacity)\n```\n\n**Bounds checking:**\n```hemlock\nlet buf = buffer(10);\nbuf[5] = 42;      // OK\nbuf[100] = 42;    // ERROR: Index out of bounds\n```\n\n## Memory API\n\n### Core Allocation\n\n**`alloc(bytes)` - Allocate raw memory**\n```hemlock\nlet p = alloc(1024);  // Allocate 1KB, returns ptr\n// ... use memory\nfree(p);\n```\n\n**`buffer(size)` - Allocate safe buffer**\n```hemlock\nlet buf = buffer(256);  // Allocate 256-byte buffer\nbuf[0] = 65;            // 'A'\nbuf[1] = 66;            // 'B'\nfree(buf);\n```\n\n**`free(ptr)` - Free memory**\n```hemlock\nlet p = alloc(100);\nfree(p);  // Must free to avoid memory leak\n\nlet buf = buffer(100);\nfree(buf);  // Works on both ptr and buffer\n```\n\n**Important:** `free()` works on both `ptr` and `buffer` types.\n\n### Memory Operations\n\n**`memset(ptr, byte, size)` - Fill memory**\n```hemlock\nlet p = alloc(100);\nmemset(p, 0, 100);     // Zero out 100 bytes\nmemset(p, 65, 10);     // Fill first 10 bytes with 'A'\nfree(p);\n```\n\n**`memcpy(dest, src, size)` - Copy memory**\n```hemlock\nlet src = alloc(50);\nlet dst = alloc(50);\nmemset(src, 42, 50);\nmemcpy(dst, src, 50);  // Copy 50 bytes from src to dst\nfree(src);\nfree(dst);\n```\n\n**`realloc(ptr, size)` - Resize allocation**\n```hemlock\nlet p = alloc(100);\n// ... use 100 bytes\np = realloc(p, 200);   // Resize to 200 bytes\n// ... use 200 bytes\nfree(p);\n```\n\n**Note:** After `realloc()`, the old pointer may be invalid. Always use the returned pointer.\n\n### Typed Allocation (TODO - v0.2)\n\nFuture versions will include typed allocation helpers:\n\n```hemlock\n// Planned for v0.2\nlet arr = talloc(i32, 100);  // Allocate 100 i32 values\nlet size = sizeof(i32);      // Get size of type\n```\n\n## Common Patterns\n\n### Pattern: Allocate, Use, Free\n\nThe basic pattern for memory management:\n\n```hemlock\n// 1. Allocate\nlet data = alloc(1024);\n\n// 2. Use\nmemset(data, 0, 1024);\n// ... do work\n\n// 3. Free\nfree(data);\n```\n\n### Pattern: Safe Buffer Usage\n\nPrefer buffers for bounds-checked access:\n\n```hemlock\nlet buf = buffer(256);\n\n// Safe iteration\nlet i = 0;\nwhile (i < buf.length) {\n    buf[i] = i;\n    i = i + 1;\n}\n\nfree(buf);\n```\n\n### Pattern: Resource Management with try/finally\n\nEnsure cleanup even on errors:\n\n```hemlock\nlet data = alloc(1024);\ntry {\n    // ... risky operations\n    process(data);\n} finally {\n    free(data);  // Always freed, even on error\n}\n```\n\n## Memory Safety Considerations\n\n### Double-Free\n\n**Allowed but will crash:**\n```hemlock\nlet p = alloc(100);\nfree(p);\nfree(p);  // CRASH: Double-free detected\n```\n\n**Prevention:**\n```hemlock\nlet p = alloc(100);\nfree(p);\np = null;  // Set to null after freeing\n\nif (p != null) {\n    free(p);  // Won't execute\n}\n```\n\n### Dangling Pointers\n\n**Allowed but undefined behavior:**\n```hemlock\nlet p = alloc(100);\n*p = 42;      // OK\nfree(p);\nlet x = *p;   // UNDEFINED: Reading freed memory\n```\n\n**Prevention:** Don't access memory after freeing.\n\n### Memory Leaks\n\n**Easy to create, hard to debug:**\n```hemlock\nfn leak_memory() {\n    let p = alloc(1000);\n    // Forgot to free!\n    return;  // Memory leaked\n}\n```\n\n**Prevention:** Always pair `alloc()` with `free()`:\n```hemlock\nfn safe_function() {\n    let p = alloc(1000);\n    try {\n        // ... use p\n    } finally {\n        free(p);  // Always freed\n    }\n}\n```\n\n### Pointer Arithmetic\n\n**Allowed but dangerous:**\n```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // Way past allocation boundary\n*q = 42;          // UNDEFINED: Out of bounds write\nfree(p);\n```\n\n**Use buffers for bounds checking:**\n```hemlock\nlet buf = buffer(10);\nbuf[100] = 42;  // ERROR: Bounds check prevents overflow\n```\n\n## Best Practices\n\n1. **Default to `buffer`** - Use `buffer` unless you specifically need raw `ptr`\n2. **Match alloc/free** - Every `alloc()` should have exactly one `free()`\n3. **Use try/finally** - Ensure cleanup with exception handling\n4. **Null after free** - Set pointers to `null` after freeing to catch use-after-free\n5. **Bounds check** - Use buffer indexing for automatic bounds checking\n6. **Document ownership** - Make clear which code owns and frees each allocation\n\n## Examples\n\n### Example: Dynamic String Builder\n\n```hemlock\nfn build_message(count: i32): ptr {\n    let size = count * 10;\n    let buf = alloc(size);\n\n    let i = 0;\n    while (i < count) {\n        memset(buf + (i * 10), 65 + i, 10);\n        i = i + 1;\n    }\n\n    return buf;  // Caller must free\n}\n\nlet msg = build_message(5);\n// ... use msg\nfree(msg);\n```\n\n### Example: Safe Array Operations\n\n```hemlock\nfn process_array(size: i32) {\n    let arr = buffer(size);\n\n    try {\n        // Fill array\n        let i = 0;\n        while (i < arr.length) {\n            arr[i] = i * 2;\n            i = i + 1;\n        }\n\n        // Process\n        i = 0;\n        while (i < arr.length) {\n            print(arr[i]);\n            i = i + 1;\n        }\n    } finally {\n        free(arr);  // Always cleanup\n    }\n}\n```\n\n### Example: Memory Pool Pattern\n\n```hemlock\n// Simple memory pool (simplified)\nlet pool = alloc(10000);\nlet pool_offset = 0;\n\nfn pool_alloc(size: i32): ptr {\n    if (pool_offset + size > 10000) {\n        throw \"Pool exhausted\";\n    }\n\n    let ptr = pool + pool_offset;\n    pool_offset = pool_offset + size;\n    return ptr;\n}\n\n// Use pool\nlet p1 = pool_alloc(100);\nlet p2 = pool_alloc(200);\n\n// Free entire pool at once\nfree(pool);\n```\n\n## Limitations (v0.1)\n\nCurrent limitations to be aware of:\n\n- **No reference counting** - Objects, closures, and arrays are never freed automatically\n- **No cycle detection** - Circular references will leak memory\n- **No typed allocation** - `talloc()` and `sizeof()` planned for v0.2\n- **No custom allocators** - Only system malloc/free\n- **Closure environments leak** - Captured variables are never freed (to be fixed in v0.2)\n\n## Related Topics\n\n- [Strings](strings.md) - String memory management and UTF-8 encoding\n- [Arrays](arrays.md) - Dynamic arrays and their memory characteristics\n- [Objects](objects.md) - Object allocation and lifetime\n- [Error Handling](error-handling.md) - Using try/finally for cleanup\n\n## See Also\n\n- **Design Philosophy**: See CLAUDE.md section \"Memory Management\"\n- **Type System**: See [Types](types.md) for `ptr` and `buffer` type details\n- **FFI**: Raw pointers are essential for Foreign Function Interface\n"}, "Language Guide  Modules": {"id": "language-guide-modules", "content": "# Hemlock Module System (Phase 1)\n\nThis document describes the ES6-style import/export module system implemented for Hemlock.\n\n## Overview\n\nHemlock now supports a file-based module system with ES6-style import/export syntax. Modules are:\n- **Singletons**: Each module is loaded once and cached\n- **File-based**: Modules correspond to .hml files on disk\n- **Explicitly imported**: Dependencies are declared with import statements\n- **Topologically executed**: Dependencies are executed before dependents\n\n## Syntax\n\n### Export Statements\n\n**Inline Named Exports:**\n```hemlock\nexport fn add(a, b) {\n    return a + b;\n}\n\nexport const PI = 3.14159;\nexport let counter = 0;\n```\n\n**Export List:**\n```hemlock\nfn add(a, b) { return a + b; }\nfn subtract(a, b) { return a - b; }\n\nexport { add, subtract };\n```\n\n**Re-exports:**\n```hemlock\n// Re-export from another module\nexport { add, subtract } from \"./math.hml\";\n```\n\n### Import Statements\n\n**Named Imports:**\n```hemlock\nimport { add, subtract } from \"./math.hml\";\nprint(add(1, 2));  // 3\n```\n\n**Namespace Import:**\n```hemlock\nimport * as math from \"./math.hml\";\nprint(math.add(1, 2));  // 3\nprint(math.PI);  // 3.14159\n```\n\n**Aliasing:**\n```hemlock\nimport { add as sum, subtract as diff } from \"./math.hml\";\nprint(sum(1, 2));  // 3\n```\n\n## Module Resolution\n\n### Path Types\n\n**Relative Paths:**\n```hemlock\nimport { foo } from \"./module.hml\";       // Same directory\nimport { bar } from \"../parent.hml\";      // Parent directory\nimport { baz } from \"./sub/nested.hml\";   // Subdirectory\n```\n\n**Absolute Paths:**\n```hemlock\nimport { foo } from \"/absolute/path/to/module.hml\";\n```\n\n**Extension Handling:**\n- `.hml` extension can be omitted - it will be added automatically\n- `./math` resolves to `./math.hml`\n\n## Features\n\n### Circular Dependency Detection\n\nThe module system detects circular dependencies and reports an error:\n\n```\nError: Circular dependency detected when loading '/path/to/a.hml'\n```\n\n### Module Caching\n\nModules are loaded once and cached. Multiple imports of the same module return the same instance:\n\n```hemlock\n// counter.hml\nexport let count = 0;\nexport fn increment() {\n    count = count + 1;\n}\n\n// a.hml\nimport { count, increment } from \"./counter.hml\";\nincrement();\nprint(count);  // 1\n\n// b.hml\nimport { count } from \"./counter.hml\";  // Same instance!\nprint(count);  // Still 1 (shared state)\n```\n\n### Import Immutability\n\nImported bindings cannot be reassigned:\n\n```hemlock\nimport { add } from \"./math.hml\";\nadd = fn() { };  // ERROR: cannot reassign imported binding\n```\n\n## Implementation Details\n\n### Architecture\n\n**Files:**\n- `include/module.h` - Module system API\n- `src/module.c` - Module loading, caching, and execution\n- Parser support in `src/parser.c`\n- Runtime support in `src/interpreter/runtime.c`\n\n**Key Components:**\n1. **ModuleCache**: Maintains loaded modules indexed by absolute path\n2. **Module**: Represents a loaded module with its AST and exports\n3. **Path Resolution**: Resolves relative/absolute paths to canonical paths\n4. **Topological Execution**: Executes modules in dependency order\n\n### Module Loading Process\n\n1. **Parse Phase**: Tokenize and parse the module file\n2. **Dependency Resolution**: Recursively load imported modules\n3. **Cycle Detection**: Check if module is already being loaded\n4. **Caching**: Store module in cache by absolute path\n5. **Execution Phase**: Execute in topological order (dependencies first)\n\n### API\n\n```c\n// High-level API\nint execute_file_with_modules(const char *file_path,\n                               int argc, char **argv,\n                               ExecutionContext *ctx);\n\n// Low-level API\nModuleCache* module_cache_new(const char *initial_dir);\nvoid module_cache_free(ModuleCache *cache);\nModule* load_module(ModuleCache *cache, const char *module_path, ExecutionContext *ctx);\nvoid execute_module(Module *module, ModuleCache *cache, ExecutionContext *ctx);\n```\n\n## Testing\n\nTest modules are located in `tests/modules/`:\n\n- `math.hml` - Basic module with exports\n- `test_import_named.hml` - Named import test\n- `test_import_namespace.hml` - Namespace import test\n- `test_import_alias.hml` - Import aliasing test\n\n## Current Limitations\n\n1. **Main Integration**: The module system is implemented but not yet integrated with main.c by default. Files must explicitly use the module API.\n2. **No Package Management**: Only file-based modules are supported (no `hemlock_modules/` or package.json)\n3. **No Standard Library**: No `std/` prefix for built-in modules yet\n4. **No Dynamic Imports**: `import()` as a runtime function is not supported\n5. **No Conditional Exports**: Exports must be at top level\n\n## Future Work (Phase 2+)\n\n- Package resolution from `hemlock_modules/`\n- Standard library with `std/` prefix\n- Dynamic imports with `import()` function\n- Conditional exports\n- Module metadata (`import.meta`)\n- Tree shaking and dead code elimination\n\n## Examples\n\nSee `tests/modules/` for working examples of the module system.\n\nExample module structure:\n```\nproject/\n main.hml\n lib/\n    math.hml\n    string.hml\n    index.hml (barrel module)\n utils/\n     helpers.hml\n```\n\nExample usage:\n```hemlock\n// lib/math.hml\nexport fn add(a, b) { return a + b; }\nexport fn multiply(a, b) { return a * b; }\n\n// lib/index.hml (barrel)\nexport { add, multiply } from \"./math.hml\";\n\n// main.hml\nimport { add } from \"./lib/index.hml\";\nprint(add(2, 3));  // 5\n```\n"}, "Language Guide  Objects": {"id": "language-guide-objects", "content": "# Objects\n\nHemlock implements JavaScript-style objects with heap allocation, dynamic fields, methods, and duck typing. Objects are flexible data structures that combine data and behavior.\n\n## Overview\n\n```hemlock\n// Anonymous object\nlet person = { name: \"Alice\", age: 30, city: \"NYC\" };\nprint(person.name);  // \"Alice\"\n\n// Object with methods\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    }\n};\n\ncounter.increment();\nprint(counter.count);  // 1\n```\n\n## Object Literals\n\n### Basic Syntax\n\n```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"NYC\"\n};\n```\n\n**Syntax:**\n- Curly braces `{}` enclose the object\n- Key-value pairs separated by commas\n- Keys are identifiers (no quotes needed)\n- Values can be any type\n\n### Empty Objects\n\n```hemlock\nlet obj = {};  // Empty object\n\n// Add fields later\nobj.name = \"Alice\";\nobj.age = 30;\n```\n\n### Nested Objects\n\n```hemlock\nlet user = {\n    info: {\n        name: \"Bob\",\n        age: 25\n    },\n    active: true,\n    settings: {\n        theme: \"dark\",\n        notifications: true\n    }\n};\n\nprint(user.info.name);           // \"Bob\"\nprint(user.settings.theme);      // \"dark\"\n```\n\n### Mixed Value Types\n\n```hemlock\nlet mixed = {\n    number: 42,\n    text: \"hello\",\n    flag: true,\n    data: null,\n    items: [1, 2, 3],\n    config: { x: 10, y: 20 }\n};\n```\n\n## Field Access\n\n### Dot Notation\n\n```hemlock\nlet person = { name: \"Alice\", age: 30 };\n\n// Read field\nlet name = person.name;      // \"Alice\"\nlet age = person.age;        // 30\n\n// Modify field\nperson.age = 31;\nprint(person.age);           // 31\n```\n\n### Dynamic Field Addition\n\nAdd new fields at runtime:\n\n```hemlock\nlet person = { name: \"Alice\" };\n\n// Add new field\nperson.email = \"alice@example.com\";\nperson.phone = \"555-1234\";\n\nprint(person.email);  // \"alice@example.com\"\n```\n\n### Field Deletion\n\n**Note:** Field deletion is not currently supported. Set to `null` instead:\n\n```hemlock\nlet obj = { x: 10, y: 20 };\n\n// Cannot delete fields (not supported)\n// obj.x = undefined;  // No 'undefined' in Hemlock\n\n// Workaround: Set to null\nobj.x = null;\n```\n\n## Methods and `self`\n\n### Defining Methods\n\nMethods are functions stored in object fields:\n\n```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    },\n    decrement: fn() {\n        self.count = self.count - 1;\n    },\n    get: fn() {\n        return self.count;\n    }\n};\n```\n\n### The `self` Keyword\n\nWhen a function is called as a method, `self` is automatically bound to the object:\n\n```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;  // self refers to counter\n    }\n};\n\ncounter.increment();  // self is bound to counter\nprint(counter.count);  // 1\n```\n\n**How it works:**\n- Method calls are detected by checking if function expression is property access\n- `self` is automatically bound to the object at call time\n- `self` is read-only (cannot reassign `self` itself)\n\n### Method Call Detection\n\n```hemlock\nlet obj = {\n    value: 10,\n    method: fn() {\n        return self.value;\n    }\n};\n\n// Called as method - self is bound\nprint(obj.method());  // 10\n\n// Called as function - self is null (error)\nlet f = obj.method;\nprint(f());  // ERROR: self is not defined\n```\n\n### Methods with Parameters\n\n```hemlock\nlet calculator = {\n    result: 0,\n    add: fn(x) {\n        self.result = self.result + x;\n    },\n    multiply: fn(x) {\n        self.result = self.result * x;\n    },\n    get: fn() {\n        return self.result;\n    }\n};\n\ncalculator.add(5);\ncalculator.multiply(2);\nprint(calculator.get());  // 10\n```\n\n## Type Definitions with `define`\n\n### Basic Type Definition\n\nDefine object shapes with `define`:\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active: bool,\n}\n\n// Create object and assign to typed variable\nlet p = { name: \"Alice\", age: 30, active: true };\nlet typed_p: Person = p;  // Duck typing validates structure\n\nprint(typeof(typed_p));  // \"Person\"\n```\n\n**What `define` does:**\n- Declares a type with required fields\n- Enables duck typing validation\n- Sets the object's type name for `typeof()`\n\n### Duck Typing\n\nObjects are validated against `define` using **structural compatibility**:\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\n//  OK: Has all required fields\nlet p1: Person = { name: \"Alice\", age: 30 };\n\n//  OK: Extra fields are allowed\nlet p2: Person = {\n    name: \"Bob\",\n    age: 25,\n    city: \"NYC\",\n    active: true\n};\n\n//  ERROR: Missing required field 'age'\nlet p3: Person = { name: \"Carol\" };\n\n//  ERROR: Wrong type for 'age'\nlet p4: Person = { name: \"Dave\", age: \"thirty\" };\n```\n\n**Duck typing rules:**\n- All required fields must be present\n- Field types must match\n- Extra fields are allowed and preserved\n- Validation happens at assignment time\n\n### Optional Fields\n\nFields can be optional with default values:\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,       // Optional with default value\n    nickname?: string,   // Optional, defaults to null\n}\n\n// Object with only required fields\nlet p = { name: \"Alice\", age: 30 };\nlet typed_p: Person = p;\n\nprint(typed_p.active);    // true (default applied)\nprint(typed_p.nickname);  // null (no default)\n\n// Can override optional fields\nlet p2: Person = { name: \"Bob\", age: 25, active: false };\nprint(p2.active);  // false (overridden)\n```\n\n**Optional field syntax:**\n- `field?: default_value` - Optional with default\n- `field?: type` - Optional with type annotation, defaults to null\n- Optional fields are added during duck typing if missing\n\n### Type Checking\n\n```hemlock\ndefine Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = { x: 10, y: 20 };\nlet point: Point = p;  // Type checking happens here\n\nprint(typeof(point));  // \"Point\"\nprint(typeof(p));      // \"object\" (original is still anonymous)\n```\n\n**When type checking happens:**\n- At assignment time to typed variable\n- Validates all required fields are present\n- Validates field types match (with implicit conversions)\n- Sets the object's type name\n\n## JSON Serialization\n\n### Serialize to JSON\n\nConvert objects to JSON strings:\n\n```hemlock\n// obj.serialize() - Convert object to JSON string\nlet obj = { x: 10, y: 20, name: \"test\" };\nlet json = obj.serialize();\nprint(json);  // {\"x\":10,\"y\":20,\"name\":\"test\"}\n\n// Nested objects\nlet nested = { inner: { a: 1, b: 2 }, outer: 3 };\nprint(nested.serialize());  // {\"inner\":{\"a\":1,\"b\":2},\"outer\":3}\n```\n\n### Deserialize from JSON\n\nParse JSON strings back to objects:\n\n```hemlock\n// json.deserialize() - Parse JSON string to object\nlet json_str = '{\"x\":10,\"y\":20,\"name\":\"test\"}';\nlet obj = json_str.deserialize();\n\nprint(obj.name);   // \"test\"\nprint(obj.x);      // 10\n```\n\n### Cycle Detection\n\nCircular references are detected and cause errors:\n\n```hemlock\nlet obj = { x: 10 };\nobj.me = obj;  // Create circular reference\n\nobj.serialize();  // ERROR: serialize() detected circular reference\n```\n\n### Supported Types\n\nJSON serialization supports:\n\n- **Numbers**: i8-i32, u8-u32, f32, f64\n- **Booleans**: true, false\n- **Strings**: With escape sequences\n- **Null**: null value\n- **Objects**: Nested objects\n- **Arrays**: Nested arrays\n\n**Not supported:**\n- Functions (silently omitted)\n- Pointers (error)\n- Buffers (error)\n\n## Built-in Functions\n\n### `typeof(value)`\n\nReturns the type name as a string:\n\n```hemlock\nlet obj = { x: 10 };\nprint(typeof(obj));  // \"object\"\n\ndefine Person { name: string, age: i32 }\nlet p: Person = { name: \"Alice\", age: 30 };\nprint(typeof(p));    // \"Person\"\n```\n\n**Return values:**\n- Anonymous objects: `\"object\"`\n- Typed objects: Custom type name (e.g., `\"Person\"`)\n\n## Implementation Details\n\n### Memory Model\n\n- **Heap-allocated** - All objects are allocated on the heap\n- **Shallow copy** - Assignment copies the reference, not the object\n- **Dynamic fields** - Stored as dynamic arrays of name/value pairs\n- **No automatic cleanup** - Objects are never freed in v0.1\n\n### Reference Semantics\n\n```hemlock\nlet obj1 = { x: 10 };\nlet obj2 = obj1;  // Shallow copy (same reference)\n\nobj2.x = 20;\nprint(obj1.x);  // 20 (both refer to same object)\n```\n\n### Method Storage\n\nMethods are just functions stored in fields:\n\n```hemlock\nlet obj = {\n    value: 10,\n    method: fn() { return self.value; }\n};\n\n// method is a function stored in obj.method\nprint(typeof(obj.method));  // \"function\"\n```\n\n## Common Patterns\n\n### Pattern: Constructor Function\n\n```hemlock\nfn createPerson(name: string, age: i32) {\n    return {\n        name: name,\n        age: age,\n        greet: fn() {\n            return \"Hi, I'm \" + self.name;\n        }\n    };\n}\n\nlet person = createPerson(\"Alice\", 30);\nprint(person.greet());  // \"Hi, I'm Alice\"\n```\n\n### Pattern: Object Builder\n\n```hemlock\nfn PersonBuilder() {\n    return {\n        name: null,\n        age: null,\n\n        setName: fn(n) {\n            self.name = n;\n            return self;  // Enable chaining\n        },\n\n        setAge: fn(a) {\n            self.age = a;\n            return self;\n        },\n\n        build: fn() {\n            return { name: self.name, age: self.age };\n        }\n    };\n}\n\nlet person = PersonBuilder()\n    .setName(\"Alice\")\n    .setAge(30)\n    .build();\n```\n\n### Pattern: State Object\n\n```hemlock\nlet state = {\n    status: \"idle\",\n    data: null,\n    error: null,\n\n    setState: fn(new_status) {\n        self.status = new_status;\n    },\n\n    setData: fn(new_data) {\n        self.data = new_data;\n        self.status = \"success\";\n    },\n\n    setError: fn(err) {\n        self.error = err;\n        self.status = \"error\";\n    }\n};\n```\n\n### Pattern: Configuration Object\n\n```hemlock\nlet config = {\n    defaults: {\n        timeout: 30,\n        retries: 3,\n        debug: false\n    },\n\n    get: fn(key) {\n        if (self.defaults[key] != null) {\n            return self.defaults[key];\n        }\n        return null;\n    },\n\n    set: fn(key, value) {\n        self.defaults[key] = value;\n    }\n};\n```\n\n## Best Practices\n\n1. **Use `define` for structure** - Document expected object shapes\n2. **Prefer factory functions** - Create objects with constructors\n3. **Keep objects simple** - Don't nest too deeply\n4. **Document `self` usage** - Make method behavior clear\n5. **Validate on assignment** - Use duck typing to catch errors early\n6. **Avoid circular references** - Will cause serialization errors\n7. **Use optional fields** - Provide sensible defaults\n\n## Common Pitfalls\n\n### Pitfall: Reference vs. Value\n\n```hemlock\nlet obj1 = { x: 10 };\nlet obj2 = obj1;  // Shallow copy\n\nobj2.x = 20;\nprint(obj1.x);  // 20 (surprise! both changed)\n\n// To avoid: Create new object\nlet obj3 = { x: obj1.x };  // Deep copy (manual)\n```\n\n### Pitfall: `self` in Non-Method Calls\n\n```hemlock\nlet obj = {\n    value: 10,\n    method: fn() { return self.value; }\n};\n\n// Works: Called as method\nprint(obj.method());  // 10\n\n// ERROR: Called as function\nlet f = obj.method;\nprint(f());  // ERROR: self is not defined\n```\n\n### Pitfall: Memory Leaks\n\n```hemlock\n// Objects are never freed in v0.1\nfn create_objects() {\n    let obj = { data: alloc(1000) };\n    // obj never freed - memory leak\n}\n\ncreate_objects();  // Leaks memory\n```\n\n### Pitfall: Type Confusion\n\n```hemlock\nlet obj = { x: 10 };\n\ndefine Point { x: i32, y: i32 }\n\n// ERROR: Missing required field 'y'\nlet p: Point = obj;\n```\n\n## Examples\n\n### Example: Vector Math\n\n```hemlock\nfn createVector(x, y) {\n    return {\n        x: x,\n        y: y,\n\n        add: fn(other) {\n            return createVector(\n                self.x + other.x,\n                self.y + other.y\n            );\n        },\n\n        length: fn() {\n            return sqrt(self.x * self.x + self.y * self.y);\n        },\n\n        toString: fn() {\n            return \"(\" + typeof(self.x) + \", \" + typeof(self.y) + \")\";\n        }\n    };\n}\n\nlet v1 = createVector(3, 4);\nlet v2 = createVector(1, 2);\nlet v3 = v1.add(v2);\n\nprint(v3.toString());  // \"(4, 6)\"\n```\n\n### Example: Simple Database\n\n```hemlock\nfn createDatabase() {\n    let records = [];\n    let next_id = 1;\n\n    return {\n        insert: fn(data) {\n            let record = { id: next_id, data: data };\n            records.push(record);\n            next_id = next_id + 1;\n            return record.id;\n        },\n\n        find: fn(id) {\n            let i = 0;\n            while (i < records.length) {\n                if (records[i].id == id) {\n                    return records[i];\n                }\n                i = i + 1;\n            }\n            return null;\n        },\n\n        count: fn() {\n            return records.length;\n        }\n    };\n}\n\nlet db = createDatabase();\nlet id = db.insert({ name: \"Alice\", age: 30 });\nlet record = db.find(id);\nprint(record.data.name);  // \"Alice\"\n```\n\n### Example: Event Emitter\n\n```hemlock\nfn createEventEmitter() {\n    let listeners = {};\n\n    return {\n        on: fn(event, handler) {\n            if (listeners[event] == null) {\n                listeners[event] = [];\n            }\n            listeners[event].push(handler);\n        },\n\n        emit: fn(event, data) {\n            if (listeners[event] != null) {\n                let i = 0;\n                while (i < listeners[event].length) {\n                    listeners[event][i](data);\n                    i = i + 1;\n                }\n            }\n        }\n    };\n}\n\nlet emitter = createEventEmitter();\n\nemitter.on(\"message\", fn(data) {\n    print(\"Received: \" + data);\n});\n\nemitter.emit(\"message\", \"Hello!\");\n```\n\n## Limitations (v0.1)\n\nCurrent limitations:\n\n- **No reference counting** - Objects never freed automatically\n- **No deep copy** - Must manually copy nested objects\n- **No pass-by-value** - Objects always passed by reference\n- **No object spread** - No `{...obj}` syntax\n- **No computed properties** - No `{[key]: value}` syntax\n- **`self` is read-only** - Cannot reassign `self` in methods\n- **No property deletion** - Cannot remove fields once added\n\n## Related Topics\n\n- [Functions](functions.md) - Methods are functions stored in objects\n- [Arrays](arrays.md) - Arrays are also object-like\n- [Types](types.md) - Duck typing and type definitions\n- [Error Handling](error-handling.md) - Throwing error objects\n\n## See Also\n\n- **Duck Typing**: See CLAUDE.md section \"Objects\" for duck typing details\n- **JSON**: See CLAUDE.md for JSON serialization details\n- **Memory**: See [Memory](memory.md) for object allocation\n"}, "Language Guide  Runes": {"id": "language-guide-runes", "content": "# Runes\n\nRunes represent **Unicode codepoints** (U+0000 to U+10FFFF) as a distinct type for character manipulation in Hemlock. Unlike bytes (u8), runes are full Unicode characters that can represent any character in any language or emoji.\n\n## Overview\n\n```hemlock\nlet ch = 'A';           // Rune literal\nlet emoji = '';       // Multi-byte character as single rune\nprint(ch);              // 'A'\nprint(emoji);           // U+1F680\n\nlet s = \"Hello \" + '!'; // String + rune concatenation\nlet r = '>' + \" msg\";   // Rune + string concatenation\n```\n\n## What is a Rune?\n\nA rune is a **32-bit value** representing a Unicode codepoint:\n\n- **Range:** 0 to 0x10FFFF (1,114,111 valid codepoints)\n- **Not a numeric type** - Used for character representation\n- **Distinct from u8/char** - Runes are full Unicode, u8 is just bytes\n- **Returned by string indexing** - `str[0]` returns a rune, not a byte\n\n**Why runes?**\n- Hemlock strings are UTF-8 encoded\n- A single Unicode character can be 1-4 bytes in UTF-8\n- Runes allow working with complete characters, not partial bytes\n\n## Rune Literals\n\n### Basic Syntax\n\nSingle quotes denote rune literals:\n\n```hemlock\nlet a = 'A';            // ASCII character\nlet b = '0';            // Digit character\nlet c = '!';            // Punctuation\nlet d = ' ';            // Space\n```\n\n### Multi-byte UTF-8 Characters\n\nRunes can represent any Unicode character:\n\n```hemlock\n// Emoji\nlet rocket = '';      // Emoji (U+1F680)\nlet heart = '';        // Heart (U+2764)\nlet smile = '';       // Grinning face (U+1F600)\n\n// CJK characters\nlet chinese = '';     // Chinese (U+4E2D)\nlet japanese = '';    // Hiragana (U+3042)\nlet korean = '';      // Hangul (U+D55C)\n\n// Symbols\nlet check = '';        // Checkmark (U+2713)\nlet arrow = '';        // Rightwards arrow (U+2192)\n```\n\n### Escape Sequences\n\nCommon escape sequences for special characters:\n\n```hemlock\nlet newline = '\\n';     // Newline (U+000A)\nlet tab = '\\t';         // Tab (U+0009)\nlet backslash = '\\\\';   // Backslash (U+005C)\nlet quote = '\\'';       // Single quote (U+0027)\nlet dquote = '\"';       // Double quote (U+0022)\nlet null_char = '\\0';   // Null character (U+0000)\nlet cr = '\\r';          // Carriage return (U+000D)\n```\n\n**Available escape sequences:**\n- `\\n` - Newline (line feed)\n- `\\t` - Horizontal tab\n- `\\r` - Carriage return\n- `\\0` - Null character\n- `\\\\` - Backslash\n- `\\'` - Single quote\n- `\\\"` - Double quote\n\n### Unicode Escapes\n\nUse `\\u{XXXXXX}` syntax for Unicode codepoints (up to 6 hex digits):\n\n```hemlock\nlet rocket = '\\u{1F680}';   //  Emoji via Unicode escape\nlet heart = '\\u{2764}';     //  Heart\nlet ascii = '\\u{41}';       // 'A' via escape\nlet max = '\\u{10FFFF}';     // Maximum Unicode codepoint\n\n// Leading zeros optional\nlet a = '\\u{41}';           // Same as '\\u{0041}'\nlet b = '\\u{0041}';\n```\n\n**Rules:**\n- Range: `\\u{0}` to `\\u{10FFFF}`\n- Hex digits: 1 to 6 digits\n- Case insensitive: `\\u{1F680}` or `\\u{1f680}`\n- Values outside valid Unicode range cause error\n\n## String + Rune Concatenation\n\nRunes can be concatenated with strings:\n\n```hemlock\n// String + rune\nlet greeting = \"Hello\" + '!';       // \"Hello!\"\nlet decorated = \"Text\" + '';       // \"Text\"\n\n// Rune + string\nlet prefix = '>' + \" Message\";      // \"> Message\"\nlet bullet = '' + \" Item\";         // \" Item\"\n\n// Multiple concatenations\nlet msg = \"Hi \" + '' + \" World \" + '';  // \"Hi  World \"\n\n// Method chaining works\nlet result = ('>' + \" Important\").to_upper();  // \"> IMPORTANT\"\n```\n\n**How it works:**\n- Runes are automatically encoded to UTF-8\n- Converted to strings during concatenation\n- The string concatenation operator handles this transparently\n\n## Type Conversions\n\nRunes can convert to/from other types.\n\n### Integer  Rune\n\nConvert between integers and runes to work with codepoint values:\n\n```hemlock\n// Integer to rune (codepoint value)\nlet code: rune = 65;            // 'A' (ASCII 65)\nlet emoji_code: rune = 128640;  // U+1F680 ()\n\n// Rune to integer (get codepoint value)\nlet r = 'Z';\nlet value: i32 = r;             // 90 (ASCII value)\n\nlet rocket = '';\nlet code: i32 = rocket;         // 128640 (U+1F680)\n```\n\n**Range checking:**\n- Integer to rune: Must be in [0, 0x10FFFF]\n- Out of range values cause runtime error\n- Rune to integer: Always succeeds (returns codepoint)\n\n### Rune  String\n\nRunes can be explicitly converted to strings:\n\n```hemlock\n// Explicit conversion\nlet ch: string = 'H';           // \"H\"\nlet emoji: string = '';       // \"\"\n\n// Automatic during concatenation\nlet s = \"\" + 'A';               // \"A\"\nlet s2 = \"x\" + 'y' + \"z\";       // \"xyz\"\n```\n\n### u8 (Byte)  Rune\n\nAny u8 value (0-255) can convert to rune:\n\n```hemlock\n// ASCII range (0-127)\nlet byte: u8 = 65;\nlet rune_val: rune = byte;      // 'A'\n\n// Extended ASCII / Latin-1 (128-255)\nlet extended: u8 = 200;\nlet r: rune = extended;         // U+00C8 ()\n\n// Note: Values 0-127 are ASCII, 128-255 are Latin-1\n```\n\n### Chained Conversions\n\nType conversions can be chained:\n\n```hemlock\n// i32  rune  string\nlet code: i32 = 128512;         // Grinning face codepoint\nlet r: rune = code;             // \nlet s: string = r;              // \"\"\n\n// All in one expression\nlet emoji: string = 128640;     // Implicit i32  rune  string ()\n```\n\n## Rune Operations\n\n### Printing\n\nHow runes are displayed depends on the codepoint:\n\n```hemlock\nlet ascii = 'A';\nprint(ascii);                   // 'A' (quoted, printable ASCII)\n\nlet emoji = '';\nprint(emoji);                   // U+1F680 (Unicode notation for non-ASCII)\n\nlet tab = '\\t';\nprint(tab);                     // U+0009 (non-printable as hex)\n\nlet space = ' ';\nprint(space);                   // ' ' (printable)\n```\n\n**Print format:**\n- Printable ASCII (32-126): Quoted character `'A'`\n- Non-printable or Unicode: Hex notation `U+XXXX`\n\n### Type Checking\n\nUse `typeof()` to check if a value is a rune:\n\n```hemlock\nlet r = '';\nprint(typeof(r));               // \"rune\"\n\nlet s = \"text\";\nlet ch = s[0];\nprint(typeof(ch));              // \"rune\" (indexing returns runes)\n\nlet num = 65;\nprint(typeof(num));             // \"i32\"\n```\n\n### Comparison\n\nRunes can be compared for equality:\n\n```hemlock\nlet a = 'A';\nlet b = 'B';\nprint(a == a);                  // true\nprint(a == b);                  // false\n\n// Case sensitive\nlet upper = 'A';\nlet lower = 'a';\nprint(upper == lower);          // false\n\n// Runes can be compared with integers (codepoint values)\nprint(a == 65);                 // true (implicit conversion)\nprint('' == 128640);          // true\n```\n\n**Comparison operators:**\n- `==` - Equal\n- `!=` - Not equal\n- `<`, `>`, `<=`, `>=` - Codepoint order\n\n```hemlock\nprint('A' < 'B');               // true (65 < 66)\nprint('a' > 'Z');               // true (97 > 90)\n```\n\n## Working with String Indexing\n\nString indexing returns runes, not bytes:\n\n```hemlock\nlet s = \"Hello\";\nlet h = s[0];                   // 'H' (rune)\nlet rocket = s[5];              // '' (rune)\n\nprint(typeof(h));               // \"rune\"\nprint(typeof(rocket));          // \"rune\"\n\n// Convert to string if needed\nlet h_str: string = h;          // \"H\"\nlet rocket_str: string = rocket; // \"\"\n```\n\n**Important:** String indexing uses codepoint positions, not byte offsets:\n\n```hemlock\nlet text = \"Hi!\";\n// Codepoint positions: 0='H', 1='i', 2='', 3='!'\n// Byte positions:      0='H', 1='i', 2-5='', 6='!'\n\nlet r = text[2];                // '' (codepoint 2)\nprint(typeof(r));               // \"rune\"\n```\n\n## Examples\n\n### Example: Character Classification\n\n```hemlock\nfn is_digit(r: rune): bool {\n    return r >= '0' && r <= '9';\n}\n\nfn is_upper(r: rune): bool {\n    return r >= 'A' && r <= 'Z';\n}\n\nfn is_lower(r: rune): bool {\n    return r >= 'a' && r <= 'z';\n}\n\nprint(is_digit('5'));           // true\nprint(is_upper('A'));           // true\nprint(is_lower('z'));           // true\n```\n\n### Example: Case Conversion\n\n```hemlock\nfn to_upper_rune(r: rune): rune {\n    if (r >= 'a' && r <= 'z') {\n        // Convert to uppercase (subtract 32)\n        let code: i32 = r;\n        code = code - 32;\n        return code;\n    }\n    return r;\n}\n\nfn to_lower_rune(r: rune): rune {\n    if (r >= 'A' && r <= 'Z') {\n        // Convert to lowercase (add 32)\n        let code: i32 = r;\n        code = code + 32;\n        return code;\n    }\n    return r;\n}\n\nprint(to_upper_rune('a'));      // 'A'\nprint(to_lower_rune('Z'));      // 'z'\n```\n\n### Example: Character Iteration\n\n```hemlock\nfn print_chars(s: string) {\n    let i = 0;\n    while (i < s.length) {\n        let ch = s[i];\n        print(\"Position \" + typeof(i) + \": \" + typeof(ch));\n        i = i + 1;\n    }\n}\n\nprint_chars(\"Hi\");\n// Position 0: 'H'\n// Position 1: 'i'\n// Position 2: U+1F680\n```\n\n### Example: Building Strings from Runes\n\n```hemlock\nfn repeat_char(ch: rune, count: i32): string {\n    let result = \"\";\n    let i = 0;\n    while (i < count) {\n        result = result + ch;\n        i = i + 1;\n    }\n    return result;\n}\n\nlet line = repeat_char('=', 40);  // \"========================================\"\nlet stars = repeat_char('', 5);  // \"\"\n```\n\n## Common Patterns\n\n### Pattern: Character Filter\n\n```hemlock\nfn filter_digits(s: string): string {\n    let result = \"\";\n    let i = 0;\n    while (i < s.length) {\n        let ch = s[i];\n        if (ch >= '0' && ch <= '9') {\n            result = result + ch;\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nlet text = \"abc123def456\";\nlet digits = filter_digits(text);  // \"123456\"\n```\n\n### Pattern: Character Counting\n\n```hemlock\nfn count_char(s: string, target: rune): i32 {\n    let count = 0;\n    let i = 0;\n    while (i < s.length) {\n        if (s[i] == target) {\n            count = count + 1;\n        }\n        i = i + 1;\n    }\n    return count;\n}\n\nlet text = \"hello world\";\nlet l_count = count_char(text, 'l');  // 3\nlet o_count = count_char(text, 'o');  // 2\n```\n\n## Best Practices\n\n1. **Use runes for character operations** - Don't try to work with bytes for text\n2. **String indexing returns runes** - Remember that `str[i]` gives you a rune\n3. **Unicode-aware comparisons** - Runes handle any Unicode character\n4. **Convert when needed** - Runes convert easily to strings and integers\n5. **Test with emoji** - Always test character operations with multi-byte characters\n\n## Common Pitfalls\n\n### Pitfall: Rune vs. Byte Confusion\n\n```hemlock\n// DON'T: Treat runes as bytes\nlet r: rune = '';\nlet b: u8 = r;              // ERROR: Rune codepoint 128640 doesn't fit in u8\n\n// DO: Use appropriate conversions\nlet r: rune = '';\nlet code: i32 = r;          // OK: 128640\n```\n\n### Pitfall: String Byte Indexing\n\n```hemlock\n// DON'T: Assume byte indexing\nlet s = \"\";\nlet byte = s.byte_at(0);    // 240 (first UTF-8 byte, not complete char)\n\n// DO: Use codepoint indexing\nlet s = \"\";\nlet rune = s[0];            // '' (complete character)\nlet rune2 = s.char_at(0);   // '' (explicit method)\n```\n\n## Related Topics\n\n- [Strings](strings.md) - String operations and UTF-8 handling\n- [Types](types.md) - Type system and conversions\n- [Control Flow](control-flow.md) - Using runes in comparisons\n\n## See Also\n\n- **Unicode Standard**: Unicode codepoints are defined by the Unicode Consortium\n- **UTF-8 Encoding**: See [Strings](strings.md) for UTF-8 details\n- **Type Conversions**: See [Types](types.md) for conversion rules\n"}, "Language Guide  Strings": {"id": "language-guide-strings", "content": "# Strings\n\nHemlock strings are **UTF-8 first-class mutable sequences** with full Unicode support and a rich set of methods for text processing. Unlike many languages, Hemlock strings are mutable and work natively with Unicode codepoints.\n\n## Overview\n\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';             // mutate with rune (now \"Hello\")\nprint(s.length);        // 5 (codepoint count)\nlet c = s[0];           // returns rune (Unicode codepoint)\nlet msg = s + \" world\"; // concatenation\nlet emoji = \"\";\nprint(emoji.length);    // 1 (one codepoint)\nprint(emoji.byte_length); // 4 (four UTF-8 bytes)\n```\n\n## Properties\n\nHemlock strings have these key characteristics:\n\n- **UTF-8 encoded** - Full Unicode support (U+0000 to U+10FFFF)\n- **Mutable** - Unlike Python, JavaScript, and Java strings\n- **Codepoint-based indexing** - Returns `rune` (Unicode codepoint), not byte\n- **Heap-allocated** - With internal capacity tracking\n- **Two length properties**:\n  - `.length` - Codepoint count (number of characters)\n  - `.byte_length` - Byte count (UTF-8 encoding size)\n\n## UTF-8 Behavior\n\nAll string operations work with **codepoints** (characters), not bytes:\n\n```hemlock\nlet text = \"HelloWorld\";\nprint(text.length);        // 11 (codepoints)\nprint(text.byte_length);   // 15 (bytes, emoji is 4 bytes)\n\n// Indexing uses codepoints\nlet h = text[0];           // 'H' (rune)\nlet rocket = text[5];      // '' (rune)\n```\n\n**Multi-byte characters count as one:**\n```hemlock\n\"Hello\".length;      // 5\n\"\".length;         // 1 (one emoji)\n\"\".length;       // 2 (two Chinese characters)\n\"caf\".length;       // 4 ( is one codepoint)\n```\n\n## String Literals\n\n```hemlock\n// Basic strings\nlet s1 = \"hello\";\nlet s2 = \"world\";\n\n// With escape sequences\nlet s3 = \"Line 1\\nLine 2\\ttabbed\";\nlet s4 = \"Quote: \\\"Hello\\\"\";\nlet s5 = \"Backslash: \\\\\";\n\n// Unicode characters\nlet s6 = \" Emoji\";\nlet s7 = \"\";\n```\n\n## Indexing and Mutation\n\n### Reading Characters\n\nIndexing returns a `rune` (Unicode codepoint):\n\n```hemlock\nlet s = \"Hello\";\nlet first = s[0];      // 'H' (rune)\nlet last = s[4];       // 'o' (rune)\n\n// UTF-8 example\nlet emoji = \"Hi!\";\nlet rocket = emoji[2];  // '' (rune at codepoint index 2)\n```\n\n### Writing Characters\n\nStrings are mutable - you can modify individual characters:\n\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';            // Now \"Hello\"\ns[4] = '!';            // Now \"Hell!\"\n\n// With Unicode\nlet msg = \"Go!\";\nmsg[0] = '';         // Now \"o!\"\n```\n\n## Concatenation\n\nUse `+` to concatenate strings:\n\n```hemlock\nlet greeting = \"Hello\" + \" \" + \"World\";  // \"Hello World\"\n\n// With variables\nlet name = \"Alice\";\nlet msg = \"Hi, \" + name + \"!\";  // \"Hi, Alice!\"\n\n// With runes (see Runes documentation)\nlet s = \"Hello\" + '!';          // \"Hello!\"\n```\n\n## String Methods\n\nHemlock provides 18 string methods for comprehensive text manipulation.\n\n### Substring & Slicing\n\n**`substr(start, length)`** - Extract substring by position and length:\n```hemlock\nlet s = \"hello world\";\nlet sub = s.substr(6, 5);       // \"world\" (start at 6, length 5)\nlet first = s.substr(0, 5);     // \"hello\"\n\n// UTF-8 example\nlet text = \"Hi!\";\nlet emoji = text.substr(2, 1);  // \"\" (position 2, length 1)\n```\n\n**`slice(start, end)`** - Extract substring by range (end exclusive):\n```hemlock\nlet s = \"hello world\";\nlet slice = s.slice(0, 5);      // \"hello\" (index 0 to 4)\nlet slice2 = s.slice(6, 11);    // \"world\"\n```\n\n**Difference:**\n- `substr(start, length)` - Uses length parameter\n- `slice(start, end)` - Uses end index (exclusive)\n\n### Search & Find\n\n**`find(needle)`** - Find first occurrence:\n```hemlock\nlet s = \"hello world\";\nlet pos = s.find(\"world\");      // 6 (index of first occurrence)\nlet pos2 = s.find(\"foo\");       // -1 (not found)\nlet pos3 = s.find(\"l\");         // 2 (first 'l')\n```\n\n**`contains(needle)`** - Check if string contains substring:\n```hemlock\nlet s = \"hello world\";\nlet has = s.contains(\"world\");  // true\nlet has2 = s.contains(\"foo\");   // false\n```\n\n### Split & Trim\n\n**`split(delimiter)`** - Split into array of strings:\n```hemlock\nlet csv = \"apple,banana,cherry\";\nlet parts = csv.split(\",\");     // [\"apple\", \"banana\", \"cherry\"]\n\nlet words = \"one two three\".split(\" \");  // [\"one\", \"two\", \"three\"]\n\n// Empty delimiter splits by character\nlet chars = \"abc\".split(\"\");    // [\"a\", \"b\", \"c\"]\n```\n\n**`trim()`** - Remove leading/trailing whitespace:\n```hemlock\nlet s = \"  hello  \";\nlet clean = s.trim();           // \"hello\"\n\nlet s2 = \"\\t\\ntext\\n\\t\";\nlet clean2 = s2.trim();         // \"text\"\n```\n\n### Case Conversion\n\n**`to_upper()`** - Convert to uppercase:\n```hemlock\nlet s = \"hello world\";\nlet upper = s.to_upper();       // \"HELLO WORLD\"\n\n// Preserves non-ASCII\nlet s2 = \"caf\";\nlet upper2 = s2.to_upper();     // \"CAF\"\n```\n\n**`to_lower()`** - Convert to lowercase:\n```hemlock\nlet s = \"HELLO WORLD\";\nlet lower = s.to_lower();       // \"hello world\"\n```\n\n### Prefix/Suffix Checking\n\n**`starts_with(prefix)`** - Check if starts with prefix:\n```hemlock\nlet s = \"hello world\";\nlet starts = s.starts_with(\"hello\");  // true\nlet starts2 = s.starts_with(\"world\"); // false\n```\n\n**`ends_with(suffix)`** - Check if ends with suffix:\n```hemlock\nlet s = \"hello world\";\nlet ends = s.ends_with(\"world\");      // true\nlet ends2 = s.ends_with(\"hello\");     // false\n```\n\n### Replacement\n\n**`replace(old, new)`** - Replace first occurrence:\n```hemlock\nlet s = \"hello world\";\nlet s2 = s.replace(\"world\", \"there\");      // \"hello there\"\n\nlet s3 = \"foo foo foo\";\nlet s4 = s3.replace(\"foo\", \"bar\");         // \"bar foo foo\" (first only)\n```\n\n**`replace_all(old, new)`** - Replace all occurrences:\n```hemlock\nlet s = \"foo foo foo\";\nlet s2 = s.replace_all(\"foo\", \"bar\");      // \"bar bar bar\"\n\nlet s3 = \"hello world, world!\";\nlet s4 = s3.replace_all(\"world\", \"hemlock\"); // \"hello hemlock, hemlock!\"\n```\n\n### Repetition\n\n**`repeat(count)`** - Repeat string n times:\n```hemlock\nlet s = \"ha\";\nlet laugh = s.repeat(3);        // \"hahaha\"\n\nlet line = \"=\".repeat(40);      // \"========================================\"\n```\n\n### Character & Byte Access\n\n**`char_at(index)`** - Get Unicode codepoint at index (returns rune):\n```hemlock\nlet s = \"hello\";\nlet char = s.char_at(0);        // 'h' (rune)\n\n// UTF-8 example\nlet emoji = \"\";\nlet rocket = emoji.char_at(0);  // Returns rune U+1F680\n```\n\n**`chars()`** - Convert to array of runes (codepoints):\n```hemlock\nlet s = \"hello\";\nlet chars = s.chars();          // ['h', 'e', 'l', 'l', 'o'] (array of runes)\n\n// UTF-8 example\nlet text = \"Hi\";\nlet chars2 = text.chars();      // ['H', 'i', '']\n```\n\n**`byte_at(index)`** - Get byte value at index (returns u8):\n```hemlock\nlet s = \"hello\";\nlet byte = s.byte_at(0);        // 104 (ASCII value of 'h')\n\n// UTF-8 example\nlet emoji = \"\";\nlet first_byte = emoji.byte_at(0);  // 240 (first UTF-8 byte)\n```\n\n**`bytes()`** - Convert to array of bytes (u8 values):\n```hemlock\nlet s = \"hello\";\nlet bytes = s.bytes();          // [104, 101, 108, 108, 111] (array of u8)\n\n// UTF-8 example\nlet emoji = \"\";\nlet bytes2 = emoji.bytes();     // [240, 159, 154, 128] (4 UTF-8 bytes)\n```\n\n**`to_bytes()`** - Convert to buffer for low-level access:\n```hemlock\nlet s = \"hello\";\nlet buf = s.to_bytes();         // Returns buffer with UTF-8 bytes\nprint(buf.length);              // 5\nfree(buf);                      // Remember to free\n```\n\n## Method Chaining\n\nAll string methods return new strings, enabling chaining:\n\n```hemlock\nlet result = \"  Hello World  \"\n    .trim()\n    .to_lower()\n    .replace(\"world\", \"hemlock\");  // \"hello hemlock\"\n\nlet processed = \"foo,bar,baz\"\n    .split(\",\")\n    .join(\" | \")\n    .to_upper();                    // \"FOO | BAR | BAZ\"\n```\n\n## Complete Method Reference\n\n| Method | Parameters | Returns | Description |\n|--------|-----------|---------|-------------|\n| `substr(start, length)` | i32, i32 | string | Extract substring by position and length |\n| `slice(start, end)` | i32, i32 | string | Extract substring by range (end exclusive) |\n| `find(needle)` | string | i32 | Find first occurrence (-1 if not found) |\n| `contains(needle)` | string | bool | Check if contains substring |\n| `split(delimiter)` | string | array | Split into array of strings |\n| `trim()` | - | string | Remove leading/trailing whitespace |\n| `to_upper()` | - | string | Convert to uppercase |\n| `to_lower()` | - | string | Convert to lowercase |\n| `starts_with(prefix)` | string | bool | Check if starts with prefix |\n| `ends_with(suffix)` | string | bool | Check if ends with suffix |\n| `replace(old, new)` | string, string | string | Replace first occurrence |\n| `replace_all(old, new)` | string, string | string | Replace all occurrences |\n| `repeat(count)` | i32 | string | Repeat string n times |\n| `char_at(index)` | i32 | rune | Get codepoint at index |\n| `byte_at(index)` | i32 | u8 | Get byte value at index |\n| `chars()` | - | array | Convert to array of runes |\n| `bytes()` | - | array | Convert to array of u8 bytes |\n| `to_bytes()` | - | buffer | Convert to buffer (must free) |\n\n## Examples\n\n### Example: Text Processing\n\n```hemlock\nfn process_input(text: string): string {\n    return text\n        .trim()\n        .to_lower()\n        .replace_all(\"  \", \" \");  // Normalize whitespace\n}\n\nlet input = \"  HELLO   WORLD  \";\nlet clean = process_input(input);  // \"hello world\"\n```\n\n### Example: CSV Parser\n\n```hemlock\nfn parse_csv_line(line: string): array {\n    let trimmed = line.trim();\n    let fields = trimmed.split(\",\");\n\n    let result = [];\n    let i = 0;\n    while (i < fields.length) {\n        result.push(fields[i].trim());\n        i = i + 1;\n    }\n\n    return result;\n}\n\nlet csv = \"apple, banana , cherry\";\nlet fields = parse_csv_line(csv);  // [\"apple\", \"banana\", \"cherry\"]\n```\n\n### Example: Word Counter\n\n```hemlock\nfn count_words(text: string): i32 {\n    let words = text.trim().split(\" \");\n    return words.length;\n}\n\nlet sentence = \"The quick brown fox\";\nlet count = count_words(sentence);  // 4\n```\n\n### Example: String Validation\n\n```hemlock\nfn is_valid_email(email: string): bool {\n    if (!email.contains(\"@\")) {\n        return false;\n    }\n\n    if (!email.contains(\".\")) {\n        return false;\n    }\n\n    if (email.starts_with(\"@\") || email.ends_with(\"@\")) {\n        return false;\n    }\n\n    return true;\n}\n\nprint(is_valid_email(\"user@example.com\"));  // true\nprint(is_valid_email(\"invalid\"));            // false\n```\n\n## Memory Management\n\nStrings are heap-allocated and follow these rules:\n\n- **Creation**: Allocated on heap with capacity tracking\n- **Concatenation**: Creates new string (old strings unchanged)\n- **Methods**: Most methods return new strings\n- **Lifetime**: Never automatically freed (v0.1 limitation)\n\n**Memory leak example:**\n```hemlock\nfn create_strings() {\n    let s = \"hello\";\n    let s2 = s + \" world\";  // New allocation\n    // s2 never freed - memory leak\n}\n```\n\n**Current limitation:** Strings are not automatically freed in v0.1. Manual memory management for strings will be addressed in future versions.\n\n## Best Practices\n\n1. **Use codepoint indexing** - Strings use codepoint positions, not byte offsets\n2. **Test with Unicode** - Always test string operations with multi-byte characters\n3. **Prefer immutable operations** - Use methods that return new strings rather than mutation\n4. **Check bounds** - String indexing does not bounds-check (returns null/error on invalid)\n5. **Normalize input** - Use `trim()` and `to_lower()` for user input\n\n## Common Pitfalls\n\n### Pitfall: Byte vs. Codepoint Confusion\n\n```hemlock\nlet emoji = \"\";\nprint(emoji.length);        // 1 (codepoint)\nprint(emoji.byte_length);   // 4 (bytes)\n\n// Don't mix byte and codepoint operations\nlet byte = emoji.byte_at(0);  // 240 (first byte)\nlet char = emoji.char_at(0);  // '' (full codepoint)\n```\n\n### Pitfall: Mutation Surprises\n\n```hemlock\nlet s1 = \"hello\";\nlet s2 = s1;       // Shallow copy\ns1[0] = 'H';       // Mutates s1\nprint(s2);         // Still \"hello\" (strings are value types)\n```\n\n## Related Topics\n\n- [Runes](runes.md) - Unicode codepoint type used in string indexing\n- [Arrays](arrays.md) - String methods often return or work with arrays\n- [Types](types.md) - String type details and conversions\n\n## See Also\n\n- **UTF-8 Encoding**: See CLAUDE.md section \"Strings\"\n- **Type Conversions**: See [Types](types.md) for string conversions\n- **Memory**: See [Memory](memory.md) for string allocation details\n"}, "Language Guide  Syntax": {"id": "language-guide-syntax", "content": "# Syntax Overview\n\nThis document covers the fundamental syntax rules and structure of Hemlock programs.\n\n## Core Syntax Rules\n\n### Semicolons Are Mandatory\n\nUnlike JavaScript or Python, semicolons are **always required** at the end of statements:\n\n```hemlock\nlet x = 42;\nlet y = 10;\nprint(x + y);\n```\n\n**This will cause an error:**\n```hemlock\nlet x = 42  // ERROR: Missing semicolon\nlet y = 10  // ERROR: Missing semicolon\n```\n\n### Braces Are Always Required\n\nAll control flow blocks must use braces, even for single statements:\n\n```hemlock\n//  CORRECT\nif (x > 0) {\n    print(\"positive\");\n}\n\n//  ERROR: Missing braces\nif (x > 0)\n    print(\"positive\");\n```\n\n### Comments\n\n```hemlock\n// This is a single-line comment\n\n/*\n   This is a\n   multi-line comment\n*/\n\nlet x = 42;  // Inline comment\n```\n\n## Variables\n\n### Declaration\n\nVariables are declared with `let`:\n\n```hemlock\nlet count = 0;\nlet name = \"Alice\";\nlet pi = 3.14159;\n```\n\n### Type Annotations (Optional)\n\n```hemlock\nlet age: i32 = 30;\nlet ratio: f64 = 1.618;\nlet flag: bool = true;\nlet text: string = \"hello\";\n```\n\n### Constants\n\nUse `const` for immutable values (experimental):\n\n```hemlock\nconst MAX_SIZE: i32 = 1000;\nconst PI: f64 = 3.14159;\n```\n\n**Note**: `const` is parsed but not yet fully enforced in v0.1.\n\n## Expressions\n\n### Arithmetic Operators\n\n```hemlock\nlet a = 10;\nlet b = 3;\n\nprint(a + b);   // 13 - Addition\nprint(a - b);   // 7  - Subtraction\nprint(a * b);   // 30 - Multiplication\nprint(a / b);   // 3  - Division (integer)\n```\n\n### Comparison Operators\n\n```hemlock\nprint(a == b);  // false - Equal\nprint(a != b);  // true  - Not equal\nprint(a > b);   // true  - Greater than\nprint(a < b);   // false - Less than\nprint(a >= b);  // true  - Greater or equal\nprint(a <= b);  // false - Less or equal\n```\n\n### Logical Operators\n\n```hemlock\nlet x = true;\nlet y = false;\n\nprint(x && y);  // false - AND\nprint(x || y);  // true  - OR\nprint(!x);      // false - NOT\n```\n\n### Bitwise Operators\n\n```hemlock\nlet a = 12;  // 1100\nlet b = 10;  // 1010\n\nprint(a & b);   // 8  - Bitwise AND\nprint(a | b);   // 14 - Bitwise OR\nprint(a ^ b);   // 6  - Bitwise XOR\nprint(a << 2);  // 48 - Left shift\nprint(a >> 1);  // 6  - Right shift\nprint(~a);      // -13 - Bitwise NOT\n```\n\n### Operator Precedence\n\nFrom highest to lowest:\n\n1. `()` - Grouping\n2. `!`, `~`, `-` (unary) - Unary operators\n3. `*`, `/` - Multiplication, Division\n4. `+`, `-` - Addition, Subtraction\n5. `<<`, `>>` - Bit shifts\n6. `<`, `<=`, `>`, `>=` - Comparisons\n7. `==`, `!=` - Equality\n8. `&` - Bitwise AND\n9. `^` - Bitwise XOR\n10. `|` - Bitwise OR\n11. `&&` - Logical AND\n12. `||` - Logical OR\n\n**Examples:**\n```hemlock\nlet x = 2 + 3 * 4;      // 14 (not 20)\nlet y = (2 + 3) * 4;    // 20\nlet z = 5 << 2 + 1;     // 40 (5 << 3)\n```\n\n## Control Flow\n\n### If Statements\n\n```hemlock\nif (condition) {\n    // body\n}\n\nif (condition) {\n    // then branch\n} else {\n    // else branch\n}\n\nif (condition1) {\n    // branch 1\n} else if (condition2) {\n    // branch 2\n} else {\n    // default branch\n}\n```\n\n### While Loops\n\n```hemlock\nwhile (condition) {\n    // body\n}\n```\n\n**Example:**\n```hemlock\nlet i = 0;\nwhile (i < 10) {\n    print(i);\n    i = i + 1;\n}\n```\n\n### For Loops\n\n**C-style for:**\n```hemlock\nfor (initializer; condition; increment) {\n    // body\n}\n```\n\n**Example:**\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n```\n\n**For-in (arrays):**\n```hemlock\nfor (let item in array) {\n    // body\n}\n```\n\n**Example:**\n```hemlock\nlet items = [10, 20, 30];\nfor (let x in items) {\n    print(x);\n}\n```\n\n### Switch Statements\n\n```hemlock\nswitch (expression) {\n    case value1:\n        // body\n        break;\n    case value2:\n        // body\n        break;\n    default:\n        // default body\n        break;\n}\n```\n\n**Example:**\n```hemlock\nlet day = 3;\nswitch (day) {\n    case 1:\n        print(\"Monday\");\n        break;\n    case 2:\n        print(\"Tuesday\");\n        break;\n    case 3:\n        print(\"Wednesday\");\n        break;\n    default:\n        print(\"Other\");\n        break;\n}\n```\n\n### Break and Continue\n\n```hemlock\n// Break: exit loop\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        break;\n    }\n    print(i);\n}\n\n// Continue: skip to next iteration\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        continue;\n    }\n    print(i);\n}\n```\n\n## Functions\n\n### Named Functions\n\n```hemlock\nfn function_name(param1: type1, param2: type2): return_type {\n    // body\n    return value;\n}\n```\n\n**Example:**\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n```\n\n### Anonymous Functions\n\n```hemlock\nlet func = fn(params) {\n    // body\n};\n```\n\n**Example:**\n```hemlock\nlet multiply = fn(x, y) {\n    return x * y;\n};\n```\n\n### Type Annotations (Optional)\n\n```hemlock\n// No annotations (types inferred)\nfn greet(name) {\n    return \"Hello, \" + name;\n}\n\n// With annotations (checked at runtime)\nfn divide(a: i32, b: i32): f64 {\n    return a / b;\n}\n```\n\n## Objects\n\n### Object Literals\n\n```hemlock\nlet obj = {\n    field1: value1,\n    field2: value2,\n};\n```\n\n**Example:**\n```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    active: true,\n};\n```\n\n### Methods\n\n```hemlock\nlet obj = {\n    method: fn() {\n        self.field = value;\n    },\n};\n```\n\n**Example:**\n```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    },\n};\n```\n\n### Type Definitions\n\n```hemlock\ndefine TypeName {\n    field1: type1,\n    field2: type2,\n    optional_field?: default_value,\n}\n```\n\n**Example:**\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,\n}\n```\n\n## Arrays\n\n### Array Literals\n\n```hemlock\nlet arr = [element1, element2, element3];\n```\n\n**Example:**\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nlet mixed = [1, \"two\", true, null];\nlet empty = [];\n```\n\n### Array Indexing\n\n```hemlock\nlet arr = [10, 20, 30];\nprint(arr[0]);   // 10\narr[1] = 99;     // Modify element\n```\n\n## Error Handling\n\n### Try/Catch\n\n```hemlock\ntry {\n    // risky code\n} catch (e) {\n    // handle error\n}\n```\n\n### Try/Finally\n\n```hemlock\ntry {\n    // risky code\n} finally {\n    // always runs\n}\n```\n\n### Try/Catch/Finally\n\n```hemlock\ntry {\n    // risky code\n} catch (e) {\n    // handle error\n} finally {\n    // cleanup\n}\n```\n\n### Throw\n\n```hemlock\nthrow expression;\n```\n\n**Example:**\n```hemlock\nif (x < 0) {\n    throw \"x must be positive\";\n}\n```\n\n### Panic\n\n```hemlock\npanic(message);\n```\n\n**Example:**\n```hemlock\npanic(\"unrecoverable error\");\n```\n\n## Modules (Experimental)\n\n### Export Statements\n\n```hemlock\nexport fn function_name() { }\nexport const CONSTANT = value;\nexport let variable = value;\nexport { name1, name2 };\n```\n\n### Import Statements\n\n```hemlock\nimport { name1, name2 } from \"./module.hml\";\nimport * as namespace from \"./module.hml\";\nimport { name as alias } from \"./module.hml\";\n```\n\n## Async (Experimental)\n\n### Async Functions\n\n```hemlock\nasync fn function_name(params): return_type {\n    // body\n}\n```\n\n### Spawn/Join\n\n```hemlock\nlet task = spawn(async_function, arg1, arg2);\nlet result = join(task);\n```\n\n### Channels\n\n```hemlock\nlet ch = channel(capacity);\nch.send(value);\nlet value = ch.recv();\nch.close();\n```\n\n## FFI (Foreign Function Interface)\n\n### Import Shared Library\n\n```hemlock\nimport \"library_name.so\";\n```\n\n### Declare External Function\n\n```hemlock\nextern fn function_name(param: type): return_type;\n```\n\n**Example:**\n```hemlock\nimport \"libc.so.6\";\nextern fn strlen(s: string): i32;\n```\n\n## Literals\n\n### Integer Literals\n\n```hemlock\nlet decimal = 42;\nlet negative = -100;\nlet large = 5000000000;  // Auto i64\n```\n\n### Float Literals\n\n```hemlock\nlet f = 3.14;\nlet e = 2.71828;\nlet sci = 1.5e-10;  // Not yet supported\n```\n\n### String Literals\n\n```hemlock\nlet s = \"hello\";\nlet escaped = \"line1\\nline2\\ttabbed\";\nlet quote = \"She said \\\"hello\\\"\";\n```\n\n### Rune Literals\n\n```hemlock\nlet ch = 'A';\nlet emoji = '';\nlet escaped = '\\n';\nlet unicode = '\\u{1F680}';\n```\n\n### Boolean Literals\n\n```hemlock\nlet t = true;\nlet f = false;\n```\n\n### Null Literal\n\n```hemlock\nlet nothing = null;\n```\n\n## Scoping Rules\n\n### Block Scope\n\nVariables are scoped to the nearest enclosing block:\n\n```hemlock\nlet x = 1;  // Outer scope\n\nif (true) {\n    let x = 2;  // Inner scope (shadows outer)\n    print(x);   // 2\n}\n\nprint(x);  // 1\n```\n\n### Function Scope\n\nFunctions create their own scope:\n\n```hemlock\nlet global = \"global\";\n\nfn foo() {\n    let local = \"local\";\n    print(global);  // Can read outer scope\n}\n\nfoo();\n// print(local);  // ERROR: 'local' not defined here\n```\n\n### Closure Scope\n\nClosures capture variables from enclosing scope:\n\n```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;  // Captures 'count'\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\n```\n\n## Whitespace and Formatting\n\n### Indentation\n\nHemlock doesn't enforce specific indentation, but 4 spaces is recommended:\n\n```hemlock\nfn example() {\n    if (true) {\n        print(\"indented\");\n    }\n}\n```\n\n### Line Breaks\n\nStatements can span multiple lines:\n\n```hemlock\nlet result =\n    very_long_function_name(\n        arg1,\n        arg2,\n        arg3\n    );\n```\n\n## Reserved Keywords\n\nThe following keywords are reserved in Hemlock:\n\n```\nlet, const, fn, if, else, while, for, in, break, continue,\nreturn, true, false, null, typeof, import, export, from,\ntry, catch, finally, throw, panic, async, await, spawn, join,\ndetach, channel, define, switch, case, default, extern, self\n```\n\n## Next Steps\n\n- [Type System](types.md) - Learn about Hemlock's type system\n- [Control Flow](control-flow.md) - Deep dive into control structures\n- [Functions](functions.md) - Master functions and closures\n- [Memory Management](memory.md) - Understand pointers and buffers\n"}, "Language Guide  Types": {"id": "language-guide-types", "content": "# Type System\n\nHemlock features a **dynamic type system** with optional type annotations and runtime type checking.\n\n## Philosophy\n\n- **Dynamic by default** - Every value has a runtime type tag\n- **Typed by choice** - Optional type annotations enforce runtime checks\n- **Explicit conversions** - Implicit conversions follow clear promotion rules\n- **Honest about types** - `typeof()` always tells the truth\n\n## Primitive Types\n\n### Integer Types\n\n**Signed integers:**\n```hemlock\nlet tiny: i8 = 127;              // 8-bit  (-128 to 127)\nlet small: i16 = 32767;          // 16-bit (-32768 to 32767)\nlet normal: i32 = 2147483647;    // 32-bit (default)\nlet large: i64 = 9223372036854775807;  // 64-bit\n```\n\n**Unsigned integers:**\n```hemlock\nlet byte: u8 = 255;              // 8-bit  (0 to 255)\nlet word: u16 = 65535;           // 16-bit (0 to 65535)\nlet dword: u32 = 4294967295;     // 32-bit (0 to 4294967295)\nlet qword: u64 = 18446744073709551615;  // 64-bit\n```\n\n**Type aliases:**\n```hemlock\nlet i: integer = 42;   // Alias for i32\nlet b: byte = 255;     // Alias for u8\n```\n\n### Floating-Point Types\n\n```hemlock\nlet f: f32 = 3.14159;        // 32-bit float\nlet d: f64 = 2.718281828;    // 64-bit float (default)\nlet n: number = 1.618;       // Alias for f64\n```\n\n### Boolean Type\n\n```hemlock\nlet flag: bool = true;\nlet active: bool = false;\n```\n\n### String Type\n\n```hemlock\nlet text: string = \"Hello, World!\";\nlet empty: string = \"\";\n```\n\nStrings are **mutable**, **UTF-8 encoded**, and **heap-allocated**.\n\nSee [Strings](strings.md) for full details.\n\n### Rune Type\n\n```hemlock\nlet ch: rune = 'A';\nlet emoji: rune = '';\nlet newline: rune = '\\n';\nlet unicode: rune = '\\u{1F680}';\n```\n\nRunes represent **Unicode codepoints** (U+0000 to U+10FFFF).\n\nSee [Runes](runes.md) for full details.\n\n### Null Type\n\n```hemlock\nlet nothing = null;\nlet uninitialized: string = null;\n```\n\n`null` is its own type with a single value.\n\n## Composite Types\n\n### Array Type\n\n```hemlock\nlet numbers: array = [1, 2, 3, 4, 5];\nlet mixed = [1, \"two\", true, null];  // Mixed types allowed\nlet empty: array = [];\n```\n\nSee [Arrays](arrays.md) for full details.\n\n### Object Type\n\n```hemlock\nlet obj: object = { x: 10, y: 20 };\nlet person = { name: \"Alice\", age: 30 };\n```\n\nSee [Objects](objects.md) for full details.\n\n### Pointer Types\n\n**Raw pointer:**\n```hemlock\nlet p: ptr = alloc(64);\n// No bounds checking, manual lifetime management\nfree(p);\n```\n\n**Safe buffer:**\n```hemlock\nlet buf: buffer = buffer(64);\n// Bounds-checked, tracks length and capacity\nfree(buf);\n```\n\nSee [Memory Management](memory.md) for full details.\n\n## Special Types\n\n### File Type\n\n```hemlock\nlet f: file = open(\"data.txt\", \"r\");\nf.close();\n```\n\nRepresents an open file handle.\n\n### Task Type\n\n```hemlock\nasync fn compute(): i32 { return 42; }\nlet task = spawn(compute);\nlet result: i32 = join(task);\n```\n\nRepresents an async task handle.\n\n### Channel Type\n\n```hemlock\nlet ch: channel = channel(10);\nch.send(42);\nlet value = ch.recv();\n```\n\nRepresents a communication channel between tasks.\n\n### Void Type\n\n```hemlock\nextern fn exit(code: i32): void;\n```\n\nUsed for functions that don't return a value (FFI only).\n\n## Type Inference\n\n### Integer Literal Inference\n\nHemlock infers integer types based on value range:\n\n```hemlock\nlet a = 42;              // i32 (fits in 32-bit)\nlet b = 5000000000;      // i64 (> i32 max)\nlet c = 128;             // i32\nlet d: u8 = 128;         // u8 (explicit annotation)\n```\n\n**Rules:**\n- Values in i32 range (-2147483648 to 2147483647): infer as `i32`\n- Values outside i32 range but within i64: infer as `i64`\n- Use explicit annotations for other types (i8, i16, u8, u16, u32, u64)\n\n### Float Literal Inference\n\n```hemlock\nlet x = 3.14;        // f64 (default)\nlet y: f32 = 3.14;   // f32 (explicit)\n```\n\n### Other Type Inference\n\n```hemlock\nlet s = \"hello\";     // string\nlet ch = 'A';        // rune\nlet flag = true;     // bool\nlet arr = [1, 2, 3]; // array\nlet obj = { x: 10 }; // object\nlet nothing = null;  // null\n```\n\n## Type Annotations\n\n### Variable Annotations\n\n```hemlock\nlet age: i32 = 30;\nlet ratio: f64 = 1.618;\nlet name: string = \"Alice\";\n```\n\n### Function Parameter Annotations\n\n```hemlock\nfn greet(name: string, age: i32) {\n    print(\"Hello, \" + name + \"!\");\n}\n```\n\n### Function Return Type Annotations\n\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n```\n\n### Object Type Annotations (Duck Typing)\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\nlet p: Person = { name: \"Bob\", age: 25 };\n```\n\n## Type Checking\n\n### Runtime Type Checking\n\nType annotations are checked at **runtime**, not compile-time:\n\n```hemlock\nlet x: i32 = 42;     // OK\nlet y: i32 = 3.14;   // Runtime error: type mismatch\n\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 3);           // OK\nadd(5, \"hello\");     // Runtime error: type mismatch\n```\n\n### Type Queries\n\nUse `typeof()` to check value types:\n\n```hemlock\nprint(typeof(42));         // \"i32\"\nprint(typeof(3.14));       // \"f64\"\nprint(typeof(\"hello\"));    // \"string\"\nprint(typeof(true));       // \"bool\"\nprint(typeof(null));       // \"null\"\nprint(typeof([1, 2, 3]));  // \"array\"\nprint(typeof({ x: 10 }));  // \"object\"\n```\n\n## Type Conversions\n\n### Implicit Type Promotion\n\nWhen mixing types in operations, Hemlock promotes to the \"higher\" type:\n\n**Promotion Hierarchy (lowest to highest):**\n```\ni8  i16  i32  u32  i64  u64  f32  f64\n                \n     u8    u16\n```\n\n**Float always wins:**\n```hemlock\nlet x: i32 = 10;\nlet y: f64 = 3.5;\nlet result = x + y;  // result is f64 (13.5)\n```\n\n**Larger size wins:**\n```hemlock\nlet a: i32 = 100;\nlet b: i64 = 200;\nlet sum = a + b;     // sum is i64 (300)\n```\n\n**Examples:**\n```hemlock\nu8 + i32   i32\ni32 + i64  i64\nu32 + u64  u64\ni32 + f32  f32\ni64 + f64  f64\ni8 + f64   f64\n```\n\n### Explicit Type Conversion\n\n**Integer  Float:**\n```hemlock\nlet i: i32 = 42;\nlet f: f64 = i;      // i32  f64 (42.0)\n\nlet x: f64 = 3.14;\nlet n: i32 = x;      // f64  i32 (3, truncated)\n```\n\n**Integer  Rune:**\n```hemlock\nlet code: i32 = 65;\nlet ch: rune = code;  // i32  rune ('A')\n\nlet r: rune = 'Z';\nlet value: i32 = r;   // rune  i32 (90)\n```\n\n**Rune  String:**\n```hemlock\nlet ch: rune = '';\nlet s: string = ch;   // rune  string (\"\")\n```\n\n**u8  Rune:**\n```hemlock\nlet b: u8 = 65;\nlet r: rune = b;      // u8  rune ('A')\n```\n\n## Range Checking\n\nType annotations enforce range checks at assignment:\n\n```hemlock\nlet x: u8 = 255;    // OK\nlet y: u8 = 256;    // ERROR: out of range for u8\n\nlet a: i8 = 127;    // OK\nlet b: i8 = 128;    // ERROR: out of range for i8\n\nlet c: i64 = 2147483647;   // OK\nlet d: u64 = 4294967295;   // OK\nlet e: u64 = -1;           // ERROR: u64 cannot be negative\n```\n\n## Type Promotion Examples\n\n### Mixed Integer Types\n\n```hemlock\nlet a: i8 = 10;\nlet b: i32 = 20;\nlet sum = a + b;     // i32 (30)\n\nlet c: u8 = 100;\nlet d: u32 = 200;\nlet total = c + d;   // u32 (300)\n```\n\n### Integer + Float\n\n```hemlock\nlet i: i32 = 5;\nlet f: f32 = 2.5;\nlet result = i * f;  // f32 (12.5)\n```\n\n### Complex Expressions\n\n```hemlock\nlet a: i8 = 10;\nlet b: i32 = 20;\nlet c: f64 = 3.0;\n\nlet result = a + b * c;  // f64 (70.0)\n// Evaluation: b * c  f64(60.0)\n//             a + f64(60.0)  f64(70.0)\n```\n\n## Duck Typing (Objects)\n\nObjects use **structural typing** (duck typing):\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\n// OK: Has all required fields\nlet p1: Person = { name: \"Alice\", age: 30 };\n\n// OK: Extra fields allowed\nlet p2: Person = { name: \"Bob\", age: 25, city: \"NYC\" };\n\n// ERROR: Missing 'age' field\nlet p3: Person = { name: \"Carol\" };\n\n// ERROR: Wrong type for 'age'\nlet p4: Person = { name: \"Dave\", age: \"thirty\" };\n```\n\n**Type checking happens at assignment:**\n- Validates all required fields present\n- Validates field types match\n- Extra fields are allowed and preserved\n- Sets object's type name for `typeof()`\n\n## Optional Fields\n\n```hemlock\ndefine Config {\n    host: string,\n    port: i32,\n    debug?: false,     // Optional with default\n    timeout?: i32,     // Optional, defaults to null\n}\n\nlet cfg1: Config = { host: \"localhost\", port: 8080 };\nprint(cfg1.debug);    // false (default)\nprint(cfg1.timeout);  // null\n\nlet cfg2: Config = { host: \"0.0.0.0\", port: 80, debug: true };\nprint(cfg2.debug);    // true (overridden)\n```\n\n## Type System Limitations\n\nCurrent limitations (v0.1):\n\n- **No generics** - Cannot parameterize types\n- **No union types** - Cannot express \"A or B\"\n- **No nullable types** - All types can be null\n- **No type aliases** - Cannot `typedef` custom types\n- **Runtime only** - No compile-time type checking\n\n## Best Practices\n\n### When to Use Type Annotations\n\n**DO use annotations when:**\n- Precise type matters (e.g., `u8` for byte values)\n- Documenting function interfaces\n- Enforcing constraints (e.g., range checks)\n\n```hemlock\nfn hash(data: buffer, length: u32): u64 {\n    // Implementation\n}\n```\n\n**DON'T use annotations when:**\n- Type is obvious from literal\n- Internal implementation details\n- Unnecessary ceremony\n\n```hemlock\n// Unnecessary\nlet x: i32 = 42;\n\n// Better\nlet x = 42;\n```\n\n### Type Safety Patterns\n\n**Check before use:**\n```hemlock\nif (typeof(value) == \"i32\") {\n    // Safe to use as i32\n}\n```\n\n**Validate function arguments:**\n```hemlock\nfn divide(a, b) {\n    if (typeof(a) != \"i32\" || typeof(b) != \"i32\") {\n        throw \"arguments must be integers\";\n    }\n    if (b == 0) {\n        throw \"division by zero\";\n    }\n    return a / b;\n}\n```\n\n**Use duck typing for flexibility:**\n```hemlock\ndefine Printable {\n    toString: fn,\n}\n\nfn print_item(item: Printable) {\n    print(item.toString());\n}\n```\n\n## Next Steps\n\n- [Strings](strings.md) - UTF-8 string type and operations\n- [Runes](runes.md) - Unicode codepoint type\n- [Arrays](arrays.md) - Dynamic array type\n- [Objects](objects.md) - Object literals and duck typing\n- [Memory](memory.md) - Pointer and buffer types\n"}, "Advanced Topics  Async Concurrency": {"id": "advanced-async-concurrency", "content": "# Async/Concurrency in Hemlock\n\nHemlock provides **structured concurrency** with async/await syntax, task spawning, and channels for communication. The implementation uses POSIX threads (pthreads) for **TRUE multi-threaded parallelism**.\n\n## Table of Contents\n\n- [Overview](#overview)\n- [Threading Model](#threading-model)\n- [Async Functions](#async-functions)\n- [Task Spawning](#task-spawning)\n- [Channels](#channels)\n- [Exception Propagation](#exception-propagation)\n- [Implementation Details](#implementation-details)\n- [Best Practices](#best-practices)\n- [Performance Characteristics](#performance-characteristics)\n- [Current Limitations](#current-limitations)\n\n## Overview\n\n**What this means:**\n-  **Real OS threads** - Each spawned task runs on a separate pthread (POSIX thread)\n-  **True parallelism** - Tasks execute simultaneously on multiple CPU cores\n-  **Kernel-scheduled** - The OS scheduler distributes tasks across available cores\n-  **Thread-safe channels** - Uses pthread mutexes and condition variables for synchronization\n\n**What this is NOT:**\n-  **NOT green threads** - Not user-space cooperative multitasking\n-  **NOT async/await coroutines** - Not single-threaded event loop like JavaScript/Python asyncio\n-  **NOT emulated concurrency** - Not simulated parallelism\n\nThis is the **same threading model as C, C++, and Rust** when using OS threads. You get actual parallel execution across multiple cores.\n\n## Threading Model\n\n### 1:1 Threading\n\nHemlock uses a **1:1 threading model**, where:\n- Each spawned task creates a dedicated OS thread via `pthread_create()`\n- The OS kernel schedules threads across available CPU cores\n- Pre-emptive multitasking - the OS can interrupt and switch between threads\n- **No GIL** - Unlike Python, there's no Global Interpreter Lock limiting parallelism\n\n### Synchronization Mechanisms\n\n- **Mutexes** - Channels use `pthread_mutex_t` for thread-safe access\n- **Condition variables** - Blocking send/recv use `pthread_cond_t` for efficient waiting\n- **Lock-free operations** - Task state transitions are atomic\n\n## Async Functions\n\nFunctions can be declared as `async` to indicate they're designed for concurrent execution:\n\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n```\n\n### Key Points\n\n- `async fn` declares an asynchronous function\n- Async functions can be spawned as concurrent tasks using `spawn()`\n- Async functions can also be called directly (runs synchronously in current thread)\n- When spawned, each task runs on its **own OS thread** (not a coroutine!)\n- `await` keyword is reserved for future use\n\n### Example: Direct Call vs Spawn\n\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\n// Direct call - runs synchronously\nlet result1 = factorial(5);  // 120\n\n// Spawned task - runs on separate thread\nlet task = spawn(factorial, 5);\nlet result2 = join(task);  // 120\n```\n\n## Task Spawning\n\nUse `spawn()` to run async functions **in parallel on separate OS threads**:\n\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\n// Spawn multiple tasks - these run in PARALLEL on different CPU cores!\nlet t1 = spawn(factorial, 5);  // Thread 1\nlet t2 = spawn(factorial, 6);  // Thread 2\nlet t3 = spawn(factorial, 7);  // Thread 3\n\n// All three are computing simultaneously right now!\n\n// Wait for results\nlet f5 = join(t1);  // 120\nlet f6 = join(t2);  // 720\nlet f7 = join(t3);  // 5040\n```\n\n### Built-in Functions\n\n#### spawn(async_fn, arg1, arg2, ...)\n\nCreates a new task on a new pthread, returns task handle.\n\n**Parameters:**\n- `async_fn` - The async function to execute\n- `arg1, arg2, ...` - Arguments to pass to the function\n\n**Returns:** Task handle (opaque value used with `join()` or `detach()`)\n\n**Example:**\n```hemlock\nasync fn process(data: string, count: i32): i32 {\n    // ... processing logic\n    return count * 2;\n}\n\nlet task = spawn(process, \"test\", 42);\n```\n\n#### join(task)\n\nWait for task completion (blocks until thread finishes), returns result.\n\n**Parameters:**\n- `task` - Task handle returned from `spawn()`\n\n**Returns:** The value returned by the async function\n\n**Example:**\n```hemlock\nlet task = spawn(compute, 1000);\nlet result = join(task);  // Blocks until compute() finishes\nprint(result);\n```\n\n**Important:** Each task can only be joined once. Subsequent joins will error.\n\n#### detach(task)\n\nFire-and-forget execution (thread runs independently, no join allowed).\n\n**Parameters:**\n- `task` - Task handle returned from `spawn()`\n\n**Returns:** `null`\n\n**Example:**\n```hemlock\nasync fn background_work() {\n    // Long-running background task\n    // ...\n}\n\nlet task = spawn(background_work);\ndetach(task);  // Task runs independently, cannot join\n```\n\n**Important:** Detached tasks cannot be joined. The pthread is cleaned up by OS, but Task struct (~64-96 bytes) currently leaks.\n\n## Channels\n\nChannels provide thread-safe communication between tasks using a bounded buffer with blocking semantics.\n\n### Creating Channels\n\n```hemlock\nlet ch = channel(10);  // Create channel with buffer size of 10\n```\n\n**Parameters:**\n- `capacity` (i32) - Maximum number of values the channel can hold\n\n**Returns:** Channel object\n\n### Channel Methods\n\n#### send(value)\n\nSend value to channel (blocks if full).\n\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nlet ch = channel(10);\nlet task = spawn(producer, ch, 5);\n```\n\n**Behavior:**\n- If channel has space, value is added immediately\n- If channel is full, sender blocks until space becomes available\n- If channel is closed, throws exception\n\n#### recv()\n\nReceive value from channel (blocks if empty).\n\n```hemlock\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\nlet ch = channel(10);\nlet task = spawn(consumer, ch, 5);\n```\n\n**Behavior:**\n- If channel has values, returns next value immediately\n- If channel is empty, receiver blocks until value available\n- If channel is closed and empty, returns `null`\n\n#### close()\n\nClose channel (recv on closed channel returns null).\n\n```hemlock\nch.close();\n```\n\n**Behavior:**\n- Prevents further `send()` operations (will throw exception)\n- Allows pending `recv()` operations to complete\n- Once empty, `recv()` returns `null`\n\n### Complete Producer-Consumer Example\n\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Create channel with buffer size\nlet ch = channel(10);\n\n// Spawn producer and consumer\nlet p = spawn(producer, ch, 5);\nlet c = spawn(consumer, ch, 5);\n\n// Wait for completion\njoin(p);\nlet total = join(c);  // 100 (0+10+20+30+40)\nprint(total);\n```\n\n### Multi-Producer, Multi-Consumer\n\nChannels can be safely shared between multiple producers and consumers:\n\n```hemlock\nasync fn producer(id: i32, ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(id * 100 + i);\n        i = i + 1;\n    }\n}\n\nasync fn consumer(id: i32, ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\nlet ch = channel(20);\n\n// Multiple producers\nlet p1 = spawn(producer, 1, ch, 5);\nlet p2 = spawn(producer, 2, ch, 5);\n\n// Multiple consumers\nlet c1 = spawn(consumer, 1, ch, 5);\nlet c2 = spawn(consumer, 2, ch, 5);\n\n// Wait for all\njoin(p1);\njoin(p2);\nlet sum1 = join(c1);\nlet sum2 = join(c2);\nprint(sum1 + sum2);\n```\n\n## Exception Propagation\n\nExceptions thrown in spawned tasks are propagated when joined:\n\n```hemlock\nasync fn risky_operation(should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Task failed!\";\n    }\n    return 42;\n}\n\nlet t = spawn(risky_operation, 1);\ntry {\n    let result = join(t);\n} catch (e) {\n    print(\"Caught: \" + e);  // \"Caught: Task failed!\"\n}\n```\n\n### Exception Handling Patterns\n\n**Pattern 1: Handle in task**\n```hemlock\nasync fn safe_task() {\n    try {\n        // risky operation\n    } catch (e) {\n        print(\"Error in task: \" + e);\n        return null;\n    }\n}\n\nlet task = spawn(safe_task);\njoin(task);  // No exception propagated\n```\n\n**Pattern 2: Propagate to caller**\n```hemlock\nasync fn task_that_throws() {\n    throw \"error\";\n}\n\nlet task = spawn(task_that_throws);\ntry {\n    join(task);\n} catch (e) {\n    print(\"Caught from task: \" + e);\n}\n```\n\n**Pattern 3: Detached tasks with exceptions**\n```hemlock\nasync fn detached_task() {\n    try {\n        // work\n    } catch (e) {\n        // Must handle internally - cannot propagate\n        print(\"Error: \" + e);\n    }\n}\n\nlet task = spawn(detached_task);\ndetach(task);  // Cannot catch exceptions from detached tasks\n```\n\n## Implementation Details\n\n### Threading Architecture\n\n- **1:1 threading** - Each spawned task creates a dedicated OS thread via `pthread_create()`\n- **Kernel-scheduled** - The OS kernel schedules threads across available CPU cores\n- **Pre-emptive multitasking** - The OS can interrupt and switch between threads\n- **No GIL** - Unlike Python, there's no Global Interpreter Lock limiting parallelism\n\n### Channel Implementation\n\nChannels use a circular buffer with pthread synchronization:\n\n```\nChannel Structure:\n- buffer[] - Fixed-size array of Values\n- capacity - Maximum number of elements\n- size - Current number of elements\n- head - Read position\n- tail - Write position\n- mutex - pthread_mutex_t for thread-safe access\n- not_empty - pthread_cond_t for blocking recv\n- not_full - pthread_cond_t for blocking send\n- closed - Boolean flag\n- refcount - Reference count for cleanup\n```\n\n**Blocking behavior:**\n- `send()` on full channel: waits on `not_full` condition variable\n- `recv()` on empty channel: waits on `not_empty` condition variable\n- Both are signaled when appropriate by the opposite operation\n\n### Memory & Cleanup\n\n- **Joined tasks:** Automatically cleaned up after `join()` returns\n- **Detached tasks:** pthread is cleaned up by OS, but Task struct (~64-96 bytes) currently leaks\n- **Channels:** Reference-counted and freed when no longer used\n\n## Best Practices\n\n### 1. Always Close Channels\n\n```hemlock\nasync fn producer(ch) {\n    // ... send values\n    ch.close();  // Important: signal no more values\n}\n```\n\n### 2. Use Structured Concurrency\n\nSpawn tasks and join them in the same scope:\n\n```hemlock\nfn process_data(data) {\n    // Spawn tasks\n    let t1 = spawn(worker, data);\n    let t2 = spawn(worker, data);\n\n    // Always join before returning\n    let r1 = join(t1);\n    let r2 = join(t2);\n\n    return r1 + r2;\n}\n```\n\n### 3. Handle Exceptions Appropriately\n\n```hemlock\nasync fn task() {\n    try {\n        // risky operation\n    } catch (e) {\n        // Log error\n        throw e;  // Re-throw if caller should know\n    }\n}\n```\n\n### 4. Use Appropriate Channel Capacity\n\n- **Small capacity (1-10):** For coordination/signaling\n- **Medium capacity (10-100):** For general producer-consumer\n- **Large capacity (100+):** For high-throughput scenarios\n\n```hemlock\nlet signal_ch = channel(1);      // Coordination\nlet work_ch = channel(50);       // Work queue\nlet buffer_ch = channel(1000);   // High throughput\n```\n\n### 5. Detach Only When Necessary\n\nPrefer `join()` over `detach()` for better resource management:\n\n```hemlock\n// Good: Join and get result\nlet task = spawn(work);\nlet result = join(task);\n\n// Use detach only for true fire-and-forget\nlet bg_task = spawn(background_logging);\ndetach(bg_task);  // Will run independently\n```\n\n## Performance Characteristics\n\n### True Parallelism\n\n- **N spawned tasks can utilize N CPU cores simultaneously**\n- Proven speedup - stress tests show 8-9x CPU time vs wall time (multiple cores working)\n- Linear scaling with number of cores (up to thread count)\n\n### Thread Overhead\n\n- Each task has ~8KB stack + pthread overhead\n- Thread creation cost: ~10-20s\n- Context switch cost: ~1-5s\n\n### When to Use Async\n\n**Good use cases:**\n- CPU-intensive computations that can be parallelized\n- I/O-bound operations (though I/O is still blocking)\n- Concurrent processing of independent data\n- Pipeline architectures with channels\n\n**Not ideal for:**\n- Very short tasks (thread overhead dominates)\n- Tasks with heavy synchronization (contention overhead)\n- Single-core systems (no parallelism benefit)\n\n### Blocking I/O Safe\n\nBlocking operations in one task don't block others:\n\n```hemlock\nasync fn reader(filename: string) {\n    let f = open(filename, \"r\");  // Blocks this thread only\n    let content = f.read();       // Blocks this thread only\n    f.close();\n    return content;\n}\n\n// Both read concurrently (on different threads)\nlet t1 = spawn(reader, \"file1.txt\");\nlet t2 = spawn(reader, \"file2.txt\");\n\nlet c1 = join(t1);\nlet c2 = join(t2);\n```\n\n## Current Limitations\n\n### 1. No select() for Multiplexing\n\nCannot wait on multiple channels simultaneously (planned):\n\n```hemlock\n// NOT YET SUPPORTED:\n// let (value, ch_id) = select(ch1, ch2, ch3);\n```\n\n**Workaround:** Use separate tasks per channel:\n\n```hemlock\nasync fn monitor_ch1(ch1, result_ch) {\n    let val = ch1.recv();\n    result_ch.send({ channel: 1, value: val });\n}\n\n// Similar for ch2, ch3...\n```\n\n### 2. No Work-Stealing Scheduler\n\nUses 1 thread per task, which can be inefficient for many short tasks.\n\n**Current:** 1000 tasks = 1000 threads (heavy overhead)\n\n**Planned:** Thread pool with work stealing for better efficiency\n\n### 3. No Async I/O Integration\n\nFile/network operations still block the thread:\n\n```hemlock\nasync fn read_file(path: string) {\n    let f = open(path, \"r\");\n    let content = f.read();  // Blocks the thread\n    f.close();\n    return content;\n}\n```\n\n**Workaround:** Use multiple threads for concurrent I/O operations\n\n### 4. Fixed Channel Capacity\n\nChannel capacity is set at creation and cannot be resized:\n\n```hemlock\nlet ch = channel(10);\n// Cannot dynamically resize to 20\n```\n\n### 5. Task Struct Leaks on Detach\n\nDetached tasks leak the Task struct (~64-96 bytes) - to be fixed with reference counting in v0.2.\n\n## Common Patterns\n\n### Parallel Map\n\n```hemlock\nasync fn map_worker(ch_in, ch_out, fn_transform) {\n    while (true) {\n        let val = ch_in.recv();\n        if (val == null) { break; }\n\n        let result = fn_transform(val);\n        ch_out.send(result);\n    }\n    ch_out.close();\n}\n\nfn parallel_map(data, fn_transform, workers: i32) {\n    let ch_in = channel(100);\n    let ch_out = channel(100);\n\n    // Spawn workers\n    let tasks = [];\n    let i = 0;\n    while (i < workers) {\n        tasks.push(spawn(map_worker, ch_in, ch_out, fn_transform));\n        i = i + 1;\n    }\n\n    // Send data\n    let i = 0;\n    while (i < data.length) {\n        ch_in.send(data[i]);\n        i = i + 1;\n    }\n    ch_in.close();\n\n    // Collect results\n    let results = [];\n    let i = 0;\n    while (i < data.length) {\n        results.push(ch_out.recv());\n        i = i + 1;\n    }\n\n    // Wait for workers\n    let i = 0;\n    while (i < tasks.length) {\n        join(tasks[i]);\n        i = i + 1;\n    }\n\n    return results;\n}\n```\n\n### Pipeline Architecture\n\n```hemlock\nasync fn stage1(input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n        output_ch.send(val * 2);\n    }\n    output_ch.close();\n}\n\nasync fn stage2(input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n        output_ch.send(val + 10);\n    }\n    output_ch.close();\n}\n\n// Create pipeline\nlet ch1 = channel(10);\nlet ch2 = channel(10);\nlet ch3 = channel(10);\n\nlet s1 = spawn(stage1, ch1, ch2);\nlet s2 = spawn(stage2, ch2, ch3);\n\n// Feed input\nch1.send(1);\nch1.send(2);\nch1.send(3);\nch1.close();\n\n// Collect output\nprint(ch3.recv());  // 12 (1 * 2 + 10)\nprint(ch3.recv());  // 14 (2 * 2 + 10)\nprint(ch3.recv());  // 16 (3 * 2 + 10)\n\njoin(s1);\njoin(s2);\n```\n\n### Fan-Out, Fan-In\n\n```hemlock\nasync fn worker(id: i32, input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n\n        // Process value\n        let result = val * id;\n        output_ch.send(result);\n    }\n}\n\nlet input = channel(10);\nlet output = channel(10);\n\n// Fan-out: Multiple workers\nlet workers = 4;\nlet tasks = [];\nlet i = 0;\nwhile (i < workers) {\n    tasks.push(spawn(worker, i, input, output));\n    i = i + 1;\n}\n\n// Send work\nlet i = 0;\nwhile (i < 10) {\n    input.send(i);\n    i = i + 1;\n}\ninput.close();\n\n// Fan-in: Collect all results\nlet results = [];\nlet i = 0;\nwhile (i < 10) {\n    results.push(output.recv());\n    i = i + 1;\n}\n\n// Wait for all workers\nlet i = 0;\nwhile (i < tasks.length) {\n    join(tasks[i]);\n    i = i + 1;\n}\n```\n\n## Summary\n\nHemlock's async/concurrency model provides:\n\n-  True multi-threaded parallelism using OS threads\n-  Simple, structured concurrency primitives\n-  Thread-safe channels for communication\n-  Exception propagation across tasks\n-  Proven performance on multi-core systems\n\nThis makes Hemlock suitable for:\n- Parallel computations\n- Concurrent I/O operations\n- Pipeline architectures\n- Producer-consumer patterns\n\nWhile avoiding the complexity of:\n- Manual thread management\n- Low-level synchronization primitives\n- Deadlock-prone lock-based designs\n"}, "Advanced Topics  Command Execution": {"id": "advanced-command-execution", "content": "# Command Execution in Hemlock\n\nHemlock provides the **`exec()` builtin function** to execute shell commands and capture their output.\n\n## Table of Contents\n\n- [Overview](#overview)\n- [The exec() Function](#the-exec-function)\n- [Result Object](#result-object)\n- [Basic Usage](#basic-usage)\n- [Advanced Examples](#advanced-examples)\n- [Error Handling](#error-handling)\n- [Implementation Details](#implementation-details)\n- [Security Considerations](#security-considerations)\n- [Limitations](#limitations)\n- [Use Cases](#use-cases)\n- [Best Practices](#best-practices)\n- [Complete Examples](#complete-examples)\n\n## Overview\n\nThe `exec()` function allows Hemlock programs to:\n- Execute shell commands\n- Capture standard output (stdout)\n- Check exit status codes\n- Use shell features (pipes, redirects, etc.)\n- Integrate with system utilities\n\n**Important:** Commands are executed via `/bin/sh`, giving full shell capabilities but also introducing security considerations.\n\n## The exec() Function\n\n### Signature\n\n```hemlock\nexec(command: string): object\n```\n\n**Parameters:**\n- `command` (string) - Shell command to execute\n\n**Returns:** An object with two fields:\n- `output` (string) - The command's stdout output\n- `exit_code` (i32) - The command's exit status code\n\n### Basic Example\n\n```hemlock\nlet result = exec(\"echo hello\");\nprint(result.output);      // \"hello\\n\"\nprint(result.exit_code);   // 0\n```\n\n## Result Object\n\nThe object returned by `exec()` has the following structure:\n\n```hemlock\n{\n    output: string,      // Command stdout (captured output)\n    exit_code: i32       // Process exit status (0 = success)\n}\n```\n\n### output Field\n\nContains all text written to stdout by the command.\n\n**Properties:**\n- Empty string if command produces no output\n- Includes newlines and whitespace as-is\n- Multi-line output preserved\n- Not limited in size (dynamically allocated)\n\n**Examples:**\n```hemlock\nlet r1 = exec(\"echo test\");\nprint(r1.output);  // \"test\\n\"\n\nlet r2 = exec(\"ls\");\nprint(r2.output);  // Directory listing with newlines\n\nlet r3 = exec(\"true\");\nprint(r3.output);  // \"\" (empty string)\n```\n\n### exit_code Field\n\nThe command's exit status code.\n\n**Values:**\n- `0` typically indicates success\n- `1-255` indicate errors (convention varies by command)\n- `-1` if command could not be executed or terminated abnormally\n\n**Examples:**\n```hemlock\nlet r1 = exec(\"true\");\nprint(r1.exit_code);  // 0 (success)\n\nlet r2 = exec(\"false\");\nprint(r2.exit_code);  // 1 (failure)\n\nlet r3 = exec(\"ls /nonexistent\");\nprint(r3.exit_code);  // 2 (file not found, varies by command)\n```\n\n## Basic Usage\n\n### Simple Command\n\n```hemlock\nlet r = exec(\"ls -la\");\nprint(r.output);\nprint(\"Exit code: \" + typeof(r.exit_code));\n```\n\n### Checking Exit Status\n\n```hemlock\nlet r = exec(\"grep pattern file.txt\");\nif (r.exit_code == 0) {\n    print(\"Found: \" + r.output);\n} else {\n    print(\"Pattern not found\");\n}\n```\n\n### Commands with Pipes\n\n```hemlock\nlet r = exec(\"ps aux | grep hemlock\");\nprint(r.output);\n```\n\n### Multiple Commands\n\n```hemlock\nlet r = exec(\"cd /tmp && ls -la\");\nprint(r.output);\n```\n\n### Command Substitution\n\n```hemlock\nlet r = exec(\"echo $(date)\");\nprint(r.output);  // Current date\n```\n\n## Advanced Examples\n\n### Handling Failures\n\n```hemlock\nlet r = exec(\"ls /nonexistent\");\nif (r.exit_code != 0) {\n    print(\"Command failed with code: \" + typeof(r.exit_code));\n    print(\"Error output: \" + r.output);  // Note: stderr not captured\n}\n```\n\n### Processing Multi-Line Output\n\n```hemlock\nlet r = exec(\"cat file.txt\");\nlet lines = r.output.split(\"\\n\");\nlet i = 0;\nwhile (i < lines.length) {\n    print(\"Line \" + typeof(i) + \": \" + lines[i]);\n    i = i + 1;\n}\n```\n\n### Command Chaining\n\n**With && (AND):**\n```hemlock\nlet r1 = exec(\"mkdir -p /tmp/test && touch /tmp/test/file.txt\");\nif (r1.exit_code == 0) {\n    print(\"Setup complete\");\n}\n```\n\n**With || (OR):**\n```hemlock\nlet r = exec(\"command1 || command2\");\n// Runs command2 only if command1 fails\n```\n\n**With ; (sequence):**\n```hemlock\nlet r = exec(\"command1; command2\");\n// Runs both regardless of success/failure\n```\n\n### Using Pipes\n\n```hemlock\nlet r = exec(\"echo 'data' | base64\");\nprint(\"Base64: \" + r.output);\n```\n\n**Complex pipelines:**\n```hemlock\nlet r = exec(\"cat /etc/passwd | grep root | cut -d: -f1\");\nprint(r.output);\n```\n\n### Exit Code Patterns\n\nDifferent exit codes indicate different conditions:\n\n```hemlock\nlet r = exec(\"test -f myfile.txt\");\nif (r.exit_code == 0) {\n    print(\"File exists\");\n} else if (r.exit_code == 1) {\n    print(\"File does not exist\");\n} else {\n    print(\"Test command failed: \" + typeof(r.exit_code));\n}\n```\n\n### Output Redirects\n\n```hemlock\n// Redirect stdout to file (within shell)\nlet r1 = exec(\"echo 'test' > /tmp/output.txt\");\n\n// Redirect stderr to stdout (Note: stderr still not captured by Hemlock)\nlet r2 = exec(\"command 2>&1\");\n```\n\n### Environment Variables\n\n```hemlock\nlet r = exec(\"export VAR=value && echo $VAR\");\nprint(r.output);  // \"value\\n\"\n```\n\n### Working Directory Changes\n\n```hemlock\nlet r = exec(\"cd /tmp && pwd\");\nprint(r.output);  // \"/tmp\\n\"\n```\n\n## Error Handling\n\n### When exec() Throws Exceptions\n\nThe `exec()` function throws an exception if the command cannot be executed:\n\n```hemlock\ntry {\n    let r = exec(\"nonexistent_command_xyz\");\n} catch (e) {\n    print(\"Failed to execute: \" + e);\n}\n```\n\n**Exceptions are thrown when:**\n- `popen()` fails (e.g., cannot create pipe)\n- System resource limits exceeded\n- Memory allocation failures\n\n### When exec() Does NOT Throw\n\n```hemlock\n// Command runs but returns non-zero exit code\nlet r1 = exec(\"false\");\nprint(r1.exit_code);  // 1 (not an exception)\n\n// Command produces no output\nlet r2 = exec(\"true\");\nprint(r2.output);  // \"\" (not an exception)\n\n// Command not found by shell\nlet r3 = exec(\"nonexistent_cmd\");\nprint(r3.exit_code);  // 127 (not an exception)\n```\n\n### Safe Execution Pattern\n\n```hemlock\nfn safe_exec(command: string) {\n    try {\n        let r = exec(command);\n        if (r.exit_code != 0) {\n            print(\"Warning: Command failed with code \" + typeof(r.exit_code));\n            return \"\";\n        }\n        return r.output;\n    } catch (e) {\n        print(\"Error executing command: \" + e);\n        return \"\";\n    }\n}\n\nlet output = safe_exec(\"ls -la\");\n```\n\n## Implementation Details\n\n### How It Works\n\n**Under the hood:**\n- Uses `popen()` to execute commands via `/bin/sh`\n- Captures stdout only (stderr is not captured)\n- Output buffered dynamically (starts at 4KB, grows as needed)\n- Exit status extracted using `WIFEXITED()` and `WEXITSTATUS()` macros\n- Output string is properly null-terminated\n\n**Process flow:**\n1. `popen(command, \"r\")` creates pipe and forks process\n2. Child process executes `/bin/sh -c \"command\"`\n3. Parent reads stdout via pipe into growing buffer\n4. `pclose()` waits for child and returns exit status\n5. Exit status is extracted and stored in result object\n\n### Performance Considerations\n\n**Costs:**\n- Creates a new shell process for each call (~1-5ms overhead)\n- Output stored entirely in memory (not streamed)\n- No streaming support (waits for command completion)\n- Suitable for commands with reasonable output sizes\n\n**Optimizations:**\n- Buffer starts at 4KB and doubles when full (efficient memory usage)\n- Single read loop minimizes system calls\n- No additional string copying\n\n**When to use:**\n- Short-running commands (< 1 second)\n- Moderate output size (< 10MB)\n- Batch operations with reasonable intervals\n\n**When NOT to use:**\n- Long-running daemons or services\n- Commands producing gigabytes of output\n- Real-time streaming data processing\n- High-frequency execution (> 100 calls/second)\n\n## Security Considerations\n\n### Shell Injection Risk\n\n **CRITICAL:** Commands are executed by the shell (`/bin/sh`), which means **shell injection is possible**.\n\n**Vulnerable code:**\n```hemlock\n// DANGEROUS - DO NOT DO THIS\nlet filename = args[1];  // User input\nlet r = exec(\"cat \" + filename);  // Shell injection!\n```\n\n**Attack:**\n```bash\n./hemlock script.hml \"; rm -rf /; echo pwned\"\n# Executes: cat ; rm -rf /; echo pwned\n```\n\n### Safe Practices\n\n**1. Never use unsanitized user input:**\n```hemlock\n// Bad\nlet user_input = args[1];\nlet r = exec(\"process \" + user_input);  // DANGEROUS\n\n// Good - validate first\nfn is_safe_filename(name: string): bool {\n    // Only allow alphanumeric, dash, underscore, dot\n    let i = 0;\n    while (i < name.length) {\n        let c = name[i];\n        if (!(c >= 'a' && c <= 'z') &&\n            !(c >= 'A' && c <= 'Z') &&\n            !(c >= '0' && c <= '9') &&\n            c != '-' && c != '_' && c != '.') {\n            return false;\n        }\n        i = i + 1;\n    }\n    return true;\n}\n\nlet filename = args[1];\nif (is_safe_filename(filename)) {\n    let r = exec(\"cat \" + filename);\n} else {\n    print(\"Invalid filename\");\n}\n```\n\n**2. Use allowlists, not denylists:**\n```hemlock\n// Good - strict allowlist\nlet allowed_commands = [\"status\", \"start\", \"stop\", \"restart\"];\nlet cmd = args[1];\n\nlet found = false;\nfor (let allowed in allowed_commands) {\n    if (cmd == allowed) {\n        found = true;\n        break;\n    }\n}\n\nif (found) {\n    exec(\"service myapp \" + cmd);\n} else {\n    print(\"Invalid command\");\n}\n```\n\n**3. Escape special characters:**\n```hemlock\nfn shell_escape(s: string): string {\n    // Simple escape - wrap in single quotes and escape single quotes\n    let escaped = s.replace_all(\"'\", \"'\\\\''\");\n    return \"'\" + escaped + \"'\";\n}\n\nlet user_file = args[1];\nlet safe = shell_escape(user_file);\nlet r = exec(\"cat \" + safe);\n```\n\n**4. Avoid exec() for file operations:**\n```hemlock\n// Bad - use exec for file operations\nlet r = exec(\"cat file.txt\");\n\n// Good - use Hemlock's file API\nlet f = open(\"file.txt\", \"r\");\nlet content = f.read();\nf.close();\n```\n\n### Permission Considerations\n\nCommands run with the same permissions as the Hemlock process:\n\n```hemlock\n// If Hemlock runs as root, exec() commands also run as root!\nlet r = exec(\"rm -rf /important\");  // DANGEROUS if running as root\n```\n\n**Best practice:** Run Hemlock with least privilege necessary.\n\n## Limitations\n\n### 1. No stderr Capture\n\nOnly stdout is captured, stderr goes to terminal:\n\n```hemlock\nlet r = exec(\"ls /nonexistent\");\n// r.output is empty\n// Error message appears on terminal, not captured\n```\n\n**Workaround - redirect stderr to stdout:**\n```hemlock\nlet r = exec(\"ls /nonexistent 2>&1\");\n// Now error messages are in r.output\n```\n\n### 2. No Streaming\n\nMust wait for command completion:\n\n```hemlock\nlet r = exec(\"long_running_command\");\n// Blocks until command finishes\n// Cannot process output incrementally\n```\n\n### 3. No Timeout\n\nCommands can run indefinitely:\n\n```hemlock\nlet r = exec(\"sleep 1000\");\n// Blocks for 1000 seconds\n// No way to timeout or cancel\n```\n\n**Workaround - use timeout command:**\n```hemlock\nlet r = exec(\"timeout 5 long_command\");\n// Will timeout after 5 seconds\n```\n\n### 4. No Signal Handling\n\nCannot send signals to running commands:\n\n```hemlock\nlet r = exec(\"long_command\");\n// Cannot send SIGINT, SIGTERM, etc. to the command\n```\n\n### 5. No Process Control\n\nCannot interact with command after starting:\n\n```hemlock\nlet r = exec(\"interactive_program\");\n// Cannot send input to the program\n// Cannot control execution\n```\n\n## Use Cases\n\n### Good Use Cases\n\n**1. Running system utilities:**\n```hemlock\nlet r = exec(\"ls -la\");\nlet r = exec(\"grep pattern file.txt\");\nlet r = exec(\"find /path -name '*.txt'\");\n```\n\n**2. Quick data processing with Unix tools:**\n```hemlock\nlet r = exec(\"cat data.txt | sort | uniq | wc -l\");\nprint(\"Unique lines: \" + r.output);\n```\n\n**3. Checking system state:**\n```hemlock\nlet r = exec(\"df -h\");\nprint(\"Disk usage:\\n\" + r.output);\n```\n\n**4. File existence checks:**\n```hemlock\nlet r = exec(\"test -f myfile.txt\");\nif (r.exit_code == 0) {\n    print(\"File exists\");\n}\n```\n\n**5. Generating reports:**\n```hemlock\nlet r = exec(\"ps aux | grep myapp | wc -l\");\nlet count = r.output.trim();\nprint(\"Running instances: \" + count);\n```\n\n**6. Automation scripts:**\n```hemlock\nexec(\"git add .\");\nexec(\"git commit -m 'Auto commit'\");\nlet r = exec(\"git push\");\nif (r.exit_code != 0) {\n    print(\"Push failed\");\n}\n```\n\n### Not Recommended For\n\n**1. Long-running services:**\n```hemlock\n// Bad\nlet r = exec(\"nginx\");  // Blocks forever\n```\n\n**2. Interactive commands:**\n```hemlock\n// Bad - cannot provide input\nlet r = exec(\"ssh user@host\");\n```\n\n**3. Commands producing huge output:**\n```hemlock\n// Bad - loads entire output into memory\nlet r = exec(\"cat 10GB_file.log\");\n```\n\n**4. Real-time streaming:**\n```hemlock\n// Bad - cannot process output incrementally\nlet r = exec(\"tail -f /var/log/app.log\");\n```\n\n**5. Mission-critical error handling:**\n```hemlock\n// Bad - stderr not captured\nlet r = exec(\"critical_operation\");\n// Cannot see detailed error messages\n```\n\n## Best Practices\n\n### 1. Always Check Exit Codes\n\n```hemlock\nlet r = exec(\"important_command\");\nif (r.exit_code != 0) {\n    print(\"Command failed!\");\n    // Handle error\n}\n```\n\n### 2. Trim Output When Needed\n\n```hemlock\nlet r = exec(\"echo test\");\nlet clean = r.output.trim();  // Remove trailing newline\nprint(clean);  // \"test\" (no newline)\n```\n\n### 3. Validate Before Executing\n\n```hemlock\nfn is_valid_command(cmd: string): bool {\n    // Validate command is safe\n    return true;  // Your validation logic\n}\n\nif (is_valid_command(user_cmd)) {\n    exec(user_cmd);\n}\n```\n\n### 4. Use try/catch for Critical Operations\n\n```hemlock\ntry {\n    let r = exec(\"critical_command\");\n    if (r.exit_code != 0) {\n        throw \"Command failed\";\n    }\n} catch (e) {\n    print(\"Error: \" + e);\n    // Cleanup or recovery\n}\n```\n\n### 5. Prefer Hemlock APIs Over exec()\n\n```hemlock\n// Bad - use exec for file operations\nlet r = exec(\"cat file.txt\");\n\n// Good - use Hemlock's File API\nlet f = open(\"file.txt\", \"r\");\nlet content = f.read();\nf.close();\n```\n\n### 6. Capture stderr When Needed\n\n```hemlock\n// Redirect stderr to stdout\nlet r = exec(\"command 2>&1\");\n// Now r.output contains both stdout and stderr\n```\n\n### 7. Use Shell Features Wisely\n\n```hemlock\n// Use pipes for efficiency\nlet r = exec(\"cat large.txt | grep pattern | head -n 10\");\n\n// Use command substitution\nlet r = exec(\"echo Current user: $(whoami)\");\n\n// Use conditional execution\nlet r = exec(\"test -f file.txt && cat file.txt\");\n```\n\n## Complete Examples\n\n### Example 1: System Information Gatherer\n\n```hemlock\nfn get_system_info() {\n    print(\"=== System Information ===\");\n\n    // Hostname\n    let r1 = exec(\"hostname\");\n    print(\"Hostname: \" + r1.output.trim());\n\n    // Uptime\n    let r2 = exec(\"uptime\");\n    print(\"Uptime: \" + r2.output.trim());\n\n    // Disk usage\n    let r3 = exec(\"df -h /\");\n    print(\"\\nDisk Usage:\");\n    print(r3.output);\n\n    // Memory usage\n    let r4 = exec(\"free -h\");\n    print(\"Memory Usage:\");\n    print(r4.output);\n}\n\nget_system_info();\n```\n\n### Example 2: Log Analyzer\n\n```hemlock\nfn analyze_log(logfile: string) {\n    print(\"Analyzing log: \" + logfile);\n\n    // Count total lines\n    let r1 = exec(\"wc -l \" + logfile);\n    print(\"Total lines: \" + r1.output.trim());\n\n    // Count errors\n    let r2 = exec(\"grep -c ERROR \" + logfile + \" 2>/dev/null\");\n    let errors = r2.output.trim();\n    if (r2.exit_code == 0) {\n        print(\"Errors: \" + errors);\n    } else {\n        print(\"Errors: 0\");\n    }\n\n    // Count warnings\n    let r3 = exec(\"grep -c WARN \" + logfile + \" 2>/dev/null\");\n    let warnings = r3.output.trim();\n    if (r3.exit_code == 0) {\n        print(\"Warnings: \" + warnings);\n    } else {\n        print(\"Warnings: 0\");\n    }\n\n    // Recent errors\n    print(\"\\nRecent errors:\");\n    let r4 = exec(\"grep ERROR \" + logfile + \" | tail -n 5\");\n    print(r4.output);\n}\n\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <logfile>\");\n} else {\n    analyze_log(args[1]);\n}\n```\n\n### Example 3: Git Helper\n\n```hemlock\nfn git_status() {\n    let r = exec(\"git status --short\");\n    if (r.exit_code != 0) {\n        print(\"Error: Not a git repository\");\n        return;\n    }\n\n    if (r.output == \"\") {\n        print(\"Working directory clean\");\n    } else {\n        print(\"Changes:\");\n        print(r.output);\n    }\n}\n\nfn git_quick_commit(message: string) {\n    print(\"Adding all changes...\");\n    let r1 = exec(\"git add -A\");\n    if (r1.exit_code != 0) {\n        print(\"Error adding files\");\n        return;\n    }\n\n    print(\"Committing...\");\n    let safe_msg = message.replace_all(\"'\", \"'\\\\''\");\n    let r2 = exec(\"git commit -m '\" + safe_msg + \"'\");\n    if (r2.exit_code != 0) {\n        print(\"Error committing\");\n        return;\n    }\n\n    print(\"Committed successfully\");\n    print(r2.output);\n}\n\n// Usage\ngit_status();\nif (args.length > 1) {\n    git_quick_commit(args[1]);\n}\n```\n\n### Example 4: Backup Script\n\n```hemlock\nfn backup_directory(source: string, dest: string) {\n    print(\"Backing up \" + source + \" to \" + dest);\n\n    // Create backup directory\n    let r1 = exec(\"mkdir -p \" + dest);\n    if (r1.exit_code != 0) {\n        print(\"Error creating backup directory\");\n        return false;\n    }\n\n    // Create tarball with timestamp\n    let r2 = exec(\"date +%Y%m%d_%H%M%S\");\n    let timestamp = r2.output.trim();\n    let backup_file = dest + \"/backup_\" + timestamp + \".tar.gz\";\n\n    print(\"Creating archive: \" + backup_file);\n    let r3 = exec(\"tar -czf \" + backup_file + \" \" + source + \" 2>&1\");\n    if (r3.exit_code != 0) {\n        print(\"Error creating backup:\");\n        print(r3.output);\n        return false;\n    }\n\n    print(\"Backup completed successfully\");\n\n    // Show backup size\n    let r4 = exec(\"du -h \" + backup_file);\n    print(\"Backup size: \" + r4.output.trim());\n\n    return true;\n}\n\nif (args.length < 3) {\n    print(\"Usage: \" + args[0] + \" <source> <destination>\");\n} else {\n    backup_directory(args[1], args[2]);\n}\n```\n\n## Summary\n\nHemlock's `exec()` function provides:\n\n-  Simple shell command execution\n-  Output capture (stdout)\n-  Exit code checking\n-  Full shell feature access (pipes, redirects, etc.)\n-  Integration with system utilities\n\nRemember:\n- Always check exit codes\n- Be aware of security implications (shell injection)\n- Validate user input before using in commands\n- Prefer Hemlock APIs over exec() when available\n- stderr is not captured (use `2>&1` to redirect)\n- Commands block until completion\n- Use for short-running utilities, not long-running services\n\n**Security checklist:**\n-  Never use unsanitized user input\n-  Validate all input\n-  Use allowlists for commands\n-  Escape special characters when necessary\n-  Run with least privilege\n-  Prefer Hemlock APIs over shell commands\n"}, "Advanced Topics  Command Line Args": {"id": "advanced-command-line-args", "content": "# Command-Line Arguments in Hemlock\n\nHemlock programs can access command-line arguments via a built-in **`args` array** that is automatically populated at program startup.\n\n## Table of Contents\n\n- [Overview](#overview)\n- [The args Array](#the-args-array)\n- [Properties](#properties)\n- [Iteration Patterns](#iteration-patterns)\n- [Common Use Cases](#common-use-cases)\n- [Argument Parsing Patterns](#argument-parsing-patterns)\n- [Best Practices](#best-practices)\n- [Complete Examples](#complete-examples)\n\n## Overview\n\nThe `args` array provides access to command-line arguments passed to your Hemlock program:\n\n- **Always available** - Built-in global variable in all Hemlock programs\n- **Script name included** - `args[0]` always contains the script path/name\n- **Array of strings** - All arguments are strings\n- **Zero-indexed** - Standard array indexing (0, 1, 2, ...)\n\n## The args Array\n\n### Basic Structure\n\n```hemlock\n// args[0] is always the script filename\n// args[1] through args[n-1] are the actual arguments\nprint(args[0]);        // \"script.hml\"\nprint(args.length);    // Total number of arguments (including script name)\n```\n\n### Example Usage\n\n**Command:**\n```bash\n./hemlock script.hml hello world \"test 123\"\n```\n\n**In script.hml:**\n```hemlock\nprint(\"Script name: \" + args[0]);     // \"script.hml\"\nprint(\"Total args: \" + typeof(args.length));  // \"4\"\nprint(\"First arg: \" + args[1]);       // \"hello\"\nprint(\"Second arg: \" + args[2]);      // \"world\"\nprint(\"Third arg: \" + args[3]);       // \"test 123\"\n```\n\n### Index Reference\n\n| Index | Contains | Example Value |\n|-------|----------|---------------|\n| `args[0]` | Script path/name | `\"script.hml\"` or `\"./script.hml\"` |\n| `args[1]` | First argument | `\"hello\"` |\n| `args[2]` | Second argument | `\"world\"` |\n| `args[3]` | Third argument | `\"test 123\"` |\n| ... | ... | ... |\n| `args[n-1]` | Last argument | (varies) |\n\n## Properties\n\n### Always Present\n\n`args` is a global array available in **all** Hemlock programs:\n\n```hemlock\n// No need to declare or import\nprint(args.length);  // Works immediately\n```\n\n### Script Name Included\n\n`args[0]` always contains the script path/name:\n\n```hemlock\nprint(\"Running: \" + args[0]);\n```\n\n**Possible values for args[0]:**\n- `\"script.hml\"` - Just the filename\n- `\"./script.hml\"` - Relative path\n- `\"/home/user/script.hml\"` - Absolute path\n- Depends on how the script was invoked\n\n### Type: Array of Strings\n\nAll arguments are stored as strings:\n\n```hemlock\n// Arguments: ./hemlock script.hml 42 3.14 true\n\nprint(args[1]);  // \"42\" (string, not number)\nprint(args[2]);  // \"3.14\" (string, not number)\nprint(args[3]);  // \"true\" (string, not boolean)\n\n// Convert as needed:\nlet num = 42;  // Parse manually if needed\n```\n\n### Minimum Length\n\nAlways at least 1 (the script name):\n\n```hemlock\nprint(args.length);  // Minimum: 1\n```\n\n**Even with no arguments:**\n```bash\n./hemlock script.hml\n```\n\n```hemlock\n// In script.hml:\nprint(args.length);  // 1 (just script name)\n```\n\n### REPL Behavior\n\nIn the REPL, `args.length` is 0 (empty array):\n\n```hemlock\n# REPL session\n> print(args.length);\n0\n```\n\n## Iteration Patterns\n\n### Basic Iteration\n\nSkip `args[0]` (script name) and process actual arguments:\n\n```hemlock\nlet i = 1;\nwhile (i < args.length) {\n    print(\"Argument \" + typeof(i) + \": \" + args[i]);\n    i = i + 1;\n}\n```\n\n**Output for: `./hemlock script.hml foo bar baz`**\n```\nArgument 1: foo\nArgument 2: bar\nArgument 3: baz\n```\n\n### For-In Iteration (Including Script Name)\n\n```hemlock\nfor (let arg in args) {\n    print(arg);\n}\n```\n\n**Output:**\n```\nscript.hml\nfoo\nbar\nbaz\n```\n\n### Checking Argument Count\n\n```hemlock\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <argument>\");\n    // exit or return\n} else {\n    let arg = args[1];\n    // process arg\n}\n```\n\n### Processing All Arguments Except Script Name\n\n```hemlock\nlet actual_args = args.slice(1, args.length);\n\nfor (let arg in actual_args) {\n    print(\"Processing: \" + arg);\n}\n```\n\n## Common Use Cases\n\n### 1. Simple Argument Processing\n\nCheck for required argument:\n\n```hemlock\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <filename>\");\n} else {\n    let filename = args[1];\n    print(\"Processing file: \" + filename);\n    // ... process file\n}\n```\n\n**Usage:**\n```bash\n./hemlock script.hml data.txt\n# Output: Processing file: data.txt\n```\n\n### 2. Multiple Arguments\n\n```hemlock\nif (args.length < 3) {\n    print(\"Usage: \" + args[0] + \" <input> <output>\");\n} else {\n    let input_file = args[1];\n    let output_file = args[2];\n\n    print(\"Input: \" + input_file);\n    print(\"Output: \" + output_file);\n\n    // Process files...\n}\n```\n\n**Usage:**\n```bash\n./hemlock convert.hml input.txt output.txt\n```\n\n### 3. Variable Number of Arguments\n\nProcess all provided arguments:\n\n```hemlock\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <file1> [file2] [file3] ...\");\n} else {\n    print(\"Processing \" + typeof(args.length - 1) + \" files:\");\n\n    let i = 1;\n    while (i < args.length) {\n        print(\"  \" + args[i]);\n        process_file(args[i]);\n        i = i + 1;\n    }\n}\n```\n\n**Usage:**\n```bash\n./hemlock batch.hml file1.txt file2.txt file3.txt\n```\n\n### 4. Help Message\n\n```hemlock\nif (args.length < 2 || args[1] == \"--help\" || args[1] == \"-h\") {\n    print(\"Usage: \" + args[0] + \" [OPTIONS] <file>\");\n    print(\"Options:\");\n    print(\"  -h, --help     Show this help message\");\n    print(\"  -v, --verbose  Enable verbose output\");\n} else {\n    // Process normally\n}\n```\n\n### 5. Argument Validation\n\n```hemlock\nfn validate_file(filename: string): bool {\n    // Check if file exists (example)\n    return filename != \"\";\n}\n\nif (args.length < 2) {\n    print(\"Error: No filename provided\");\n} else if (!validate_file(args[1])) {\n    print(\"Error: Invalid file: \" + args[1]);\n} else {\n    print(\"Processing: \" + args[1]);\n}\n```\n\n## Argument Parsing Patterns\n\n### Named Arguments (Flags)\n\nSimple pattern for named arguments:\n\n```hemlock\nlet verbose = false;\nlet output_file = \"\";\nlet input_file = \"\";\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--verbose\" || args[i] == \"-v\") {\n        verbose = true;\n    } else if (args[i] == \"--output\" || args[i] == \"-o\") {\n        i = i + 1;\n        if (i < args.length) {\n            output_file = args[i];\n        }\n    } else {\n        input_file = args[i];\n    }\n    i = i + 1;\n}\n\nif (verbose) {\n    print(\"Verbose mode enabled\");\n}\nprint(\"Input: \" + input_file);\nprint(\"Output: \" + output_file);\n```\n\n**Usage:**\n```bash\n./hemlock script.hml --verbose --output out.txt input.txt\n./hemlock script.hml -v -o out.txt input.txt\n```\n\n### Boolean Flags\n\n```hemlock\nlet debug = false;\nlet verbose = false;\nlet force = false;\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--debug\") {\n        debug = true;\n    } else if (args[i] == \"--verbose\") {\n        verbose = true;\n    } else if (args[i] == \"--force\") {\n        force = true;\n    }\n    i = i + 1;\n}\n```\n\n### Value Arguments\n\n```hemlock\nlet config_file = \"default.conf\";\nlet port = 8080;\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--config\") {\n        i = i + 1;\n        if (i < args.length) {\n            config_file = args[i];\n        }\n    } else if (args[i] == \"--port\") {\n        i = i + 1;\n        if (i < args.length) {\n            port = 8080;  // Would need to parse string to int\n        }\n    }\n    i = i + 1;\n}\n```\n\n### Mixed Positional and Named Arguments\n\n```hemlock\nlet input_file = \"\";\nlet output_file = \"\";\nlet verbose = false;\n\nlet i = 1;\nlet positional = [];\n\nwhile (i < args.length) {\n    if (args[i] == \"--verbose\") {\n        verbose = true;\n    } else {\n        // Treat as positional argument\n        positional.push(args[i]);\n    }\n    i = i + 1;\n}\n\n// Assign positional arguments\nif (positional.length > 0) {\n    input_file = positional[0];\n}\nif (positional.length > 1) {\n    output_file = positional[1];\n}\n```\n\n### Argument Parser Helper Function\n\n```hemlock\nfn parse_args() {\n    let options = {\n        verbose: false,\n        output: \"\",\n        files: []\n    };\n\n    let i = 1;\n    while (i < args.length) {\n        let arg = args[i];\n\n        if (arg == \"--verbose\" || arg == \"-v\") {\n            options.verbose = true;\n        } else if (arg == \"--output\" || arg == \"-o\") {\n            i = i + 1;\n            if (i < args.length) {\n                options.output = args[i];\n            }\n        } else {\n            // Positional argument\n            options.files.push(arg);\n        }\n\n        i = i + 1;\n    }\n\n    return options;\n}\n\nlet opts = parse_args();\nprint(\"Verbose: \" + typeof(opts.verbose));\nprint(\"Output: \" + opts.output);\nprint(\"Files: \" + typeof(opts.files.length));\n```\n\n## Best Practices\n\n### 1. Always Check Argument Count\n\n```hemlock\n// Good\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <file>\");\n} else {\n    process_file(args[1]);\n}\n\n// Bad - may crash if no arguments\nprocess_file(args[1]);  // Error if args.length == 1\n```\n\n### 2. Provide Usage Information\n\n```hemlock\nfn show_usage() {\n    print(\"Usage: \" + args[0] + \" [OPTIONS] <file>\");\n    print(\"Options:\");\n    print(\"  -h, --help     Show help\");\n    print(\"  -v, --verbose  Verbose output\");\n}\n\nif (args.length < 2) {\n    show_usage();\n}\n```\n\n### 3. Validate Arguments\n\n```hemlock\nfn validate_args() {\n    if (args.length < 2) {\n        print(\"Error: Missing required argument\");\n        return false;\n    }\n\n    if (args[1] == \"\") {\n        print(\"Error: Empty argument\");\n        return false;\n    }\n\n    return true;\n}\n\nif (!validate_args()) {\n    // exit or show usage\n}\n```\n\n### 4. Use Descriptive Variable Names\n\n```hemlock\n// Good\nlet input_filename = args[1];\nlet output_filename = args[2];\nlet max_iterations = args[3];\n\n// Bad\nlet a = args[1];\nlet b = args[2];\nlet c = args[3];\n```\n\n### 5. Handle Quoted Arguments with Spaces\n\nShell automatically handles this:\n\n```bash\n./hemlock script.hml \"file with spaces.txt\"\n```\n\n```hemlock\nprint(args[1]);  // \"file with spaces.txt\"\n```\n\n### 6. Create Argument Objects\n\n```hemlock\nfn get_args() {\n    return {\n        script: args[0],\n        input: args[1],\n        output: args[2]\n    };\n}\n\nlet arguments = get_args();\nprint(\"Input: \" + arguments.input);\n```\n\n## Complete Examples\n\n### Example 1: File Processor\n\n```hemlock\n// Usage: ./hemlock process.hml <input> <output>\n\nfn show_usage() {\n    print(\"Usage: \" + args[0] + \" <input_file> <output_file>\");\n}\n\nif (args.length < 3) {\n    show_usage();\n} else {\n    let input = args[1];\n    let output = args[2];\n\n    print(\"Processing \" + input + \" -> \" + output);\n\n    // Process files\n    let f_in = open(input, \"r\");\n    let f_out = open(output, \"w\");\n\n    try {\n        let content = f_in.read();\n        let processed = content.to_upper();  // Example processing\n        f_out.write(processed);\n\n        print(\"Done!\");\n    } finally {\n        f_in.close();\n        f_out.close();\n    }\n}\n```\n\n### Example 2: Batch File Processor\n\n```hemlock\n// Usage: ./hemlock batch.hml <file1> <file2> <file3> ...\n\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <file1> [file2] [file3] ...\");\n} else {\n    print(\"Processing \" + typeof(args.length - 1) + \" files:\");\n\n    let i = 1;\n    while (i < args.length) {\n        let filename = args[i];\n        print(\"  Processing: \" + filename);\n\n        try {\n            let f = open(filename, \"r\");\n            let content = f.read();\n            f.close();\n\n            // Process content...\n            print(\"    \" + typeof(content.length) + \" bytes\");\n        } catch (e) {\n            print(\"    Error: \" + e);\n        }\n\n        i = i + 1;\n    }\n\n    print(\"Done!\");\n}\n```\n\n### Example 3: Advanced Argument Parser\n\n```hemlock\n// Usage: ./hemlock app.hml [OPTIONS] <files...>\n// Options:\n//   --verbose, -v     Enable verbose output\n//   --output, -o FILE Set output file\n//   --help, -h        Show help\n\nfn parse_arguments() {\n    let config = {\n        verbose: false,\n        output: \"output.txt\",\n        help: false,\n        files: []\n    };\n\n    let i = 1;\n    while (i < args.length) {\n        let arg = args[i];\n\n        if (arg == \"--verbose\" || arg == \"-v\") {\n            config.verbose = true;\n        } else if (arg == \"--output\" || arg == \"-o\") {\n            i = i + 1;\n            if (i < args.length) {\n                config.output = args[i];\n            } else {\n                print(\"Error: --output requires a value\");\n            }\n        } else if (arg == \"--help\" || arg == \"-h\") {\n            config.help = true;\n        } else if (arg.starts_with(\"--\")) {\n            print(\"Error: Unknown option: \" + arg);\n        } else {\n            config.files.push(arg);\n        }\n\n        i = i + 1;\n    }\n\n    return config;\n}\n\nfn show_help() {\n    print(\"Usage: \" + args[0] + \" [OPTIONS] <files...>\");\n    print(\"Options:\");\n    print(\"  --verbose, -v     Enable verbose output\");\n    print(\"  --output, -o FILE Set output file\");\n    print(\"  --help, -h        Show this help\");\n}\n\nlet config = parse_arguments();\n\nif (config.help) {\n    show_help();\n} else if (config.files.length == 0) {\n    print(\"Error: No input files specified\");\n    show_help();\n} else {\n    if (config.verbose) {\n        print(\"Verbose mode enabled\");\n        print(\"Output file: \" + config.output);\n        print(\"Input files: \" + typeof(config.files.length));\n    }\n\n    // Process files\n    for (let file in config.files) {\n        if (config.verbose) {\n            print(\"Processing: \" + file);\n        }\n        // ... process file\n    }\n}\n```\n\n### Example 4: Configuration Tool\n\n```hemlock\n// Usage: ./hemlock config.hml <action> [arguments]\n// Actions:\n//   get <key>\n//   set <key> <value>\n//   list\n\nfn show_usage() {\n    print(\"Usage: \" + args[0] + \" <action> [arguments]\");\n    print(\"Actions:\");\n    print(\"  get <key>         Get configuration value\");\n    print(\"  set <key> <value> Set configuration value\");\n    print(\"  list              List all configuration\");\n}\n\nif (args.length < 2) {\n    show_usage();\n} else {\n    let action = args[1];\n\n    if (action == \"get\") {\n        if (args.length < 3) {\n            print(\"Error: 'get' requires a key\");\n        } else {\n            let key = args[2];\n            print(\"Getting: \" + key);\n            // ... get from config\n        }\n    } else if (action == \"set\") {\n        if (args.length < 4) {\n            print(\"Error: 'set' requires key and value\");\n        } else {\n            let key = args[2];\n            let value = args[3];\n            print(\"Setting \" + key + \" = \" + value);\n            // ... set in config\n        }\n    } else if (action == \"list\") {\n        print(\"Listing all configuration:\");\n        // ... list config\n    } else {\n        print(\"Error: Unknown action: \" + action);\n        show_usage();\n    }\n}\n```\n\n## Summary\n\nHemlock's command-line argument support provides:\n\n-  Built-in `args` array available globally\n-  Simple array-based access to arguments\n-  Script name in `args[0]`\n-  All arguments as strings\n-  Array methods available (.length, .slice, etc.)\n\nRemember:\n- Always check `args.length` before accessing elements\n- `args[0]` is the script name\n- Actual arguments start at `args[1]`\n- All arguments are strings - convert as needed\n- Provide usage information for user-friendly tools\n- Validate arguments before processing\n\nCommon patterns:\n- Simple positional arguments\n- Named/flag arguments (--flag)\n- Value arguments (--option value)\n- Help messages (--help)\n- Argument validation\n"}, "Advanced Topics  Ffi": {"id": "advanced-ffi", "content": "# Foreign Function Interface (FFI) in Hemlock\n\nHemlock provides **FFI (Foreign Function Interface)** to call C functions from shared libraries using libffi, enabling integration with existing C libraries and system APIs.\n\n## Table of Contents\n\n- [Overview](#overview)\n- [Current Status](#current-status)\n- [Supported Types](#supported-types)\n- [Basic Concepts](#basic-concepts)\n- [Use Cases](#use-cases)\n- [Future Development](#future-development)\n\n## Overview\n\nThe Foreign Function Interface (FFI) allows Hemlock programs to:\n- Call C functions from shared libraries (.so, .dylib, .dll)\n- Use existing C libraries without writing wrapper code\n- Access system APIs directly\n- Integrate with third-party native libraries\n- Bridge Hemlock with low-level system functionality\n\n**Key capabilities:**\n- Dynamic library loading\n- C function binding\n- Automatic type conversion between Hemlock and C types\n- Support for all primitive types\n- libffi-based implementation for portability\n\n## Current Status\n\nFFI support is available in Hemlock v0.1 with the following features:\n\n**Implemented:**\n-  Call C functions from shared libraries\n-  Support for all primitive types (integers, floats, pointers)\n-  Automatic type conversion\n-  libffi-based implementation\n-  Dynamic library loading\n\n**In Development:**\n-  Struct passing and return values\n-  Array/buffer handling\n-  Function pointer callbacks\n-  String marshaling helpers\n-  Error handling improvements\n\n**Test Coverage:**\n- 3 FFI tests passing (as of v0.1)\n- Basic function calling verified\n- Type conversion tested\n\n## Supported Types\n\n### Primitive Types\n\nThe following Hemlock types can be passed to/from C functions:\n\n| Hemlock Type | C Type | Size | Notes |\n|--------------|--------|------|-------|\n| `i8` | `int8_t` | 1 byte | Signed 8-bit integer |\n| `i16` | `int16_t` | 2 bytes | Signed 16-bit integer |\n| `i32` | `int32_t` | 4 bytes | Signed 32-bit integer |\n| `i64` | `int64_t` | 8 bytes | Signed 64-bit integer |\n| `u8` | `uint8_t` | 1 byte | Unsigned 8-bit integer |\n| `u16` | `uint16_t` | 2 bytes | Unsigned 16-bit integer |\n| `u32` | `uint32_t` | 4 bytes | Unsigned 32-bit integer |\n| `u64` | `uint64_t` | 8 bytes | Unsigned 64-bit integer |\n| `f32` | `float` | 4 bytes | 32-bit floating point |\n| `f64` | `double` | 8 bytes | 64-bit floating point |\n| `ptr` | `void*` | 8 bytes | Raw pointer |\n\n### Type Conversion\n\n**Automatic conversions:**\n- Hemlock integers  C integers (with range checking)\n- Hemlock floats  C floats\n- Hemlock pointers  C pointers\n- C return values  Hemlock values\n\n**Example type mappings:**\n```hemlock\n// Hemlock  C\nlet i: i32 = 42;         //  int32_t (4 bytes)\nlet f: f64 = 3.14;       //  double (8 bytes)\nlet p: ptr = alloc(64);  //  void* (8 bytes)\n\n// C  Hemlock (return values)\n// int32_t foo()  i32\n// double bar()  f64\n// void* baz()  ptr\n```\n\n## Basic Concepts\n\n### Shared Libraries\n\nFFI works with compiled shared libraries:\n\n**Linux:** `.so` files\n```\nlibexample.so\n/usr/lib/libm.so\n```\n\n**macOS:** `.dylib` files\n```\nlibexample.dylib\n/usr/lib/libSystem.dylib\n```\n\n**Windows:** `.dll` files\n```\nexample.dll\nkernel32.dll\n```\n\n### Function Signatures\n\nC functions must have known signatures for FFI to work correctly:\n\n```c\n// Example C function signatures\nint add(int a, int b);\ndouble sqrt(double x);\nvoid* malloc(size_t size);\nvoid free(void* ptr);\n```\n\nThese can be called from Hemlock once the library is loaded and functions are bound.\n\n### Platform Compatibility\n\nFFI uses **libffi** for portability:\n- Works on x86, x86-64, ARM, ARM64\n- Handles calling conventions automatically\n- Abstracts platform-specific ABI details\n- Supports Linux, macOS, Windows (with appropriate libffi)\n\n## Use Cases\n\n### 1. System Libraries\n\nAccess standard C library functions:\n\n**Math functions:**\n```hemlock\n// Call sqrt from libm\nlet result = sqrt(16.0);  // 4.0\n```\n\n**Memory allocation:**\n```hemlock\n// Call malloc/free from libc\nlet ptr = malloc(1024);\nfree(ptr);\n```\n\n### 2. Third-Party Libraries\n\nUse existing C libraries:\n\n**Example: Image processing**\n```hemlock\n// Load libpng or libjpeg\n// Process images using C library functions\n```\n\n**Example: Cryptography**\n```hemlock\n// Use OpenSSL or libsodium\n// Encryption/decryption via FFI\n```\n\n### 3. System APIs\n\nDirect system calls:\n\n**Example: POSIX APIs**\n```hemlock\n// Call getpid, getuid, etc.\n// Access low-level system functionality\n```\n\n### 4. Performance-Critical Code\n\nCall optimized C implementations:\n\n```hemlock\n// Use highly-optimized C libraries\n// SIMD operations, vectorized code\n// Hardware-accelerated functions\n```\n\n### 5. Hardware Access\n\nInterface with hardware libraries:\n\n```hemlock\n// GPIO control on embedded systems\n// USB device communication\n// Serial port access\n```\n\n### 6. Legacy Code Integration\n\nReuse existing C codebases:\n\n```hemlock\n// Call functions from legacy C applications\n// Gradually migrate to Hemlock\n// Preserve working C code\n```\n\n## Future Development\n\n### Planned Features\n\n**1. Struct Support**\n```hemlock\n// Future: Pass/return C structs\ndefine Point {\n    x: f64,\n    y: f64,\n}\n\nlet p = Point { x: 1.0, y: 2.0 };\nc_function_with_struct(p);\n```\n\n**2. Array/Buffer Handling**\n```hemlock\n// Future: Better array passing\nlet arr = [1, 2, 3, 4, 5];\nprocess_array(arr);  // Pass to C function\n```\n\n**3. Function Pointer Callbacks**\n```hemlock\n// Future: Pass Hemlock functions to C\nfn my_callback(x: i32): i32 {\n    return x * 2;\n}\n\nc_function_with_callback(my_callback);\n```\n\n**4. String Marshaling**\n```hemlock\n// Future: Automatic string conversion\nlet s = \"hello\";\nc_string_function(s);  // Auto-convert to C string\n```\n\n**5. Error Handling**\n```hemlock\n// Future: Better error reporting\ntry {\n    let result = risky_c_function();\n} catch (e) {\n    print(\"FFI error: \" + e);\n}\n```\n\n**6. Type Safety**\n```hemlock\n// Future: Type annotations for FFI\n@ffi(\"libm.so\")\nfn sqrt(x: f64): f64;\n\nlet result = sqrt(16.0);  // Type-checked\n```\n\n### Roadmap\n\n**v0.1 (Current):**\n-  Basic FFI with primitive types\n-  Dynamic library loading\n-  Function calling\n\n**v0.2 (Planned):**\n-  Struct support\n-  Array handling\n-  String marshaling\n-  Function pointers\n\n**v0.3 (Future):**\n-  Advanced type mapping\n-  Automatic binding generation\n-  FFI debugging tools\n-  Performance optimizations\n\n## Current Limitations\n\nAs of v0.1, FFI has the following limitations:\n\n**1. No Struct Passing**\n- Cannot pass complex structs by value\n- Workaround: Pass pointers to structs\n\n**2. Manual Type Conversion**\n- Must manually manage string conversions\n- No automatic Hemlock string  C string conversion\n\n**3. Limited Error Handling**\n- Basic error reporting\n- No detailed FFI error messages yet\n\n**4. No Callback Support**\n- Cannot pass Hemlock functions to C\n- C functions with callbacks not yet supported\n\n**5. Manual Library Loading**\n- Must manually load libraries\n- No automatic binding generation\n\n**6. Platform-Specific Code**\n- Library paths differ by platform\n- Must handle .so vs .dylib vs .dll\n\n## Best Practices\n\nWhile comprehensive FFI documentation is still being developed, here are general best practices:\n\n### 1. Type Safety\n\n```hemlock\n// Be explicit about types\nlet x: i32 = 42;\nlet result: f64 = c_function(x);\n```\n\n### 2. Memory Management\n\n```hemlock\n// Remember to free allocated memory\nlet ptr = c_malloc(1024);\n// ... use ptr\nc_free(ptr);\n```\n\n### 3. Error Checking\n\n```hemlock\n// Check return values\nlet result = c_function();\nif (result == null) {\n    print(\"C function failed\");\n}\n```\n\n### 4. Platform Compatibility\n\n```hemlock\n// Handle platform differences\n// Use appropriate library extensions (.so, .dylib, .dll)\n```\n\n## Examples\n\nDetailed examples will be added as FFI documentation is expanded. For now, refer to:\n- Test suite: `/tests/ffi/` (3 tests)\n- Example programs: `/examples/` (if available)\n\n## Getting Help\n\nFFI is a newer feature in Hemlock. For questions or issues:\n\n1. Check test suite for working examples\n2. Refer to libffi documentation for low-level details\n3. Report bugs or request features via project issues\n\n## Summary\n\nHemlock's FFI provides:\n\n-  C function calling from shared libraries\n-  Primitive type support (i8-i64, u8-u64, f32, f64, ptr)\n-  Automatic type conversion\n-  libffi-based portability\n-  Foundation for native library integration\n\n**Current status:** Basic FFI available in v0.1 with primitive types\n\n**Coming soon:** Structs, arrays, callbacks, string marshaling\n\n**Use cases:** System libraries, third-party libraries, performance-critical code, hardware access\n\n---\n\n**Note:** This documentation reflects FFI features as of Hemlock v0.1. FFI is under active development, and this document will be updated as features are added. For the most current information, refer to the test suite and CLAUDE.md.\n\n## Contributing\n\nFFI documentation is being expanded. If you're working with FFI:\n- Document your use cases\n- Share example code\n- Report issues or limitations\n- Suggest improvements\n\nThe FFI system is designed to be practical and safe while providing low-level access when needed, following Hemlock's philosophy of \"explicit over implicit\" and \"unsafe is a feature, not a bug.\"\n"}, "Advanced Topics  File Io": {"id": "advanced-file-io", "content": "# File I/O in Hemlock\n\nHemlock provides a **File object API** for file operations with proper error handling and resource management.\n\n## Table of Contents\n\n- [Overview](#overview)\n- [Opening Files](#opening-files)\n- [File Methods](#file-methods)\n- [File Properties](#file-properties)\n- [Error Handling](#error-handling)\n- [Resource Management](#resource-management)\n- [Complete API Reference](#complete-api-reference)\n- [Common Patterns](#common-patterns)\n- [Best Practices](#best-practices)\n\n## Overview\n\nThe File object API provides:\n\n- **Explicit resource management** - Files must be manually closed\n- **Multiple open modes** - Read, write, append, read/write\n- **Text and binary operations** - Read/write both text and binary data\n- **Seeking support** - Random access within files\n- **Comprehensive error messages** - Context-aware error reporting\n\n**Important:** Files are not automatically closed. You must call `f.close()` to avoid file descriptor leaks.\n\n## Opening Files\n\nUse `open(path, mode?)` to open a file:\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");     // Read mode (default)\nlet f2 = open(\"output.txt\", \"w\");  // Write mode (truncate)\nlet f3 = open(\"log.txt\", \"a\");     // Append mode\nlet f4 = open(\"data.bin\", \"r+\");   // Read/write mode\n```\n\n### Open Modes\n\n| Mode | Description | File Must Exist | Truncates | Position |\n|------|-------------|----------------|-----------|----------|\n| `\"r\"` | Read (default) | Yes | No | Start |\n| `\"w\"` | Write | No (creates) | Yes | Start |\n| `\"a\"` | Append | No (creates) | No | End |\n| `\"r+\"` | Read and write | Yes | No | Start |\n| `\"w+\"` | Read and write | No (creates) | Yes | Start |\n| `\"a+\"` | Read and append | No (creates) | No | End |\n\n### Examples\n\n**Reading an existing file:**\n```hemlock\nlet f = open(\"config.json\", \"r\");\n// or simply:\nlet f = open(\"config.json\");  // \"r\" is default\n```\n\n**Creating a new file for writing:**\n```hemlock\nlet f = open(\"output.txt\", \"w\");  // Creates or truncates\n```\n\n**Appending to a file:**\n```hemlock\nlet f = open(\"log.txt\", \"a\");  // Creates if doesn't exist\n```\n\n**Read and write mode:**\n```hemlock\nlet f = open(\"data.bin\", \"r+\");  // Existing file, can read/write\n```\n\n## File Methods\n\n### Reading\n\n#### read(size?: i32): string\n\nRead text from file (optional size parameter).\n\n**Without size (read all):**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet all = f.read();  // Read from current position to EOF\nf.close();\n```\n\n**With size (read specific bytes):**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet chunk = f.read(1024);  // Read up to 1024 bytes\nlet next = f.read(1024);   // Read next 1024 bytes\nf.close();\n```\n\n**Returns:** String containing the read data, or empty string if at EOF\n\n**Example - Reading entire file:**\n```hemlock\nlet f = open(\"poem.txt\", \"r\");\nlet content = f.read();\nprint(content);\nf.close();\n```\n\n**Example - Reading in chunks:**\n```hemlock\nlet f = open(\"large.txt\", \"r\");\nwhile (true) {\n    let chunk = f.read(4096);  // 4KB chunks\n    if (chunk == \"\") { break; }  // EOF reached\n    process(chunk);\n}\nf.close();\n```\n\n#### read_bytes(size: i32): buffer\n\nRead binary data (returns buffer).\n\n**Parameters:**\n- `size` (i32) - Number of bytes to read\n\n**Returns:** Buffer containing the read bytes\n\n```hemlock\nlet f = open(\"image.png\", \"r\");\nlet binary = f.read_bytes(256);  // Read 256 bytes\nprint(binary.length);  // 256 (or less if EOF)\n\n// Access individual bytes\nlet first_byte = binary[0];\nprint(first_byte);\n\nf.close();\n```\n\n**Example - Reading entire binary file:**\n```hemlock\nlet f = open(\"data.bin\", \"r\");\nlet size = 10240;  // Expected size\nlet data = f.read_bytes(size);\nf.close();\n\n// Process binary data\nlet i = 0;\nwhile (i < data.length) {\n    let byte = data[i];\n    // ... process byte\n    i = i + 1;\n}\n```\n\n### Writing\n\n#### write(data: string): i32\n\nWrite text to file (returns bytes written).\n\n**Parameters:**\n- `data` (string) - Text to write\n\n**Returns:** Number of bytes written (i32)\n\n```hemlock\nlet f = open(\"output.txt\", \"w\");\nlet written = f.write(\"Hello, World!\\n\");\nprint(\"Wrote \" + typeof(written) + \" bytes\");  // \"Wrote 14 bytes\"\nf.close();\n```\n\n**Example - Writing multiple lines:**\n```hemlock\nlet f = open(\"output.txt\", \"w\");\nf.write(\"Line 1\\n\");\nf.write(\"Line 2\\n\");\nf.write(\"Line 3\\n\");\nf.close();\n```\n\n**Example - Appending to log file:**\n```hemlock\nlet f = open(\"app.log\", \"a\");\nf.write(\"[INFO] Application started\\n\");\nf.write(\"[INFO] User logged in\\n\");\nf.close();\n```\n\n#### write_bytes(data: buffer): i32\n\nWrite binary data (returns bytes written).\n\n**Parameters:**\n- `data` (buffer) - Binary data to write\n\n**Returns:** Number of bytes written (i32)\n\n```hemlock\nlet f = open(\"output.bin\", \"w\");\n\n// Create binary data\nlet buf = buffer(10);\nbuf[0] = 65;  // 'A'\nbuf[1] = 66;  // 'B'\nbuf[2] = 67;  // 'C'\n\nlet bytes = f.write_bytes(buf);\nprint(\"Wrote \" + typeof(bytes) + \" bytes\");\n\nf.close();\n```\n\n**Example - Copying binary file:**\n```hemlock\nlet src = open(\"input.bin\", \"r\");\nlet dst = open(\"output.bin\", \"w\");\n\nlet data = src.read_bytes(1024);\nwhile (data.length > 0) {\n    dst.write_bytes(data);\n    data = src.read_bytes(1024);\n}\n\nsrc.close();\ndst.close();\n```\n\n### Seeking\n\n#### seek(position: i32): i32\n\nMove to specific position (returns new position).\n\n**Parameters:**\n- `position` (i32) - Byte offset from beginning of file\n\n**Returns:** New position (i32)\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\n// Move to byte 100\nf.seek(100);\n\n// Read from position 100\nlet data = f.read(50);\n\n// Reset to beginning\nf.seek(0);\n\nf.close();\n```\n\n**Example - Random access:**\n```hemlock\nlet f = open(\"records.dat\", \"r\");\n\n// Read record at offset 1000\nf.seek(1000);\nlet record1 = f.read_bytes(100);\n\n// Read record at offset 2000\nf.seek(2000);\nlet record2 = f.read_bytes(100);\n\nf.close();\n```\n\n#### tell(): i32\n\nGet current position in file.\n\n**Returns:** Current byte offset (i32)\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nlet pos1 = f.tell();  // 0 (at start)\n\nf.read(100);\nlet pos2 = f.tell();  // 100 (after reading 100 bytes)\n\nf.seek(500);\nlet pos3 = f.tell();  // 500 (after seeking)\n\nf.close();\n```\n\n**Example - Measuring read amount:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nlet start = f.tell();\nlet content = f.read();\nlet end = f.tell();\n\nlet bytes_read = end - start;\nprint(\"Read \" + typeof(bytes_read) + \" bytes\");\n\nf.close();\n```\n\n### Closing\n\n#### close()\n\nClose file (idempotent, can call multiple times).\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n// ... use file\nf.close();\nf.close();  // Safe - no error on second close\n```\n\n**Important notes:**\n- Always close files when done to avoid file descriptor leaks\n- Closing is idempotent - can call multiple times safely\n- After closing, all other operations will error\n- Use `finally` blocks to ensure files are closed even on errors\n\n## File Properties\n\nFile objects have three read-only properties:\n\n### path: string\n\nThe file path used to open the file.\n\n```hemlock\nlet f = open(\"/path/to/file.txt\", \"r\");\nprint(f.path);  // \"/path/to/file.txt\"\nf.close();\n```\n\n### mode: string\n\nThe mode the file was opened with.\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.mode);  // \"r\"\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nprint(f2.mode);  // \"w\"\nf2.close();\n```\n\n### closed: bool\n\nWhether the file is closed.\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.closed);  // false\n\nf.close();\nprint(f.closed);  // true\n```\n\n**Example - Checking if file is open:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nif (!f.closed) {\n    let content = f.read();\n    // ... process content\n}\n\nf.close();\n\nif (f.closed) {\n    print(\"File is now closed\");\n}\n```\n\n## Error Handling\n\nAll file operations include proper error messages with context.\n\n### Common Errors\n\n**File not found:**\n```hemlock\nlet f = open(\"missing.txt\", \"r\");\n// Error: Failed to open 'missing.txt': No such file or directory\n```\n\n**Reading from closed file:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nf.close();\nf.read();\n// Error: Cannot read from closed file 'data.txt'\n```\n\n**Writing to read-only file:**\n```hemlock\nlet f = open(\"readonly.txt\", \"r\");\nf.write(\"data\");\n// Error: Cannot write to file 'readonly.txt' opened in read-only mode\n```\n\n**Reading from write-only file:**\n```hemlock\nlet f = open(\"output.txt\", \"w\");\nf.read();\n// Error: Cannot read from file 'output.txt' opened in write-only mode\n```\n\n### Using try/catch\n\n```hemlock\ntry {\n    let f = open(\"data.txt\", \"r\");\n    let content = f.read();\n    f.close();\n    process(content);\n} catch (e) {\n    print(\"Error reading file: \" + e);\n}\n```\n\n## Resource Management\n\n### Basic Pattern\n\nAlways close files explicitly:\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n```\n\n### With Error Handling (Recommended)\n\nUse `finally` to ensure files are closed even on errors:\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\ntry {\n    let content = f.read();\n    process(content);\n} finally {\n    f.close();  // Always close, even on error\n}\n```\n\n### Multiple Files\n\n```hemlock\nlet src = null;\nlet dst = null;\n\ntry {\n    src = open(\"input.txt\", \"r\");\n    dst = open(\"output.txt\", \"w\");\n\n    let content = src.read();\n    dst.write(content);\n} finally {\n    if (src != null) { src.close(); }\n    if (dst != null) { dst.close(); }\n}\n```\n\n### Helper Function Pattern\n\n```hemlock\nfn with_file(path: string, mode: string, callback) {\n    let f = open(path, mode);\n    try {\n        return callback(f);\n    } finally {\n        f.close();\n    }\n}\n\n// Usage:\nwith_file(\"data.txt\", \"r\", fn(f) {\n    return f.read();\n});\n```\n\n## Complete API Reference\n\n### Functions\n\n| Function | Parameters | Returns | Description |\n|----------|-----------|---------|-------------|\n| `open(path, mode?)` | path: string, mode?: string | File | Open file (mode defaults to \"r\") |\n\n### Methods\n\n| Method | Parameters | Returns | Description |\n|--------|-----------|---------|-------------|\n| `read(size?)` | size?: i32 | string | Read text (all or specific bytes) |\n| `read_bytes(size)` | size: i32 | buffer | Read binary data |\n| `write(data)` | data: string | i32 | Write text, returns bytes written |\n| `write_bytes(data)` | data: buffer | i32 | Write binary data, returns bytes written |\n| `seek(position)` | position: i32 | i32 | Seek to position, returns new position |\n| `tell()` | - | i32 | Get current position |\n| `close()` | - | null | Close file (idempotent) |\n\n### Properties (read-only)\n\n| Property | Type | Description |\n|----------|------|-------------|\n| `path` | string | File path |\n| `mode` | string | Open mode |\n| `closed` | bool | Whether file is closed |\n\n## Common Patterns\n\n### Reading Entire File\n\n```hemlock\nfn read_file(path: string): string {\n    let f = open(path, \"r\");\n    try {\n        return f.read();\n    } finally {\n        f.close();\n    }\n}\n\nlet content = read_file(\"config.json\");\n```\n\n### Writing Entire File\n\n```hemlock\nfn write_file(path: string, content: string) {\n    let f = open(path, \"w\");\n    try {\n        f.write(content);\n    } finally {\n        f.close();\n    }\n}\n\nwrite_file(\"output.txt\", \"Hello, World!\");\n```\n\n### Appending to File\n\n```hemlock\nfn append_file(path: string, content: string) {\n    let f = open(path, \"a\");\n    try {\n        f.write(content);\n    } finally {\n        f.close();\n    }\n}\n\nappend_file(\"log.txt\", \"[INFO] Event occurred\\n\");\n```\n\n### Reading Lines\n\n```hemlock\nfn read_lines(path: string) {\n    let f = open(path, \"r\");\n    try {\n        let content = f.read();\n        return content.split(\"\\n\");\n    } finally {\n        f.close();\n    }\n}\n\nlet lines = read_lines(\"data.txt\");\nlet i = 0;\nwhile (i < lines.length) {\n    print(\"Line \" + typeof(i) + \": \" + lines[i]);\n    i = i + 1;\n}\n```\n\n### Processing Large Files in Chunks\n\n```hemlock\nfn process_large_file(path: string) {\n    let f = open(path, \"r\");\n    try {\n        while (true) {\n            let chunk = f.read(4096);  // 4KB chunks\n            if (chunk == \"\") { break; }\n\n            // Process chunk\n            process_chunk(chunk);\n        }\n    } finally {\n        f.close();\n    }\n}\n```\n\n### Binary File Copy\n\n```hemlock\nfn copy_file(src_path: string, dst_path: string) {\n    let src = null;\n    let dst = null;\n\n    try {\n        src = open(src_path, \"r\");\n        dst = open(dst_path, \"w\");\n\n        while (true) {\n            let chunk = src.read_bytes(4096);\n            if (chunk.length == 0) { break; }\n\n            dst.write_bytes(chunk);\n        }\n    } finally {\n        if (src != null) { src.close(); }\n        if (dst != null) { dst.close(); }\n    }\n}\n\ncopy_file(\"input.dat\", \"output.dat\");\n```\n\n### File Truncation\n\n```hemlock\nfn truncate_file(path: string) {\n    let f = open(path, \"w\");  // \"w\" mode truncates\n    f.close();\n}\n\ntruncate_file(\"empty_me.txt\");\n```\n\n### Random Access Read\n\n```hemlock\nfn read_at_offset(path: string, offset: i32, size: i32): string {\n    let f = open(path, \"r\");\n    try {\n        f.seek(offset);\n        return f.read(size);\n    } finally {\n        f.close();\n    }\n}\n\nlet data = read_at_offset(\"records.dat\", 1000, 100);\n```\n\n### File Size\n\n```hemlock\nfn file_size(path: string): i32 {\n    let f = open(path, \"r\");\n    try {\n        // Seek to end\n        let end = f.seek(999999999);  // Large number\n        f.seek(0);  // Reset\n        return end;\n    } finally {\n        f.close();\n    }\n}\n\nlet size = file_size(\"data.txt\");\nprint(\"File size: \" + typeof(size) + \" bytes\");\n```\n\n### Conditional Read/Write\n\n```hemlock\nfn update_file(path: string, condition, new_content: string) {\n    let f = open(path, \"r+\");\n    try {\n        let content = f.read();\n\n        if (condition(content)) {\n            f.seek(0);  // Reset to beginning\n            f.write(new_content);\n        }\n    } finally {\n        f.close();\n    }\n}\n```\n\n## Best Practices\n\n### 1. Always Use try/finally\n\n```hemlock\n// Good\nlet f = open(\"data.txt\", \"r\");\ntry {\n    let content = f.read();\n    process(content);\n} finally {\n    f.close();\n}\n\n// Bad - file might not close on error\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nprocess(content);  // If this throws, file leaks\nf.close();\n```\n\n### 2. Check File State Before Operations\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nif (!f.closed) {\n    let content = f.read();\n    // ... use content\n}\n\nf.close();\n```\n\n### 3. Use Appropriate Modes\n\n```hemlock\n// Reading only? Use \"r\"\nlet f = open(\"config.json\", \"r\");\n\n// Completely replacing? Use \"w\"\nlet f = open(\"output.txt\", \"w\");\n\n// Adding to end? Use \"a\"\nlet f = open(\"log.txt\", \"a\");\n```\n\n### 4. Handle Errors Gracefully\n\n```hemlock\nfn safe_read_file(path: string): string {\n    try {\n        let f = open(path, \"r\");\n        try {\n            return f.read();\n        } finally {\n            f.close();\n        }\n    } catch (e) {\n        print(\"Warning: Could not read \" + path + \": \" + e);\n        return \"\";\n    }\n}\n```\n\n### 5. Close Files in Reverse Order of Opening\n\n```hemlock\nlet f1 = null;\nlet f2 = null;\nlet f3 = null;\n\ntry {\n    f1 = open(\"file1.txt\", \"r\");\n    f2 = open(\"file2.txt\", \"r\");\n    f3 = open(\"file3.txt\", \"r\");\n\n    // ... use files\n} finally {\n    // Close in reverse order\n    if (f3 != null) { f3.close(); }\n    if (f2 != null) { f2.close(); }\n    if (f1 != null) { f1.close(); }\n}\n```\n\n### 6. Avoid Reading Large Files Entirely\n\n```hemlock\n// Bad for large files\nlet f = open(\"huge.log\", \"r\");\nlet content = f.read();  // Loads entire file into memory\nf.close();\n\n// Good - process in chunks\nlet f = open(\"huge.log\", \"r\");\ntry {\n    while (true) {\n        let chunk = f.read(4096);\n        if (chunk == \"\") { break; }\n        process_chunk(chunk);\n    }\n} finally {\n    f.close();\n}\n```\n\n## Summary\n\nHemlock's File I/O API provides:\n\n-  Simple, explicit file operations\n-  Text and binary support\n-  Random access with seek/tell\n-  Clear error messages with context\n-  Idempotent close operation\n\nRemember:\n- Always close files manually\n- Use try/finally for resource safety\n- Choose appropriate open modes\n- Handle errors gracefully\n- Process large files in chunks\n"}, "Advanced Topics  Signals": {"id": "advanced-signals", "content": "# Signal Handling in Hemlock\n\nHemlock provides **POSIX signal handling** for managing system signals like SIGINT (Ctrl+C), SIGTERM, and custom signals. This enables low-level process control and inter-process communication.\n\n## Table of Contents\n\n- [Overview](#overview)\n- [Signal API](#signal-api)\n- [Signal Constants](#signal-constants)\n- [Basic Signal Handling](#basic-signal-handling)\n- [Advanced Patterns](#advanced-patterns)\n- [Signal Handler Behavior](#signal-handler-behavior)\n- [Safety Considerations](#safety-considerations)\n- [Common Use Cases](#common-use-cases)\n- [Complete Examples](#complete-examples)\n\n## Overview\n\nSignal handling allows programs to:\n- Respond to user interrupts (Ctrl+C, Ctrl+Z)\n- Implement graceful shutdown\n- Handle termination requests\n- Use custom signals for inter-process communication\n- Create alarm/timer mechanisms\n\n**Important:** Signal handling is **inherently unsafe** in Hemlock's philosophy. Handlers can be called at any time, interrupting normal execution. The user is responsible for proper synchronization.\n\n## Signal API\n\n### signal(signum, handler_fn)\n\nRegister a signal handler function.\n\n**Parameters:**\n- `signum` (i32) - Signal number (constant like SIGINT, SIGTERM)\n- `handler_fn` (function or null) - Function to call when signal is received, or `null` to reset to default\n\n**Returns:** The previous handler function (or `null` if none)\n\n**Example:**\n```hemlock\nfn my_handler(sig) {\n    print(\"Caught signal: \" + typeof(sig));\n}\n\nlet old_handler = signal(SIGINT, my_handler);\n```\n\n**Resetting to default:**\n```hemlock\nsignal(SIGINT, null);  // Reset SIGINT to default behavior\n```\n\n### raise(signum)\n\nSend a signal to the current process.\n\n**Parameters:**\n- `signum` (i32) - Signal number to send\n\n**Returns:** `null`\n\n**Example:**\n```hemlock\nraise(SIGUSR1);  // Trigger SIGUSR1 handler\n```\n\n## Signal Constants\n\nHemlock provides standard POSIX signal constants as i32 values.\n\n### Interrupt & Termination\n\n| Constant | Value | Description | Common Trigger |\n|----------|-------|-------------|----------------|\n| `SIGINT` | 2 | Interrupt from keyboard | Ctrl+C |\n| `SIGTERM` | 15 | Termination request | `kill` command |\n| `SIGQUIT` | 3 | Quit from keyboard | Ctrl+\\ |\n| `SIGHUP` | 1 | Hangup detected | Terminal closed |\n| `SIGABRT` | 6 | Abort signal | `abort()` function |\n\n**Examples:**\n```hemlock\nsignal(SIGINT, handle_interrupt);   // Ctrl+C\nsignal(SIGTERM, handle_terminate);  // kill command\nsignal(SIGHUP, handle_hangup);      // Terminal closes\n```\n\n### User-Defined Signals\n\n| Constant | Value | Description | Use Case |\n|----------|-------|-------------|----------|\n| `SIGUSR1` | 10 | User-defined signal 1 | Custom IPC |\n| `SIGUSR2` | 12 | User-defined signal 2 | Custom IPC |\n\n**Examples:**\n```hemlock\n// Use for custom communication\nsignal(SIGUSR1, reload_config);\nsignal(SIGUSR2, rotate_logs);\n```\n\n### Process Control\n\n| Constant | Value | Description | Notes |\n|----------|-------|-------------|-------|\n| `SIGALRM` | 14 | Alarm clock timer | After `alarm()` |\n| `SIGCHLD` | 17 | Child process status change | Process management |\n| `SIGCONT` | 18 | Continue if stopped | Resume after SIGSTOP |\n| `SIGSTOP` | 19 | Stop process | **Cannot be caught** |\n| `SIGTSTP` | 20 | Terminal stop | Ctrl+Z |\n\n**Examples:**\n```hemlock\nsignal(SIGALRM, handle_timeout);\nsignal(SIGCHLD, handle_child_exit);\n```\n\n### I/O Signals\n\n| Constant | Value | Description | When Sent |\n|----------|-------|-------------|-----------|\n| `SIGPIPE` | 13 | Broken pipe | Write to closed pipe |\n| `SIGTTIN` | 21 | Background read from terminal | BG process reads TTY |\n| `SIGTTOU` | 22 | Background write to terminal | BG process writes TTY |\n\n**Examples:**\n```hemlock\nsignal(SIGPIPE, handle_broken_pipe);\n```\n\n## Basic Signal Handling\n\n### Catching Ctrl+C\n\n```hemlock\nlet interrupted = false;\n\nfn handle_interrupt(sig) {\n    print(\"Caught SIGINT!\");\n    interrupted = true;\n}\n\nsignal(SIGINT, handle_interrupt);\n\n// Program continues running...\n// User presses Ctrl+C -> handle_interrupt() is called\n\nwhile (!interrupted) {\n    // Do work...\n}\n\nprint(\"Exiting due to interrupt\");\n```\n\n### Handler Function Signature\n\nSignal handlers receive one argument: the signal number (i32)\n\n```hemlock\nfn my_handler(signum) {\n    print(\"Received signal: \" + typeof(signum));\n    // signum contains the signal number (e.g., 2 for SIGINT)\n\n    if (signum == SIGINT) {\n        print(\"This is SIGINT\");\n    }\n}\n\nsignal(SIGINT, my_handler);\nsignal(SIGTERM, my_handler);  // Same handler for multiple signals\n```\n\n### Multiple Signal Handlers\n\nDifferent handlers for different signals:\n\n```hemlock\nfn handle_int(sig) {\n    print(\"SIGINT received\");\n}\n\nfn handle_term(sig) {\n    print(\"SIGTERM received\");\n}\n\nfn handle_usr1(sig) {\n    print(\"SIGUSR1 received\");\n}\n\nsignal(SIGINT, handle_int);\nsignal(SIGTERM, handle_term);\nsignal(SIGUSR1, handle_usr1);\n```\n\n### Resetting to Default Behavior\n\nPass `null` as the handler to reset to default behavior:\n\n```hemlock\n// Register custom handler\nsignal(SIGINT, my_handler);\n\n// Later, reset to default (terminate on SIGINT)\nsignal(SIGINT, null);\n```\n\n### Raising Signals Manually\n\nSend signals to your own process:\n\n```hemlock\nlet count = 0;\n\nfn increment(sig) {\n    count = count + 1;\n}\n\nsignal(SIGUSR1, increment);\n\n// Trigger handler manually\nraise(SIGUSR1);\nraise(SIGUSR1);\n\nprint(count);  // 2\n```\n\n## Advanced Patterns\n\n### Graceful Shutdown Pattern\n\nCommon pattern for cleanup on termination:\n\n```hemlock\nlet should_exit = false;\n\nfn handle_shutdown(sig) {\n    print(\"Shutting down gracefully...\");\n    should_exit = true;\n}\n\nsignal(SIGINT, handle_shutdown);\nsignal(SIGTERM, handle_shutdown);\n\n// Main loop\nwhile (!should_exit) {\n    // Do work...\n    // Check should_exit flag periodically\n}\n\nprint(\"Cleanup complete\");\n```\n\n### Signal Counter\n\nTrack number of signals received:\n\n```hemlock\nlet signal_count = 0;\n\nfn count_signals(sig) {\n    signal_count = signal_count + 1;\n    print(\"Received \" + typeof(signal_count) + \" signals\");\n}\n\nsignal(SIGUSR1, count_signals);\n\n// Later...\nprint(\"Total signals: \" + typeof(signal_count));\n```\n\n### Configuration Reload on Signal\n\n```hemlock\nlet config = load_config();\n\nfn reload_config(sig) {\n    print(\"Reloading configuration...\");\n    config = load_config();\n    print(\"Configuration reloaded\");\n}\n\nsignal(SIGHUP, reload_config);  // Reload on SIGHUP\n\n// Send SIGHUP to process to reload config\n// From shell: kill -HUP <pid>\n```\n\n### Timeout Using SIGALRM\n\n```hemlock\nlet timed_out = false;\n\nfn handle_alarm(sig) {\n    print(\"Timeout!\");\n    timed_out = true;\n}\n\nsignal(SIGALRM, handle_alarm);\n\n// Set alarm (not yet implemented in Hemlock, example only)\n// alarm(5);  // 5 second timeout\n\nwhile (!timed_out) {\n    // Do work with timeout\n}\n```\n\n### Signal-Based State Machine\n\n```hemlock\nlet state = 0;\n\nfn next_state(sig) {\n    state = (state + 1) % 3;\n    print(\"State: \" + typeof(state));\n}\n\nfn prev_state(sig) {\n    state = (state - 1 + 3) % 3;\n    print(\"State: \" + typeof(state));\n}\n\nsignal(SIGUSR1, next_state);  // Advance state\nsignal(SIGUSR2, prev_state);  // Go back\n\n// Control state machine:\n// kill -USR1 <pid>  # Next state\n// kill -USR2 <pid>  # Previous state\n```\n\n## Signal Handler Behavior\n\n### Important Notes\n\n**Handler Execution:**\n- Handlers are called **synchronously** when the signal is received\n- Handlers execute in the current process context\n- Signal handlers share the closure environment of the function they're defined in\n- Handlers can access and modify outer scope variables (like globals or captured variables)\n\n**Best Practices:**\n- Keep handlers simple and quick - avoid long-running operations\n- Set flags rather than performing complex logic\n- Avoid calling functions that might take locks\n- Be aware that handlers can interrupt any operation\n\n### What Signals Can Be Caught\n\n**Can catch and handle:**\n- SIGINT, SIGTERM, SIGUSR1, SIGUSR2, SIGHUP, SIGQUIT\n- SIGALRM, SIGCHLD, SIGCONT, SIGTSTP\n- SIGPIPE, SIGTTIN, SIGTTOU\n- SIGABRT (but program will abort after handler returns)\n\n**Cannot catch:**\n- `SIGKILL` (9) - Always terminates process\n- `SIGSTOP` (19) - Always stops process\n\n**System-dependent:**\n- Some signals have default behaviors that may differ by system\n- Check your platform's signal documentation for specifics\n\n### Handler Limitations\n\n```hemlock\nfn complex_handler(sig) {\n    // Avoid these in signal handlers:\n\n    //  Long-running operations\n    // process_large_file();\n\n    //  Blocking I/O\n    // let f = open(\"log.txt\", \"a\");\n    // f.write(\"Signal received\\n\");\n\n    //  Complex state changes\n    // rebuild_entire_data_structure();\n\n    //  Simple flag setting is safe\n    let should_stop = true;\n\n    //  Simple counter updates are usually safe\n    let signal_count = signal_count + 1;\n}\n```\n\n## Safety Considerations\n\nSignal handling is **inherently unsafe** in Hemlock's philosophy.\n\n### Race Conditions\n\nHandlers can be called at any time, interrupting normal execution:\n\n```hemlock\nlet counter = 0;\n\nfn increment(sig) {\n    counter = counter + 1;  // Race condition if called during counter update\n}\n\nsignal(SIGUSR1, increment);\n\n// Main code also modifies counter\ncounter = counter + 1;  // Could be interrupted by signal handler\n```\n\n**Problem:** If signal arrives while main code is updating `counter`, the result is unpredictable.\n\n### Async-Signal-Safety\n\nHemlock does **not** guarantee async-signal-safety:\n- Handlers can call any Hemlock code (unlike C's restricted async-signal-safe functions)\n- This provides flexibility but requires user caution\n- Race conditions are possible if handler modifies shared state\n\n### Best Practices for Safe Signal Handling\n\n**1. Use Atomic Flags**\n\nSimple boolean assignments are generally safe:\n\n```hemlock\nlet should_exit = false;\n\nfn handler(sig) {\n    should_exit = true;  // Simple assignment is safe\n}\n\nsignal(SIGINT, handler);\n\nwhile (!should_exit) {\n    // work...\n}\n```\n\n**2. Minimize Shared State**\n\n```hemlock\nlet interrupt_count = 0;\n\nfn handler(sig) {\n    // Only modify this one variable\n    interrupt_count = interrupt_count + 1;\n}\n```\n\n**3. Defer Complex Operations**\n\n```hemlock\nlet pending_reload = false;\n\nfn signal_reload(sig) {\n    pending_reload = true;  // Just set flag\n}\n\nsignal(SIGHUP, signal_reload);\n\n// In main loop:\nwhile (true) {\n    if (pending_reload) {\n        reload_config();  // Do complex work here\n        pending_reload = false;\n    }\n\n    // Normal work...\n}\n```\n\n**4. Avoid Re-entrancy Issues**\n\n```hemlock\nlet in_critical_section = false;\nlet data = [];\n\nfn careful_handler(sig) {\n    if (in_critical_section) {\n        // Don't modify data while main code is using it\n        return;\n    }\n    // Safe to proceed\n}\n```\n\n## Common Use Cases\n\n### 1. Graceful Server Shutdown\n\n```hemlock\nlet running = true;\n\nfn shutdown(sig) {\n    print(\"Shutdown signal received\");\n    running = false;\n}\n\nsignal(SIGINT, shutdown);\nsignal(SIGTERM, shutdown);\n\n// Server main loop\nwhile (running) {\n    handle_client_request();\n}\n\ncleanup_resources();\nprint(\"Server stopped\");\n```\n\n### 2. Configuration Reload (Without Restart)\n\n```hemlock\nlet config = load_config(\"app.conf\");\nlet reload_needed = false;\n\nfn trigger_reload(sig) {\n    reload_needed = true;\n}\n\nsignal(SIGHUP, trigger_reload);\n\nwhile (true) {\n    if (reload_needed) {\n        print(\"Reloading configuration...\");\n        config = load_config(\"app.conf\");\n        reload_needed = false;\n    }\n\n    // Use config...\n}\n```\n\n### 3. Log Rotation\n\n```hemlock\nlet log_file = open(\"app.log\", \"a\");\nlet rotate_needed = false;\n\nfn trigger_rotate(sig) {\n    rotate_needed = true;\n}\n\nsignal(SIGUSR1, trigger_rotate);\n\nwhile (true) {\n    if (rotate_needed) {\n        log_file.close();\n        // Rename old log, open new one\n        exec(\"mv app.log app.log.old\");\n        log_file = open(\"app.log\", \"a\");\n        rotate_needed = false;\n    }\n\n    // Normal logging...\n    log_file.write(\"Log entry\\n\");\n}\n```\n\n### 4. Status Reporting\n\n```hemlock\nlet requests_handled = 0;\n\nfn report_status(sig) {\n    print(\"Status: \" + typeof(requests_handled) + \" requests handled\");\n}\n\nsignal(SIGUSR1, report_status);\n\nwhile (true) {\n    handle_request();\n    requests_handled = requests_handled + 1;\n}\n\n// From shell: kill -USR1 <pid>\n```\n\n### 5. Debug Mode Toggle\n\n```hemlock\nlet debug_mode = false;\n\nfn toggle_debug(sig) {\n    debug_mode = !debug_mode;\n    if (debug_mode) {\n        print(\"Debug mode: ON\");\n    } else {\n        print(\"Debug mode: OFF\");\n    }\n}\n\nsignal(SIGUSR2, toggle_debug);\n\n// From shell: kill -USR2 <pid> to toggle\n```\n\n## Complete Examples\n\n### Example 1: Interrupt Handler with Cleanup\n\n```hemlock\nlet running = true;\nlet signal_count = 0;\n\nfn handle_signal(signum) {\n    signal_count = signal_count + 1;\n\n    if (signum == SIGINT) {\n        print(\"Interrupt detected (Ctrl+C)\");\n        running = false;\n    }\n\n    if (signum == SIGUSR1) {\n        print(\"User signal 1 received\");\n    }\n}\n\n// Register handlers\nsignal(SIGINT, handle_signal);\nsignal(SIGUSR1, handle_signal);\n\n// Simulate some work\nlet i = 0;\nwhile (running && i < 100) {\n    print(\"Working... \" + typeof(i));\n\n    // Trigger SIGUSR1 every 10 iterations\n    if (i == 10 || i == 20) {\n        raise(SIGUSR1);\n    }\n\n    i = i + 1;\n}\n\nprint(\"Total signals received: \" + typeof(signal_count));\n```\n\n### Example 2: Multi-Signal State Machine\n\n```hemlock\nlet state = \"idle\";\nlet request_count = 0;\n\nfn start_processing(sig) {\n    state = \"processing\";\n    print(\"State: \" + state);\n}\n\nfn stop_processing(sig) {\n    state = \"idle\";\n    print(\"State: \" + state);\n}\n\nfn report_stats(sig) {\n    print(\"State: \" + state);\n    print(\"Requests: \" + typeof(request_count));\n}\n\nsignal(SIGUSR1, start_processing);\nsignal(SIGUSR2, stop_processing);\nsignal(SIGHUP, report_stats);\n\nwhile (true) {\n    if (state == \"processing\") {\n        // Do work\n        request_count = request_count + 1;\n    }\n\n    // Check every iteration...\n}\n```\n\n### Example 3: Worker Pool Controller\n\n```hemlock\nlet worker_count = 4;\nlet should_exit = false;\n\nfn increase_workers(sig) {\n    worker_count = worker_count + 1;\n    print(\"Workers: \" + typeof(worker_count));\n}\n\nfn decrease_workers(sig) {\n    if (worker_count > 1) {\n        worker_count = worker_count - 1;\n    }\n    print(\"Workers: \" + typeof(worker_count));\n}\n\nfn shutdown(sig) {\n    print(\"Shutting down...\");\n    should_exit = true;\n}\n\nsignal(SIGUSR1, increase_workers);\nsignal(SIGUSR2, decrease_workers);\nsignal(SIGINT, shutdown);\nsignal(SIGTERM, shutdown);\n\n// Main loop adjusts worker pool based on worker_count\nwhile (!should_exit) {\n    // Manage workers based on worker_count\n    // ...\n}\n```\n\n### Example 4: Timeout Pattern\n\n```hemlock\nlet operation_complete = false;\nlet timed_out = false;\n\nfn timeout_handler(sig) {\n    timed_out = true;\n}\n\nsignal(SIGALRM, timeout_handler);\n\n// Start long operation\nasync fn long_operation() {\n    // ... work\n    operation_complete = true;\n}\n\nlet task = spawn(long_operation);\n\n// Wait with timeout (manual check)\nlet elapsed = 0;\nwhile (!operation_complete && elapsed < 1000) {\n    // Sleep or check\n    elapsed = elapsed + 1;\n}\n\nif (!operation_complete) {\n    print(\"Operation timed out\");\n    detach(task);  // Give up waiting\n} else {\n    join(task);\n    print(\"Operation completed\");\n}\n```\n\n## Debugging Signal Handlers\n\n### Add Diagnostic Prints\n\n```hemlock\nfn debug_handler(sig) {\n    print(\"Handler called for signal: \" + typeof(sig));\n    print(\"Stack: (not yet available)\");\n\n    // Your handler logic...\n}\n\nsignal(SIGINT, debug_handler);\n```\n\n### Count Signal Calls\n\n```hemlock\nlet handler_calls = 0;\n\nfn counting_handler(sig) {\n    handler_calls = handler_calls + 1;\n    print(\"Handler call #\" + typeof(handler_calls));\n\n    // Your handler logic...\n}\n```\n\n### Test with raise()\n\n```hemlock\nfn test_handler(sig) {\n    print(\"Test signal received: \" + typeof(sig));\n}\n\nsignal(SIGUSR1, test_handler);\n\n// Test by manually raising\nraise(SIGUSR1);\nprint(\"Handler should have been called\");\n```\n\n## Summary\n\nHemlock's signal handling provides:\n\n-  POSIX signal handling for low-level process control\n-  15 standard signal constants\n-  Simple signal() and raise() API\n-  Flexible handler functions with closure support\n-  Multiple signals can share handlers\n\nRemember:\n- Signal handling is inherently unsafe - use with caution\n- Keep handlers simple and fast\n- Use flags for state changes, not complex operations\n- Handlers can interrupt execution at any time\n- Cannot catch SIGKILL or SIGSTOP\n- Test handlers thoroughly with raise()\n\nCommon patterns:\n- Graceful shutdown (SIGINT, SIGTERM)\n- Configuration reload (SIGHUP)\n- Log rotation (SIGUSR1)\n- Status reporting (SIGUSR1/SIGUSR2)\n- Debug mode toggle (SIGUSR2)\n"}, "API Reference  Array Api": {"id": "reference-array-api", "content": "# Array API Reference\n\nComplete reference for Hemlock's array type and all 15 array methods.\n\n---\n\n## Overview\n\nArrays in Hemlock are **dynamic, heap-allocated** sequences that can hold mixed types. They provide comprehensive methods for data manipulation and processing.\n\n**Key Features:**\n- Dynamic sizing (automatic growth)\n- Zero-indexed\n- Mixed types allowed\n- 15 built-in methods\n- Heap-allocated with capacity tracking\n\n---\n\n## Array Type\n\n**Type:** `array`\n\n**Properties:**\n- `.length` - Number of elements (i32)\n\n**Literal Syntax:** Square brackets `[elem1, elem2, ...]`\n\n**Examples:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr.length);     // 5\n\n// Mixed types\nlet mixed = [1, \"hello\", true, null];\nprint(mixed.length);   // 4\n\n// Empty array\nlet empty = [];\nprint(empty.length);   // 0\n```\n\n---\n\n## Indexing\n\nArrays support zero-based indexing using `[]`:\n\n**Read Access:**\n```hemlock\nlet arr = [10, 20, 30];\nprint(arr[0]);         // 10\nprint(arr[1]);         // 20\nprint(arr[2]);         // 30\n```\n\n**Write Access:**\n```hemlock\nlet arr = [10, 20, 30];\narr[0] = 99;\narr[1] = 88;\nprint(arr);            // [99, 88, 30]\n```\n\n**Note:** Direct indexing has no bounds checking. Use methods for safety.\n\n---\n\n## Array Properties\n\n### .length\n\nGet the number of elements in the array.\n\n**Type:** `i32`\n\n**Examples:**\n```hemlock\nlet arr = [1, 2, 3];\nprint(arr.length);     // 3\n\nlet empty = [];\nprint(empty.length);   // 0\n\n// Length changes dynamically\narr.push(4);\nprint(arr.length);     // 4\n\narr.pop();\nprint(arr.length);     // 3\n```\n\n---\n\n## Array Methods\n\n### Stack Operations\n\n#### push\n\nAdd element to end of array.\n\n**Signature:**\n```hemlock\narray.push(value: any): null\n```\n\n**Parameters:**\n- `value` - Element to add\n\n**Returns:** `null`\n\n**Mutates:** Yes (modifies array in place)\n\n**Examples:**\n```hemlock\nlet arr = [1, 2, 3];\narr.push(4);           // [1, 2, 3, 4]\narr.push(5);           // [1, 2, 3, 4, 5]\narr.push(\"hello\");     // [1, 2, 3, 4, 5, \"hello\"]\n```\n\n---\n\n#### pop\n\nRemove and return last element.\n\n**Signature:**\n```hemlock\narray.pop(): any\n```\n\n**Returns:** Last element (removed from array)\n\n**Mutates:** Yes (modifies array in place)\n\n**Examples:**\n```hemlock\nlet arr = [1, 2, 3];\nlet last = arr.pop();  // 3\nprint(arr);            // [1, 2]\n\nlet last2 = arr.pop(); // 2\nprint(arr);            // [1]\n```\n\n**Error:** Runtime error if array is empty.\n\n---\n\n### Queue Operations\n\n#### shift\n\nRemove and return first element.\n\n**Signature:**\n```hemlock\narray.shift(): any\n```\n\n**Returns:** First element (removed from array)\n\n**Mutates:** Yes (modifies array in place)\n\n**Examples:**\n```hemlock\nlet arr = [1, 2, 3];\nlet first = arr.shift();  // 1\nprint(arr);               // [2, 3]\n\nlet first2 = arr.shift(); // 2\nprint(arr);               // [3]\n```\n\n**Error:** Runtime error if array is empty.\n\n---\n\n#### unshift\n\nAdd element to beginning of array.\n\n**Signature:**\n```hemlock\narray.unshift(value: any): null\n```\n\n**Parameters:**\n- `value` - Element to add\n\n**Returns:** `null`\n\n**Mutates:** Yes (modifies array in place)\n\n**Examples:**\n```hemlock\nlet arr = [2, 3];\narr.unshift(1);        // [1, 2, 3]\narr.unshift(0);        // [0, 1, 2, 3]\n```\n\n---\n\n### Insertion & Removal\n\n#### insert\n\nInsert element at specific index.\n\n**Signature:**\n```hemlock\narray.insert(index: i32, value: any): null\n```\n\n**Parameters:**\n- `index` - Position to insert at (0-based)\n- `value` - Element to insert\n\n**Returns:** `null`\n\n**Mutates:** Yes (modifies array in place)\n\n**Examples:**\n```hemlock\nlet arr = [1, 2, 4, 5];\narr.insert(2, 3);      // [1, 2, 3, 4, 5]\n\nlet arr2 = [1, 3];\narr2.insert(1, 2);     // [1, 2, 3]\n\n// Insert at end\narr2.insert(arr2.length, 4);  // [1, 2, 3, 4]\n```\n\n**Behavior:** Shifts elements at and after index to the right.\n\n---\n\n#### remove\n\nRemove and return element at index.\n\n**Signature:**\n```hemlock\narray.remove(index: i32): any\n```\n\n**Parameters:**\n- `index` - Position to remove from (0-based)\n\n**Returns:** Removed element\n\n**Mutates:** Yes (modifies array in place)\n\n**Examples:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet removed = arr.remove(0);  // 1\nprint(arr);                   // [2, 3, 4, 5]\n\nlet removed2 = arr.remove(2); // 4\nprint(arr);                   // [2, 3, 5]\n```\n\n**Behavior:** Shifts elements after index to the left.\n\n**Error:** Runtime error if index out of bounds.\n\n---\n\n### Search & Find\n\n#### find\n\nFind first occurrence of value.\n\n**Signature:**\n```hemlock\narray.find(value: any): i32\n```\n\n**Parameters:**\n- `value` - Value to search for\n\n**Returns:** Index of first occurrence, or `-1` if not found\n\n**Examples:**\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet idx = arr.find(30);      // 2\nlet idx2 = arr.find(99);     // -1 (not found)\n\n// Find first duplicate\nlet arr2 = [1, 2, 3, 2, 4];\nlet idx3 = arr2.find(2);     // 1 (first occurrence)\n```\n\n**Comparison:** Uses value equality for primitives and strings.\n\n---\n\n#### contains\n\nCheck if array contains value.\n\n**Signature:**\n```hemlock\narray.contains(value: any): bool\n```\n\n**Parameters:**\n- `value` - Value to search for\n\n**Returns:** `true` if found, `false` otherwise\n\n**Examples:**\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet has = arr.contains(20);  // true\nlet has2 = arr.contains(99); // false\n\n// Works with strings\nlet words = [\"hello\", \"world\"];\nlet has3 = words.contains(\"hello\");  // true\n```\n\n---\n\n### Slicing & Extraction\n\n#### slice\n\nExtract subarray by range (end exclusive).\n\n**Signature:**\n```hemlock\narray.slice(start: i32, end: i32): array\n```\n\n**Parameters:**\n- `start` - Starting index (0-based, inclusive)\n- `end` - Ending index (exclusive)\n\n**Returns:** New array with elements from [start, end)\n\n**Mutates:** No (returns new array)\n\n**Examples:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet sub = arr.slice(1, 4);   // [2, 3, 4]\nlet first_three = arr.slice(0, 3);  // [1, 2, 3]\nlet last_two = arr.slice(3, 5);     // [4, 5]\n\n// Empty slice\nlet empty = arr.slice(2, 2); // []\n```\n\n---\n\n#### first\n\nGet first element without removing.\n\n**Signature:**\n```hemlock\narray.first(): any\n```\n\n**Returns:** First element\n\n**Mutates:** No\n\n**Examples:**\n```hemlock\nlet arr = [1, 2, 3];\nlet f = arr.first();         // 1\nprint(arr);                  // [1, 2, 3] (unchanged)\n```\n\n**Error:** Runtime error if array is empty.\n\n---\n\n#### last\n\nGet last element without removing.\n\n**Signature:**\n```hemlock\narray.last(): any\n```\n\n**Returns:** Last element\n\n**Mutates:** No\n\n**Examples:**\n```hemlock\nlet arr = [1, 2, 3];\nlet l = arr.last();          // 3\nprint(arr);                  // [1, 2, 3] (unchanged)\n```\n\n**Error:** Runtime error if array is empty.\n\n---\n\n### Array Manipulation\n\n#### reverse\n\nReverse array in place.\n\n**Signature:**\n```hemlock\narray.reverse(): null\n```\n\n**Returns:** `null`\n\n**Mutates:** Yes (modifies array in place)\n\n**Examples:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.reverse();               // [5, 4, 3, 2, 1]\nprint(arr);                  // [5, 4, 3, 2, 1]\n\nlet words = [\"hello\", \"world\"];\nwords.reverse();             // [\"world\", \"hello\"]\n```\n\n---\n\n#### clear\n\nRemove all elements from array.\n\n**Signature:**\n```hemlock\narray.clear(): null\n```\n\n**Returns:** `null`\n\n**Mutates:** Yes (modifies array in place)\n\n**Examples:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.clear();\nprint(arr);                  // []\nprint(arr.length);           // 0\n```\n\n---\n\n### Array Combination\n\n#### concat\n\nConcatenate with another array.\n\n**Signature:**\n```hemlock\narray.concat(other: array): array\n```\n\n**Parameters:**\n- `other` - Array to concatenate\n\n**Returns:** New array with elements from both arrays\n\n**Mutates:** No (returns new array)\n\n**Examples:**\n```hemlock\nlet a = [1, 2, 3];\nlet b = [4, 5, 6];\nlet combined = a.concat(b);  // [1, 2, 3, 4, 5, 6]\nprint(a);                    // [1, 2, 3] (unchanged)\nprint(b);                    // [4, 5, 6] (unchanged)\n\n// Chain concatenations\nlet c = [7, 8];\nlet all = a.concat(b).concat(c);  // [1, 2, 3, 4, 5, 6, 7, 8]\n```\n\n---\n\n### String Conversion\n\n#### join\n\nJoin elements into string with delimiter.\n\n**Signature:**\n```hemlock\narray.join(delimiter: string): string\n```\n\n**Parameters:**\n- `delimiter` - String to place between elements\n\n**Returns:** String with all elements joined\n\n**Examples:**\n```hemlock\nlet words = [\"hello\", \"world\", \"foo\"];\nlet joined = words.join(\" \");  // \"hello world foo\"\n\nlet numbers = [1, 2, 3];\nlet csv = numbers.join(\",\");   // \"1,2,3\"\n\n// Works with mixed types\nlet mixed = [1, \"hello\", true, null];\nprint(mixed.join(\" | \"));  // \"1 | hello | true | null\"\n\n// Empty delimiter\nlet arr = [\"a\", \"b\", \"c\"];\nlet s = arr.join(\"\");          // \"abc\"\n```\n\n**Behavior:** Automatically converts all elements to strings.\n\n---\n\n## Method Chaining\n\nArray methods can be chained for concise operations:\n\n**Examples:**\n```hemlock\n// Chain slice and join\nlet result = [\"apple\", \"banana\", \"cherry\", \"date\"]\n    .slice(0, 2)\n    .join(\" and \");  // \"apple and banana\"\n\n// Chain concat and slice\nlet combined = [1, 2, 3]\n    .concat([4, 5, 6])\n    .slice(2, 5);    // [3, 4, 5]\n\n// Complex chaining\nlet words = [\"hello\", \"world\", \"foo\", \"bar\"];\nlet result2 = words\n    .slice(0, 3)\n    .concat([\"baz\"])\n    .join(\"-\");      // \"hello-world-foo-baz\"\n```\n\n---\n\n## Complete Method Summary\n\n### Mutating Methods\n\nMethods that modify the array in place:\n\n| Method     | Signature                  | Returns   | Description                    |\n|------------|----------------------------|-----------|--------------------------------|\n| `push`     | `(value: any)`             | `null`    | Add to end                     |\n| `pop`      | `()`                       | `any`     | Remove from end                |\n| `shift`    | `()`                       | `any`     | Remove from start              |\n| `unshift`  | `(value: any)`             | `null`    | Add to start                   |\n| `insert`   | `(index: i32, value: any)` | `null`    | Insert at index                |\n| `remove`   | `(index: i32)`             | `any`     | Remove at index                |\n| `reverse`  | `()`                       | `null`    | Reverse in place               |\n| `clear`    | `()`                       | `null`    | Remove all elements            |\n\n### Non-Mutating Methods\n\nMethods that return new values without modifying the original:\n\n| Method     | Signature                  | Returns   | Description                    |\n|------------|----------------------------|-----------|--------------------------------|\n| `find`     | `(value: any)`             | `i32`     | Find first occurrence          |\n| `contains` | `(value: any)`             | `bool`    | Check if contains value        |\n| `slice`    | `(start: i32, end: i32)`   | `array`   | Extract subarray               |\n| `first`    | `()`                       | `any`     | Get first element              |\n| `last`     | `()`                       | `any`     | Get last element               |\n| `concat`   | `(other: array)`           | `array`   | Concatenate arrays             |\n| `join`     | `(delimiter: string)`      | `string`  | Join elements into string      |\n\n---\n\n## Usage Patterns\n\n### Stack Usage\n\n```hemlock\nlet stack = [];\n\n// Push elements\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\n// Pop elements\nwhile (stack.length > 0) {\n    let item = stack.pop();\n    print(item);  // 3, 2, 1\n}\n```\n\n### Queue Usage\n\n```hemlock\nlet queue = [];\n\n// Enqueue\nqueue.push(1);\nqueue.push(2);\nqueue.push(3);\n\n// Dequeue\nwhile (queue.length > 0) {\n    let item = queue.shift();\n    print(item);  // 1, 2, 3\n}\n```\n\n### Array Transformation\n\n```hemlock\n// Filter (manual)\nlet numbers = [1, 2, 3, 4, 5, 6];\nlet evens = [];\nlet i = 0;\nwhile (i < numbers.length) {\n    if (numbers[i] % 2 == 0) {\n        evens.push(numbers[i]);\n    }\n    i = i + 1;\n}\n\n// Map (manual)\nlet numbers2 = [1, 2, 3, 4, 5];\nlet doubled = [];\nlet j = 0;\nwhile (j < numbers2.length) {\n    doubled.push(numbers2[j] * 2);\n    j = j + 1;\n}\n```\n\n### Building Arrays\n\n```hemlock\nlet arr = [];\n\n// Build array with loop\nlet i = 0;\nwhile (i < 10) {\n    arr.push(i * 10);\n    i = i + 1;\n}\n\nprint(arr);  // [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]\n```\n\n---\n\n## Implementation Details\n\n**Capacity Management:**\n- Arrays automatically grow when needed\n- Capacity doubles when exceeded\n- No manual capacity control\n\n**Value Comparison:**\n- `find()` and `contains()` use value equality\n- Works correctly for primitives and strings\n- Objects/arrays compared by reference\n\n**Memory:**\n- Heap-allocated\n- No automatic freeing (manual memory management)\n- No bounds checking on direct index access\n\n---\n\n## See Also\n\n- [Type System](type-system.md) - Array type details\n- [String API](string-api.md) - String join() results\n- [Operators](operators.md) - Array indexing operator\n"}, "API Reference  Builtins": {"id": "reference-builtins", "content": "# Built-in Functions Reference\n\nComplete reference for all built-in functions and constants in Hemlock.\n\n---\n\n## Overview\n\nHemlock provides a set of built-in functions for I/O, type introspection, memory management, concurrency, and system interaction. All built-ins are available globally without imports.\n\n---\n\n## I/O Functions\n\n### print\n\nPrint values to stdout with newline.\n\n**Signature:**\n```hemlock\nprint(...values): null\n```\n\n**Parameters:**\n- `...values` - Any number of values to print\n\n**Returns:** `null`\n\n**Examples:**\n```hemlock\nprint(\"Hello, World!\");\nprint(42);\nprint(3.14);\nprint(true);\nprint([1, 2, 3]);\nprint({ x: 10, y: 20 });\n\n// Multiple values\nprint(\"x =\", 10, \"y =\", 20);\n```\n\n**Behavior:**\n- Converts all values to strings\n- Separates multiple values with spaces\n- Adds newline at end\n- Flushes stdout\n\n---\n\n## Type Introspection\n\n### typeof\n\nGet the type name of a value.\n\n**Signature:**\n```hemlock\ntypeof(value: any): string\n```\n\n**Parameters:**\n- `value` - Any value\n\n**Returns:** Type name as string\n\n**Examples:**\n```hemlock\nprint(typeof(42));              // \"i32\"\nprint(typeof(3.14));            // \"f64\"\nprint(typeof(\"hello\"));         // \"string\"\nprint(typeof('A'));             // \"rune\"\nprint(typeof(true));            // \"bool\"\nprint(typeof(null));            // \"null\"\nprint(typeof([1, 2, 3]));       // \"array\"\nprint(typeof({ x: 10 }));       // \"object\"\n\n// Typed objects\ndefine Person { name: string }\nlet p: Person = { name: \"Alice\" };\nprint(typeof(p));               // \"Person\"\n\n// Other types\nprint(typeof(alloc(10)));       // \"ptr\"\nprint(typeof(buffer(10)));      // \"buffer\"\nprint(typeof(open(\"file.txt\"))); // \"file\"\n```\n\n**Type Names:**\n- Primitives: `\"i8\"`, `\"i16\"`, `\"i32\"`, `\"i64\"`, `\"u8\"`, `\"u16\"`, `\"u32\"`, `\"u64\"`, `\"f32\"`, `\"f64\"`, `\"bool\"`, `\"string\"`, `\"rune\"`, `\"null\"`\n- Composites: `\"array\"`, `\"object\"`, `\"ptr\"`, `\"buffer\"`, `\"function\"`\n- Special: `\"file\"`, `\"task\"`, `\"channel\"`\n- Custom: User-defined type names from `define`\n\n**See Also:** [Type System](type-system.md)\n\n---\n\n## Command Execution\n\n### exec\n\nExecute shell command and capture output.\n\n**Signature:**\n```hemlock\nexec(command: string): object\n```\n\n**Parameters:**\n- `command` - Shell command to execute\n\n**Returns:** Object with fields:\n- `output` (string) - Command's stdout\n- `exit_code` (i32) - Exit status code (0 = success)\n\n**Examples:**\n```hemlock\nlet result = exec(\"echo hello\");\nprint(result.output);      // \"hello\\n\"\nprint(result.exit_code);   // 0\n\n// Check exit status\nlet r = exec(\"grep pattern file.txt\");\nif (r.exit_code == 0) {\n    print(\"Found:\", r.output);\n} else {\n    print(\"Pattern not found\");\n}\n\n// Process multi-line output\nlet r2 = exec(\"ls -la\");\nlet lines = r2.output.split(\"\\n\");\n```\n\n**Behavior:**\n- Executes command via `/bin/sh`\n- Captures stdout only (stderr goes to terminal)\n- Blocks until command completes\n- Returns empty string if no output\n\n**Error Handling:**\n```hemlock\ntry {\n    let r = exec(\"nonexistent_command\");\n} catch (e) {\n    print(\"Failed to execute:\", e);\n}\n```\n\n**Security Warning:**  Vulnerable to shell injection. Always validate/sanitize user input.\n\n**Limitations:**\n- No stderr capture\n- No streaming\n- No timeout\n- No signal handling\n\n---\n\n## Error Handling\n\n### throw\n\nThrow an exception.\n\n**Signature:**\n```hemlock\nthrow expression\n```\n\n**Parameters:**\n- `expression` - Value to throw (any type)\n\n**Returns:** Never returns (transfers control)\n\n**Examples:**\n```hemlock\nthrow \"error message\";\nthrow 404;\nthrow { code: 500, message: \"Internal error\" };\nthrow null;\n```\n\n**See Also:** try/catch/finally statements\n\n---\n\n### panic\n\nImmediately terminate program with error message (unrecoverable).\n\n**Signature:**\n```hemlock\npanic(message?: any): never\n```\n\n**Parameters:**\n- `message` (optional) - Error message to print\n\n**Returns:** Never returns (program exits)\n\n**Examples:**\n```hemlock\npanic();                          // Default: \"panic!\"\npanic(\"unreachable code reached\");\npanic(42);\n\n// Common use case\nfn process_state(state: i32): string {\n    if (state == 1) { return \"ready\"; }\n    if (state == 2) { return \"running\"; }\n    panic(\"invalid state: \" + typeof(state));\n}\n```\n\n**Behavior:**\n- Prints error to stderr: `panic: <message>`\n- Exits with code 1\n- **NOT catchable** with try/catch\n- Use for bugs and unrecoverable errors\n\n**Panic vs Throw:**\n- `panic()` - Unrecoverable error, exits immediately\n- `throw` - Recoverable error, can be caught\n\n---\n\n## Signal Handling\n\n### signal\n\nRegister or reset signal handler.\n\n**Signature:**\n```hemlock\nsignal(signum: i32, handler: function | null): function | null\n```\n\n**Parameters:**\n- `signum` - Signal number (use constants like `SIGINT`)\n- `handler` - Function to call when signal received, or `null` to reset to default\n\n**Returns:** Previous handler function, or `null`\n\n**Examples:**\n```hemlock\nfn handle_interrupt(sig) {\n    print(\"Caught SIGINT!\");\n}\n\nsignal(SIGINT, handle_interrupt);\n\n// Reset to default\nsignal(SIGINT, null);\n```\n\n**Handler Signature:**\n```hemlock\nfn handler(signum: i32) {\n    // signum contains the signal number\n}\n```\n\n**See Also:**\n- [Signal constants](#signal-constants)\n- `raise()`\n\n---\n\n### raise\n\nSend signal to current process.\n\n**Signature:**\n```hemlock\nraise(signum: i32): null\n```\n\n**Parameters:**\n- `signum` - Signal number to raise\n\n**Returns:** `null`\n\n**Examples:**\n```hemlock\nlet count = 0;\n\nfn increment(sig) {\n    count = count + 1;\n}\n\nsignal(SIGUSR1, increment);\n\nraise(SIGUSR1);\nraise(SIGUSR1);\nprint(count);  // 2\n```\n\n---\n\n## Global Variables\n\n### args\n\nCommand-line arguments array.\n\n**Type:** `array` of strings\n\n**Structure:**\n- `args[0]` - Script filename\n- `args[1..n]` - Command-line arguments\n\n**Examples:**\n```bash\n# Command: ./hemlock script.hml hello world\n```\n\n```hemlock\nprint(args[0]);        // \"script.hml\"\nprint(args.length);    // 3\nprint(args[1]);        // \"hello\"\nprint(args[2]);        // \"world\"\n\n// Iterate arguments\nlet i = 1;\nwhile (i < args.length) {\n    print(\"Argument\", i, \":\", args[i]);\n    i = i + 1;\n}\n```\n\n**REPL Behavior:** In the REPL, `args.length` is 0 (empty array)\n\n---\n\n## Signal Constants\n\nStandard POSIX signal constants (i32 values):\n\n### Interrupt & Termination\n\n| Constant   | Value | Description                            |\n|------------|-------|----------------------------------------|\n| `SIGINT`   | 2     | Interrupt from keyboard (Ctrl+C)       |\n| `SIGTERM`  | 15    | Termination request                    |\n| `SIGQUIT`  | 3     | Quit from keyboard (Ctrl+\\)            |\n| `SIGHUP`   | 1     | Hangup detected on controlling terminal|\n| `SIGABRT`  | 6     | Abort signal                           |\n\n### User-Defined\n\n| Constant   | Value | Description                |\n|------------|-------|----------------------------|\n| `SIGUSR1`  | 10    | User-defined signal 1      |\n| `SIGUSR2`  | 12    | User-defined signal 2      |\n\n### Process Control\n\n| Constant   | Value | Description                     |\n|------------|-------|---------------------------------|\n| `SIGALRM`  | 14    | Alarm clock timer               |\n| `SIGCHLD`  | 17    | Child process status change     |\n| `SIGCONT`  | 18    | Continue if stopped             |\n| `SIGSTOP`  | 19    | Stop process (cannot be caught) |\n| `SIGTSTP`  | 20    | Terminal stop (Ctrl+Z)          |\n\n### I/O\n\n| Constant   | Value | Description                        |\n|------------|-------|------------------------------------|\n| `SIGPIPE`  | 13    | Broken pipe                        |\n| `SIGTTIN`  | 21    | Background read from terminal      |\n| `SIGTTOU`  | 22    | Background write to terminal       |\n\n**Examples:**\n```hemlock\nfn handle_signal(sig) {\n    if (sig == SIGINT) {\n        print(\"Interrupt detected\");\n    }\n    if (sig == SIGTERM) {\n        print(\"Termination requested\");\n    }\n}\n\nsignal(SIGINT, handle_signal);\nsignal(SIGTERM, handle_signal);\n```\n\n**Note:** `SIGKILL` (9) and `SIGSTOP` (19) cannot be caught or ignored.\n\n---\n\n## Memory Management Functions\n\nSee [Memory API](memory-api.md) for complete reference:\n- `alloc(size)` - Allocate raw memory\n- `free(ptr)` - Free memory\n- `buffer(size)` - Allocate safe buffer\n- `memset(ptr, byte, size)` - Fill memory\n- `memcpy(dest, src, size)` - Copy memory\n- `realloc(ptr, new_size)` - Resize allocation\n\n---\n\n## File I/O Functions\n\nSee [File API](file-api.md) for complete reference:\n- `open(path, mode?)` - Open file\n\n---\n\n## Concurrency Functions\n\nSee [Concurrency API](concurrency-api.md) for complete reference:\n- `spawn(fn, args...)` - Spawn task\n- `join(task)` - Wait for task\n- `detach(task)` - Detach task\n- `channel(capacity)` - Create channel\n\n---\n\n## Summary Table\n\n### Functions\n\n| Function   | Category        | Returns      | Description                     |\n|------------|-----------------|--------------|----------------------------------|\n| `print`    | I/O             | `null`       | Print to stdout                  |\n| `typeof`   | Type            | `string`     | Get type name                    |\n| `exec`     | Command         | `object`     | Execute shell command            |\n| `panic`    | Error           | `never`      | Unrecoverable error (exits)      |\n| `signal`   | Signal          | `function?`  | Register signal handler          |\n| `raise`    | Signal          | `null`       | Send signal to process           |\n| `alloc`    | Memory          | `ptr`        | Allocate raw memory              |\n| `free`     | Memory          | `null`       | Free memory                      |\n| `buffer`   | Memory          | `buffer`     | Allocate safe buffer             |\n| `memset`   | Memory          | `null`       | Fill memory                      |\n| `memcpy`   | Memory          | `null`       | Copy memory                      |\n| `realloc`  | Memory          | `ptr`        | Resize allocation                |\n| `open`     | File I/O        | `file`       | Open file                        |\n| `spawn`    | Concurrency     | `task`       | Spawn concurrent task            |\n| `join`     | Concurrency     | `any`        | Wait for task result             |\n| `detach`   | Concurrency     | `null`       | Detach task                      |\n| `channel`  | Concurrency     | `channel`    | Create communication channel     |\n\n### Global Variables\n\n| Variable   | Type     | Description                       |\n|------------|----------|-----------------------------------|\n| `args`     | `array`  | Command-line arguments            |\n\n### Constants\n\n| Constant   | Type  | Category | Value | Description               |\n|------------|-------|----------|-------|---------------------------|\n| `SIGINT`   | `i32` | Signal   | 2     | Keyboard interrupt        |\n| `SIGTERM`  | `i32` | Signal   | 15    | Termination request       |\n| `SIGQUIT`  | `i32` | Signal   | 3     | Keyboard quit             |\n| `SIGHUP`   | `i32` | Signal   | 1     | Hangup                    |\n| `SIGABRT`  | `i32` | Signal   | 6     | Abort                     |\n| `SIGUSR1`  | `i32` | Signal   | 10    | User-defined 1            |\n| `SIGUSR2`  | `i32` | Signal   | 12    | User-defined 2            |\n| `SIGALRM`  | `i32` | Signal   | 14    | Alarm timer               |\n| `SIGCHLD`  | `i32` | Signal   | 17    | Child status change       |\n| `SIGCONT`  | `i32` | Signal   | 18    | Continue                  |\n| `SIGSTOP`  | `i32` | Signal   | 19    | Stop (uncatchable)        |\n| `SIGTSTP`  | `i32` | Signal   | 20    | Terminal stop             |\n| `SIGPIPE`  | `i32` | Signal   | 13    | Broken pipe               |\n| `SIGTTIN`  | `i32` | Signal   | 21    | Background terminal read  |\n| `SIGTTOU`  | `i32` | Signal   | 22    | Background terminal write |\n\n---\n\n## See Also\n\n- [Type System](type-system.md) - Types and conversions\n- [Memory API](memory-api.md) - Memory allocation functions\n- [File API](file-api.md) - File I/O functions\n- [Concurrency API](concurrency-api.md) - Async/concurrency functions\n- [String API](string-api.md) - String methods\n- [Array API](array-api.md) - Array methods\n"}, "API Reference  Concurrency Api": {"id": "reference-concurrency-api", "content": "# Concurrency API Reference\n\nComplete reference for Hemlock's async/concurrency system.\n\n---\n\n## Overview\n\nHemlock provides **structured concurrency** with true multi-threaded parallelism using POSIX threads (pthreads). Each spawned task runs on a separate OS thread, enabling actual parallel execution across multiple CPU cores.\n\n**Key Features:**\n- True multi-threaded parallelism (not green threads)\n- Async function syntax\n- Task spawning and joining\n- Thread-safe channels\n- Exception propagation\n\n**Threading Model:**\n-  Real OS threads (POSIX pthreads)\n-  True parallelism (multiple CPU cores)\n-  Kernel-scheduled (pre-emptive multitasking)\n-  Thread-safe synchronization (mutexes, condition variables)\n\n---\n\n## Async Functions\n\n### Async Function Declaration\n\nFunctions can be declared as `async` to indicate they're designed for concurrent execution.\n\n**Syntax:**\n```hemlock\nasync fn function_name(params): return_type {\n    // function body\n}\n```\n\n**Examples:**\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\nasync fn process_data(data: string) {\n    print(\"Processing:\", data);\n    return null;\n}\n```\n\n**Behavior:**\n- `async fn` declares an asynchronous function\n- Can be called synchronously (runs in current thread)\n- Can be spawned as concurrent task (runs on new thread)\n- When spawned, runs on its own OS thread\n\n**Note:** The `await` keyword is reserved for future use but not currently implemented.\n\n---\n\n## Task Management\n\n### spawn\n\nCreate and start a new concurrent task.\n\n**Signature:**\n```hemlock\nspawn(async_fn: function, ...args): task\n```\n\n**Parameters:**\n- `async_fn` - Async function to execute\n- `...args` - Arguments to pass to function\n\n**Returns:** Task handle\n\n**Examples:**\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Spawn single task\nlet t = spawn(compute, 1000);\nlet result = join(t);\nprint(result);\n\n// Spawn multiple tasks (run in parallel!)\nlet t1 = spawn(compute, 100);\nlet t2 = spawn(compute, 200);\nlet t3 = spawn(compute, 300);\n\n// All three are running simultaneously\nlet r1 = join(t1);\nlet r2 = join(t2);\nlet r3 = join(t3);\n```\n\n**Behavior:**\n- Creates new OS thread via `pthread_create()`\n- Starts executing function immediately\n- Returns task handle for later joining\n- Tasks run in parallel on separate CPU cores\n\n---\n\n### join\n\nWait for task completion and retrieve result.\n\n**Signature:**\n```hemlock\njoin(task: task): any\n```\n\n**Parameters:**\n- `task` - Task handle from `spawn()`\n\n**Returns:** Task's return value\n\n**Examples:**\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\nlet t = spawn(factorial, 10);\nlet result = join(t);  // Blocks until task completes\nprint(result);         // 3628800\n```\n\n**Behavior:**\n- Blocks current thread until task completes\n- Returns task's return value\n- Propagates exceptions thrown by task\n- Cleans up task resources after returning\n\n**Error Handling:**\n```hemlock\nasync fn risky_operation(should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Task failed!\";\n    }\n    return 42;\n}\n\nlet t = spawn(risky_operation, 1);\ntry {\n    let result = join(t);\n} catch (e) {\n    print(\"Caught:\", e);  // \"Caught: Task failed!\"\n}\n```\n\n---\n\n### detach\n\nDetach task (fire-and-forget execution).\n\n**Signature:**\n```hemlock\ndetach(task: task): null\n```\n\n**Parameters:**\n- `task` - Task handle from `spawn()`\n\n**Returns:** `null`\n\n**Examples:**\n```hemlock\nasync fn background_work() {\n    print(\"Working in background...\");\n    return null;\n}\n\nlet t = spawn(background_work);\ndetach(t);  // Task continues running independently\n\n// Cannot join detached task\n// join(t);  // ERROR\n```\n\n**Behavior:**\n- Task continues running independently\n- Cannot `join()` detached task\n- Thread is cleaned up by OS when task completes\n- Task struct currently leaks (~64-96 bytes)\n\n**Use Cases:**\n- Fire-and-forget background tasks\n- Logging/monitoring tasks\n- Tasks that don't need to return values\n\n---\n\n## Channels\n\nChannels provide thread-safe communication between tasks.\n\n### channel\n\nCreate a buffered channel.\n\n**Signature:**\n```hemlock\nchannel(capacity: i32): channel\n```\n\n**Parameters:**\n- `capacity` - Buffer size (number of values)\n\n**Returns:** Channel object\n\n**Examples:**\n```hemlock\nlet ch = channel(10);  // Buffered channel with capacity 10\nlet ch2 = channel(1);  // Minimal buffer (synchronous)\nlet ch3 = channel(100); // Large buffer\n```\n\n**Behavior:**\n- Creates thread-safe channel\n- Uses pthread mutexes for synchronization\n- Capacity is fixed at creation time\n\n---\n\n### Channel Methods\n\n#### send\n\nSend value to channel (blocks if full).\n\n**Signature:**\n```hemlock\nchannel.send(value: any): null\n```\n\n**Parameters:**\n- `value` - Value to send (any type)\n\n**Returns:** `null`\n\n**Examples:**\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nlet ch = channel(10);\nlet t = spawn(producer, ch, 5);\n```\n\n**Behavior:**\n- Sends value to channel\n- Blocks if channel is full\n- Thread-safe (uses mutex)\n- Returns after value is sent\n\n---\n\n#### recv\n\nReceive value from channel (blocks if empty).\n\n**Signature:**\n```hemlock\nchannel.recv(): any\n```\n\n**Returns:** Value from channel, or `null` if channel is closed and empty\n\n**Examples:**\n```hemlock\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\nlet ch = channel(10);\nlet t = spawn(consumer, ch, 5);\n```\n\n**Behavior:**\n- Receives value from channel\n- Blocks if channel is empty\n- Returns `null` if channel is closed and empty\n- Thread-safe (uses mutex)\n\n---\n\n#### close\n\nClose channel (no more sends allowed).\n\n**Signature:**\n```hemlock\nchannel.close(): null\n```\n\n**Returns:** `null`\n\n**Examples:**\n```hemlock\nasync fn producer(ch) {\n    ch.send(1);\n    ch.send(2);\n    ch.send(3);\n    ch.close();  // Signal no more values\n    return null;\n}\n\nasync fn consumer(ch) {\n    while (true) {\n        let val = ch.recv();\n        if (val == null) {\n            break;  // Channel closed\n        }\n        print(val);\n    }\n    return null;\n}\n```\n\n**Behavior:**\n- Closes channel\n- No more sends allowed\n- `recv()` returns `null` when channel is empty\n- Thread-safe\n\n---\n\n## Complete Concurrency Example\n\n### Producer-Consumer Pattern\n\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        print(\"Producing:\", i);\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        print(\"Consuming:\", val);\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Create channel\nlet ch = channel(10);\n\n// Spawn producer and consumer\nlet p = spawn(producer, ch, 5);\nlet c = spawn(consumer, ch, 5);\n\n// Wait for completion\njoin(p);\nlet total = join(c);\nprint(\"Total:\", total);  // 0+10+20+30+40 = 100\n```\n\n---\n\n## Parallel Computation\n\n### Multiple Tasks Example\n\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\n// Spawn multiple tasks (run in parallel!)\nlet t1 = spawn(factorial, 5);   // Thread 1\nlet t2 = spawn(factorial, 6);   // Thread 2\nlet t3 = spawn(factorial, 7);   // Thread 3\nlet t4 = spawn(factorial, 8);   // Thread 4\n\n// All four are computing simultaneously!\n\n// Wait for results\nlet f5 = join(t1);  // 120\nlet f6 = join(t2);  // 720\nlet f7 = join(t3);  // 5040\nlet f8 = join(t4);  // 40320\n\nprint(f5, f6, f7, f8);\n```\n\n---\n\n## Task Lifecycle\n\n### State Transitions\n\n1. **Created** - Task spawned but not yet running\n2. **Running** - Task executing on OS thread\n3. **Completed** - Task finished (result available)\n4. **Joined** - Result retrieved, resources cleaned up\n5. **Detached** - Task continues independently\n\n### Lifecycle Example\n\n```hemlock\nasync fn work(n: i32): i32 {\n    return n * 2;\n}\n\n// 1. Create task\nlet t = spawn(work, 21);  // State: Running\n\n// Task executes on separate thread...\n\n// 2. Join task\nlet result = join(t);     // State: Completed  Joined\nprint(result);            // 42\n\n// Task resources cleaned up after join\n```\n\n### Detached Lifecycle\n\n```hemlock\nasync fn background() {\n    print(\"Background task running\");\n    return null;\n}\n\n// 1. Create task\nlet t = spawn(background);  // State: Running\n\n// 2. Detach task\ndetach(t);                  // State: Detached\n\n// Task continues running independently\n// Resources cleaned up by OS when done\n```\n\n---\n\n## Error Handling\n\n### Exception Propagation\n\nExceptions thrown in tasks are propagated when joined:\n\n```hemlock\nasync fn risky_operation(should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Task failed!\";\n    }\n    return 42;\n}\n\n// Task that succeeds\nlet t1 = spawn(risky_operation, 0);\nlet result1 = join(t1);  // 42\n\n// Task that fails\nlet t2 = spawn(risky_operation, 1);\ntry {\n    let result2 = join(t2);\n} catch (e) {\n    print(\"Caught:\", e);  // \"Caught: Task failed!\"\n}\n```\n\n### Handling Multiple Tasks\n\n```hemlock\nasync fn work(id: i32, should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Task \" + typeof(id) + \" failed\";\n    }\n    return id * 10;\n}\n\nlet t1 = spawn(work, 1, 0);\nlet t2 = spawn(work, 2, 1);  // Will fail\nlet t3 = spawn(work, 3, 0);\n\n// Join with error handling\ntry {\n    let r1 = join(t1);  // OK\n    print(\"Task 1:\", r1);\n\n    let r2 = join(t2);  // Throws\n    print(\"Task 2:\", r2);  // Never reached\n} catch (e) {\n    print(\"Error:\", e);  // \"Error: Task 2 failed\"\n}\n\n// Can still join remaining task\nlet r3 = join(t3);\nprint(\"Task 3:\", r3);\n```\n\n---\n\n## Performance Characteristics\n\n### True Parallelism\n\n```hemlock\nasync fn cpu_intensive(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Sequential execution\nlet start = get_time();\nlet r1 = cpu_intensive(10000000);\nlet r2 = cpu_intensive(10000000);\nlet sequential_time = get_time() - start;\n\n// Parallel execution\nlet start2 = get_time();\nlet t1 = spawn(cpu_intensive, 10000000);\nlet t2 = spawn(cpu_intensive, 10000000);\njoin(t1);\njoin(t2);\nlet parallel_time = get_time() - start2;\n\n// parallel_time should be ~50% of sequential_time on multi-core systems\n```\n\n**Proven Characteristics:**\n- N tasks can utilize N CPU cores simultaneously\n- Stress tests show 8-9x CPU time vs wall time (proof of parallelism)\n- Thread overhead: ~8KB stack + pthread overhead per task\n- Blocking operations in one task don't block others\n\n---\n\n## Implementation Details\n\n### Threading Model\n\n- **1:1 threading** - Each task = 1 OS thread (`pthread`)\n- **Kernel-scheduled** - OS kernel distributes threads across cores\n- **Pre-emptive multitasking** - OS can interrupt and switch threads\n- **No GIL** - No Global Interpreter Lock (unlike Python)\n\n### Synchronization\n\n- **Mutexes** - Channels use `pthread_mutex_t`\n- **Condition variables** - Blocking send/recv use `pthread_cond_t`\n- **Lock-free operations** - Task state transitions are atomic\n\n### Memory & Cleanup\n\n- **Joined tasks** - Automatically cleaned up after `join()`\n- **Detached tasks** - pthread cleaned up by OS, Task struct (~64-96 bytes) currently leaks\n- **Channels** - Reference-counted, freed when no longer used\n\n---\n\n## Limitations (v0.1)\n\n- No `select()` for multiplexing multiple channels\n- No work-stealing scheduler (1 thread per task)\n- No async I/O integration (file/network operations block)\n- Channel capacity fixed at creation time\n- Detached task structs leak memory\n\n---\n\n## Complete API Summary\n\n### Functions\n\n| Function  | Signature                         | Returns   | Description                    |\n|-----------|-----------------------------------|-----------|--------------------------------|\n| `spawn`   | `(async_fn: function, ...args)`   | `task`    | Create and start concurrent task|\n| `join`    | `(task: task)`                    | `any`     | Wait for task, get result      |\n| `detach`  | `(task: task)`                    | `null`    | Detach task (fire-and-forget)  |\n| `channel` | `(capacity: i32)`                 | `channel` | Create thread-safe channel     |\n\n### Channel Methods\n\n| Method  | Signature       | Returns | Description                      |\n|---------|-----------------|---------|----------------------------------|\n| `send`  | `(value: any)`  | `null`  | Send value (blocks if full)      |\n| `recv`  | `()`            | `any`   | Receive value (blocks if empty)  |\n| `close` | `()`            | `null`  | Close channel                    |\n\n### Types\n\n| Type      | Description                          |\n|-----------|--------------------------------------|\n| `task`    | Handle for concurrent task           |\n| `channel` | Thread-safe communication channel    |\n\n---\n\n## Best Practices\n\n### Do's\n\n Use channels for communication between tasks\n Handle exceptions from joined tasks\n Close channels when done sending\n Use `join()` to get results and clean up\n Spawn async functions only\n\n### Don'ts\n\n Don't share mutable state without synchronization\n Don't join the same task twice\n Don't send on closed channels\n Don't spawn non-async functions\n Don't forget to join tasks (unless detached)\n\n---\n\n## See Also\n\n- [Built-in Functions](builtins.md) - `spawn()`, `join()`, `detach()`, `channel()`\n- [Type System](type-system.md) - Task and channel types\n"}, "API Reference  File Api": {"id": "reference-file-api", "content": "# File API Reference\n\nComplete reference for Hemlock's File I/O system.\n\n---\n\n## Overview\n\nHemlock provides a **File object API** for file operations with proper error handling and resource management. Files must be manually opened and closed.\n\n**Key Features:**\n- File object with methods\n- Read/write text and binary data\n- Seeking and positioning\n- Proper error messages\n- Manual resource management (no RAII)\n\n---\n\n## File Type\n\n**Type:** `file`\n\n**Description:** File handle for I/O operations\n\n**Properties (Read-Only):**\n- `.path` - File path (string)\n- `.mode` - Open mode (string)\n- `.closed` - Whether file is closed (bool)\n\n---\n\n## Opening Files\n\n### open\n\nOpen a file for reading, writing, or both.\n\n**Signature:**\n```hemlock\nopen(path: string, mode?: string): file\n```\n\n**Parameters:**\n- `path` - File path (relative or absolute)\n- `mode` (optional) - Open mode (default: `\"r\"`)\n\n**Returns:** File object\n\n**Modes:**\n- `\"r\"` - Read (default)\n- `\"w\"` - Write (truncate existing file)\n- `\"a\"` - Append\n- `\"r+\"` - Read and write\n- `\"w+\"` - Read and write (truncate)\n- `\"a+\"` - Read and append\n\n**Examples:**\n```hemlock\n// Read mode (default)\nlet f = open(\"data.txt\");\nlet f_read = open(\"data.txt\", \"r\");\n\n// Write mode (truncate)\nlet f_write = open(\"output.txt\", \"w\");\n\n// Append mode\nlet f_append = open(\"log.txt\", \"a\");\n\n// Read/write mode\nlet f_rw = open(\"data.bin\", \"r+\");\n\n// Read/write (truncate)\nlet f_rw_trunc = open(\"output.bin\", \"w+\");\n\n// Read/append\nlet f_ra = open(\"log.txt\", \"a+\");\n```\n\n**Error Handling:**\n```hemlock\ntry {\n    let f = open(\"missing.txt\", \"r\");\n} catch (e) {\n    print(\"Failed to open:\", e);\n    // Error: Failed to open 'missing.txt': No such file or directory\n}\n```\n\n**Important:** Files must be closed manually with `f.close()` to avoid file descriptor leaks.\n\n---\n\n## File Methods\n\n### Reading\n\n#### read\n\nRead text from file.\n\n**Signature:**\n```hemlock\nfile.read(size?: i32): string\n```\n\n**Parameters:**\n- `size` (optional) - Number of bytes to read (if omitted, reads to EOF)\n\n**Returns:** String with file contents\n\n**Examples:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\n// Read entire file\nlet all = f.read();\nprint(all);\n\n// Read specific number of bytes\nlet chunk = f.read(1024);\n\nf.close();\n```\n\n**Behavior:**\n- Reads from current file position\n- Returns empty string at EOF\n- Advances file position\n\n**Errors:**\n- Reading from closed file\n- Reading from write-only file\n\n---\n\n#### read_bytes\n\nRead binary data from file.\n\n**Signature:**\n```hemlock\nfile.read_bytes(size: i32): buffer\n```\n\n**Parameters:**\n- `size` - Number of bytes to read\n\n**Returns:** Buffer with binary data\n\n**Examples:**\n```hemlock\nlet f = open(\"data.bin\", \"r\");\n\n// Read 256 bytes\nlet binary = f.read_bytes(256);\nprint(binary.length);       // 256\n\n// Process binary data\nlet i = 0;\nwhile (i < binary.length) {\n    print(binary[i]);\n    i = i + 1;\n}\n\nf.close();\n```\n\n**Behavior:**\n- Reads exact number of bytes\n- Returns buffer (not string)\n- Advances file position\n\n---\n\n### Writing\n\n#### write\n\nWrite text to file.\n\n**Signature:**\n```hemlock\nfile.write(data: string): i32\n```\n\n**Parameters:**\n- `data` - String to write\n\n**Returns:** Number of bytes written (i32)\n\n**Examples:**\n```hemlock\nlet f = open(\"output.txt\", \"w\");\n\n// Write text\nlet written = f.write(\"Hello, World!\\n\");\nprint(\"Wrote\", written, \"bytes\");\n\n// Multiple writes\nf.write(\"Line 1\\n\");\nf.write(\"Line 2\\n\");\nf.write(\"Line 3\\n\");\n\nf.close();\n```\n\n**Behavior:**\n- Writes at current file position\n- Returns number of bytes written\n- Advances file position\n\n**Errors:**\n- Writing to closed file\n- Writing to read-only file\n\n---\n\n#### write_bytes\n\nWrite binary data to file.\n\n**Signature:**\n```hemlock\nfile.write_bytes(data: buffer): i32\n```\n\n**Parameters:**\n- `data` - Buffer to write\n\n**Returns:** Number of bytes written (i32)\n\n**Examples:**\n```hemlock\nlet f = open(\"output.bin\", \"w\");\n\n// Create buffer\nlet buf = buffer(10);\nbuf[0] = 65;  // 'A'\nbuf[1] = 66;  // 'B'\nbuf[2] = 67;  // 'C'\n\n// Write buffer\nlet written = f.write_bytes(buf);\nprint(\"Wrote\", written, \"bytes\");\n\nf.close();\n```\n\n**Behavior:**\n- Writes buffer contents to file\n- Returns number of bytes written\n- Advances file position\n\n---\n\n### Seeking\n\n#### seek\n\nMove file position to specific byte offset.\n\n**Signature:**\n```hemlock\nfile.seek(position: i32): i32\n```\n\n**Parameters:**\n- `position` - Byte offset from beginning of file\n\n**Returns:** New file position (i32)\n\n**Examples:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\n// Jump to byte 100\nf.seek(100);\n\n// Read from that position\nlet chunk = f.read(50);\n\n// Reset to beginning\nf.seek(0);\n\n// Read from start\nlet all = f.read();\n\nf.close();\n```\n\n**Behavior:**\n- Sets file position to absolute offset\n- Returns new position\n- Seeking past EOF is allowed (creates hole in file when writing)\n\n---\n\n#### tell\n\nGet current file position.\n\n**Signature:**\n```hemlock\nfile.tell(): i32\n```\n\n**Returns:** Current byte offset from beginning of file (i32)\n\n**Examples:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nprint(f.tell());        // 0 (at start)\n\nf.read(100);\nprint(f.tell());        // 100 (after reading)\n\nf.seek(50);\nprint(f.tell());        // 50 (after seeking)\n\nf.close();\n```\n\n---\n\n### Closing\n\n#### close\n\nClose file (idempotent).\n\n**Signature:**\n```hemlock\nfile.close(): null\n```\n\n**Returns:** `null`\n\n**Examples:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n\n// Safe to call multiple times\nf.close();  // No error\nf.close();  // No error\n```\n\n**Behavior:**\n- Closes file handle\n- Flushes any pending writes\n- Idempotent (safe to call multiple times)\n- Sets `.closed` property to `true`\n\n**Important:** Always close files when done to avoid file descriptor leaks.\n\n---\n\n## File Properties\n\n### .path\n\nGet file path.\n\n**Type:** `string`\n\n**Access:** Read-only\n\n**Examples:**\n```hemlock\nlet f = open(\"/path/to/file.txt\", \"r\");\nprint(f.path);          // \"/path/to/file.txt\"\nf.close();\n```\n\n---\n\n### .mode\n\nGet open mode.\n\n**Type:** `string`\n\n**Access:** Read-only\n\n**Examples:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.mode);          // \"r\"\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nprint(f2.mode);         // \"w\"\nf2.close();\n```\n\n---\n\n### .closed\n\nCheck if file is closed.\n\n**Type:** `bool`\n\n**Access:** Read-only\n\n**Examples:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.closed);        // false\n\nf.close();\nprint(f.closed);        // true\n```\n\n---\n\n## Error Handling\n\nAll file operations include proper error messages with context:\n\n### File Not Found\n```hemlock\nlet f = open(\"missing.txt\", \"r\");\n// Error: Failed to open 'missing.txt': No such file or directory\n```\n\n### Reading from Closed File\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nf.close();\nf.read();\n// Error: Cannot read from closed file 'data.txt'\n```\n\n### Writing to Read-Only File\n```hemlock\nlet f = open(\"readonly.txt\", \"r\");\nf.write(\"data\");\n// Error: Cannot write to file 'readonly.txt' opened in read-only mode\n```\n\n### Using try/catch\n```hemlock\nlet f = null;\ntry {\n    f = open(\"data.txt\", \"r\");\n    let content = f.read();\n    print(content);\n} catch (e) {\n    print(\"File error:\", e);\n} finally {\n    if (f != null && !f.closed) {\n        f.close();\n    }\n}\n```\n\n---\n\n## Resource Management Patterns\n\n### Basic Pattern\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n```\n\n### With Error Handling\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\ntry {\n    let content = f.read();\n    process(content);\n} finally {\n    f.close();  // Always close, even on error\n}\n```\n\n### Safe Pattern\n\n```hemlock\nlet f = null;\ntry {\n    f = open(\"data.txt\", \"r\");\n    let content = f.read();\n    // ... process content ...\n} catch (e) {\n    print(\"Error:\", e);\n} finally {\n    if (f != null && !f.closed) {\n        f.close();\n    }\n}\n```\n\n---\n\n## Usage Examples\n\n### Read Entire File\n\n```hemlock\nfn read_file(filename: string): string {\n    let f = open(filename, \"r\");\n    let content = f.read();\n    f.close();\n    return content;\n}\n\nlet text = read_file(\"data.txt\");\nprint(text);\n```\n\n### Write Text File\n\n```hemlock\nfn write_file(filename: string, content: string) {\n    let f = open(filename, \"w\");\n    f.write(content);\n    f.close();\n}\n\nwrite_file(\"output.txt\", \"Hello, World!\\n\");\n```\n\n### Append to File\n\n```hemlock\nfn append_file(filename: string, line: string) {\n    let f = open(filename, \"a\");\n    f.write(line + \"\\n\");\n    f.close();\n}\n\nappend_file(\"log.txt\", \"Log entry 1\");\nappend_file(\"log.txt\", \"Log entry 2\");\n```\n\n### Read Binary File\n\n```hemlock\nfn read_binary(filename: string, size: i32): buffer {\n    let f = open(filename, \"r\");\n    let data = f.read_bytes(size);\n    f.close();\n    return data;\n}\n\nlet binary = read_binary(\"data.bin\", 256);\nprint(\"Read\", binary.length, \"bytes\");\n```\n\n### Write Binary File\n\n```hemlock\nfn write_binary(filename: string, data: buffer) {\n    let f = open(filename, \"w\");\n    f.write_bytes(data);\n    f.close();\n}\n\nlet buf = buffer(10);\nbuf[0] = 65;\nwrite_binary(\"output.bin\", buf);\n```\n\n### Read File Line by Line\n\n```hemlock\nfn read_lines(filename: string): array {\n    let f = open(filename, \"r\");\n    let content = f.read();\n    f.close();\n    return content.split(\"\\n\");\n}\n\nlet lines = read_lines(\"data.txt\");\nlet i = 0;\nwhile (i < lines.length) {\n    print(\"Line\", i, \":\", lines[i]);\n    i = i + 1;\n}\n```\n\n### Copy File\n\n```hemlock\nfn copy_file(src: string, dest: string) {\n    let f_in = open(src, \"r\");\n    let f_out = open(dest, \"w\");\n\n    let content = f_in.read();\n    f_out.write(content);\n\n    f_in.close();\n    f_out.close();\n}\n\ncopy_file(\"input.txt\", \"output.txt\");\n```\n\n### Read File in Chunks\n\n```hemlock\nfn process_chunks(filename: string) {\n    let f = open(filename, \"r\");\n\n    while (true) {\n        let chunk = f.read(1024);  // Read 1KB at a time\n        if (chunk.length == 0) {\n            break;  // EOF\n        }\n\n        // Process chunk\n        print(\"Processing\", chunk.length, \"bytes\");\n    }\n\n    f.close();\n}\n\nprocess_chunks(\"large_file.txt\");\n```\n\n---\n\n## Complete Method Summary\n\n| Method        | Signature                | Returns   | Description                  |\n|---------------|--------------------------|-----------|------------------------------|\n| `read`        | `(size?: i32)`           | `string`  | Read text                    |\n| `read_bytes`  | `(size: i32)`            | `buffer`  | Read binary data             |\n| `write`       | `(data: string)`         | `i32`     | Write text                   |\n| `write_bytes` | `(data: buffer)`         | `i32`     | Write binary data            |\n| `seek`        | `(position: i32)`        | `i32`     | Set file position            |\n| `tell`        | `()`                     | `i32`     | Get file position            |\n| `close`       | `()`                     | `null`    | Close file (idempotent)      |\n\n---\n\n## Complete Property Summary\n\n| Property  | Type     | Access     | Description              |\n|-----------|----------|------------|--------------------------|\n| `.path`   | `string` | Read-only  | File path                |\n| `.mode`   | `string` | Read-only  | Open mode                |\n| `.closed` | `bool`   | Read-only  | Whether file is closed   |\n\n---\n\n## Migration from Old API\n\n**Old API (Removed):**\n- `read_file(path)` - Use `open(path, \"r\").read()`\n- `write_file(path, data)` - Use `open(path, \"w\").write(data)`\n- `append_file(path, data)` - Use `open(path, \"a\").write(data)`\n- `file_exists(path)` - No replacement yet\n\n**Migration Example:**\n```hemlock\n// Old (v0.0)\nlet content = read_file(\"data.txt\");\nwrite_file(\"output.txt\", content);\n\n// New (v0.1)\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nf2.write(content);\nf2.close();\n```\n\n---\n\n## See Also\n\n- [Built-in Functions](builtins.md) - `open()` function\n- [Memory API](memory-api.md) - Buffer type\n- [String API](string-api.md) - String methods for text processing\n"}, "API Reference  Memory Api": {"id": "reference-memory-api", "content": "# Memory API Reference\n\nComplete reference for Hemlock's memory management functions and pointer types.\n\n---\n\n## Overview\n\nHemlock provides **manual memory management** with explicit allocation and deallocation. Memory is managed through two pointer types: raw pointers (`ptr`) and safe buffers (`buffer`).\n\n**Key Principles:**\n- Explicit allocation and deallocation\n- No garbage collection\n- No automatic resource cleanup\n- User responsible for memory safety\n\n---\n\n## Pointer Types\n\n### ptr (Raw Pointer)\n\n**Type:** `ptr`\n\n**Description:** Raw memory address with no bounds checking or tracking.\n\n**Size:** 8 bytes\n\n**Use Cases:**\n- Low-level memory operations\n- FFI (Foreign Function Interface)\n- Maximum performance (no overhead)\n\n**Safety:** Unsafe - no bounds checking, user must track lifetime\n\n**Examples:**\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);\n```\n\n---\n\n### buffer (Safe Buffer)\n\n**Type:** `buffer`\n\n**Description:** Safe pointer wrapper with bounds checking.\n\n**Structure:** Pointer + length + capacity\n\n**Properties:**\n- `.length` - Buffer size (i32)\n- `.capacity` - Allocated capacity (i32)\n\n**Use Cases:**\n- Most memory allocations\n- When safety is important\n- Dynamic arrays\n\n**Safety:** Bounds-checked on index access\n\n**Examples:**\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // Bounds checked\nprint(b.length);        // 64\nfree(b);\n```\n\n---\n\n## Memory Allocation Functions\n\n### alloc\n\nAllocate raw memory.\n\n**Signature:**\n```hemlock\nalloc(size: i32): ptr\n```\n\n**Parameters:**\n- `size` - Number of bytes to allocate\n\n**Returns:** Pointer to allocated memory (`ptr`)\n\n**Examples:**\n```hemlock\nlet p = alloc(1024);        // Allocate 1KB\nmemset(p, 0, 1024);         // Initialize to zero\nfree(p);                    // Free when done\n\n// Allocate for structure\nlet struct_size = 16;\nlet p2 = alloc(struct_size);\n```\n\n**Behavior:**\n- Returns uninitialized memory\n- Memory must be manually freed\n- Returns valid pointer or crashes on allocation failure\n\n**See Also:** `buffer()` for safer alternative\n\n---\n\n### buffer\n\nAllocate safe buffer with bounds checking.\n\n**Signature:**\n```hemlock\nbuffer(size: i32): buffer\n```\n\n**Parameters:**\n- `size` - Buffer size in bytes\n\n**Returns:** Buffer object\n\n**Examples:**\n```hemlock\nlet buf = buffer(256);\nprint(buf.length);          // 256\nprint(buf.capacity);        // 256\n\n// Access with bounds checking\nbuf[0] = 65;                // 'A'\nbuf[255] = 90;              // 'Z'\n// buf[256] = 0;            // ERROR: out of bounds\n\nfree(buf);\n```\n\n**Properties:**\n- `.length` - Current size (i32)\n- `.capacity` - Allocated capacity (i32)\n\n**Behavior:**\n- Initializes memory to zero\n- Provides bounds checking on index access\n- Must be manually freed\n\n---\n\n### free\n\nFree allocated memory.\n\n**Signature:**\n```hemlock\nfree(ptr: ptr | buffer): null\n```\n\n**Parameters:**\n- `ptr` - Pointer or buffer to free\n\n**Returns:** `null`\n\n**Examples:**\n```hemlock\n// Free raw pointer\nlet p = alloc(1024);\nfree(p);\n\n// Free buffer\nlet buf = buffer(256);\nfree(buf);\n```\n\n**Behavior:**\n- Frees memory allocated by `alloc()` or `buffer()`\n- Double-free causes crash (user's responsibility to avoid)\n- Freeing invalid pointers causes undefined behavior\n\n**Important:** You allocate, you free. No automatic cleanup.\n\n---\n\n### realloc\n\nResize allocated memory.\n\n**Signature:**\n```hemlock\nrealloc(ptr: ptr, new_size: i32): ptr\n```\n\n**Parameters:**\n- `ptr` - Pointer to resize\n- `new_size` - New size in bytes\n\n**Returns:** Pointer to resized memory (may be different address)\n\n**Examples:**\n```hemlock\nlet p = alloc(100);\n// ... use memory ...\n\n// Need more space\np = realloc(p, 200);        // Now 200 bytes\n// ... use expanded memory ...\n\nfree(p);\n```\n\n**Behavior:**\n- May move memory to new location\n- Preserves existing data (up to minimum of old/new size)\n- Old pointer is invalid after realloc (use returned pointer)\n- If new_size is smaller, data is truncated\n\n**Important:** Always update your pointer variable with the result.\n\n---\n\n## Memory Operations\n\n### memset\n\nFill memory with byte value.\n\n**Signature:**\n```hemlock\nmemset(ptr: ptr, byte: i32, size: i32): null\n```\n\n**Parameters:**\n- `ptr` - Pointer to memory\n- `byte` - Byte value to fill (0-255)\n- `size` - Number of bytes to fill\n\n**Returns:** `null`\n\n**Examples:**\n```hemlock\nlet p = alloc(100);\n\n// Zero out memory\nmemset(p, 0, 100);\n\n// Fill with specific value\nmemset(p, 0xFF, 100);\n\n// Initialize buffer\nlet buf = alloc(256);\nmemset(buf, 65, 256);       // Fill with 'A'\n\nfree(p);\nfree(buf);\n```\n\n**Behavior:**\n- Writes byte value to each byte in range\n- Byte value is truncated to 8 bits (0-255)\n- No bounds checking (unsafe)\n\n---\n\n### memcpy\n\nCopy memory from source to destination.\n\n**Signature:**\n```hemlock\nmemcpy(dest: ptr, src: ptr, size: i32): null\n```\n\n**Parameters:**\n- `dest` - Destination pointer\n- `src` - Source pointer\n- `size` - Number of bytes to copy\n\n**Returns:** `null`\n\n**Examples:**\n```hemlock\nlet src = alloc(100);\nlet dest = alloc(100);\n\n// Initialize source\nmemset(src, 65, 100);\n\n// Copy to destination\nmemcpy(dest, src, 100);\n\n// dest now contains same data as src\n\nfree(src);\nfree(dest);\n```\n\n**Behavior:**\n- Copies byte-by-byte from src to dest\n- No bounds checking (unsafe)\n- Overlapping regions have undefined behavior (use carefully)\n\n---\n\n## Typed Memory Operations (TODO)\n\n**Note:** These functions are documented but not fully implemented yet.\n\n### sizeof\n\nGet size of type in bytes.\n\n**Signature:**\n```hemlock\nsizeof(type): i32\n```\n\n**Parameters:**\n- `type` - Type name (e.g., `i32`, `f64`, `ptr`)\n\n**Returns:** Size in bytes\n\n**Examples (Future):**\n```hemlock\nlet int_size = sizeof(i32);      // 4\nlet ptr_size = sizeof(ptr);      // 8\nlet float_size = sizeof(f64);    // 8\n```\n\n**Status:** Parsed but not implemented (v0.1)\n\n---\n\n### talloc\n\nAllocate array of typed values.\n\n**Signature:**\n```hemlock\ntalloc(type, count: i32): ptr\n```\n\n**Parameters:**\n- `type` - Type to allocate\n- `count` - Number of elements\n\n**Returns:** Pointer to allocated array\n\n**Examples (Future):**\n```hemlock\nlet arr = talloc(i32, 100);      // Array of 100 i32s\nlet floats = talloc(f64, 50);    // Array of 50 f64s\n\nfree(arr);\nfree(floats);\n```\n\n**Status:** Parsed but not implemented (v0.1)\n\n---\n\n## Buffer Properties\n\n### .length\n\nGet buffer size.\n\n**Type:** `i32`\n\n**Access:** Read-only\n\n**Examples:**\n```hemlock\nlet buf = buffer(256);\nprint(buf.length);          // 256\n\nlet buf2 = buffer(1024);\nprint(buf2.length);         // 1024\n```\n\n---\n\n### .capacity\n\nGet buffer capacity.\n\n**Type:** `i32`\n\n**Access:** Read-only\n\n**Examples:**\n```hemlock\nlet buf = buffer(256);\nprint(buf.capacity);        // 256\n```\n\n**Note:** Currently, `.length` and `.capacity` are the same for buffers created with `buffer()`.\n\n---\n\n## Usage Patterns\n\n### Basic Allocation Pattern\n\n```hemlock\n// Allocate\nlet p = alloc(1024);\n\n// Use\nmemset(p, 0, 1024);\n\n// Free\nfree(p);\n```\n\n### Safe Buffer Pattern\n\n```hemlock\n// Allocate buffer\nlet buf = buffer(256);\n\n// Use with bounds checking\nlet i = 0;\nwhile (i < buf.length) {\n    buf[i] = i;\n    i = i + 1;\n}\n\n// Free\nfree(buf);\n```\n\n### Dynamic Growth Pattern\n\n```hemlock\nlet size = 100;\nlet p = alloc(size);\n\n// ... use memory ...\n\n// Need more space\nsize = 200;\np = realloc(p, size);\n\n// ... use expanded memory ...\n\nfree(p);\n```\n\n### Memory Copy Pattern\n\n```hemlock\nlet original = alloc(100);\nmemset(original, 65, 100);\n\n// Create copy\nlet copy = alloc(100);\nmemcpy(copy, original, 100);\n\nfree(original);\nfree(copy);\n```\n\n---\n\n## Safety Considerations\n\n**Hemlock memory management is UNSAFE by design:**\n\n### Common Pitfalls\n\n**1. Memory Leaks**\n```hemlock\n// BAD: Memory leak\nfn create_buffer() {\n    let p = alloc(1024);\n    return null;  // Memory leaked!\n}\n\n// GOOD: Proper cleanup\nfn create_buffer() {\n    let p = alloc(1024);\n    // ... use memory ...\n    free(p);\n    return null;\n}\n```\n\n**2. Use After Free**\n```hemlock\n// BAD: Use after free\nlet p = alloc(100);\nfree(p);\nmemset(p, 0, 100);  // CRASH: using freed memory\n\n// GOOD: Don't use after free\nlet p2 = alloc(100);\nmemset(p2, 0, 100);\nfree(p2);\n// Don't touch p2 after this\n```\n\n**3. Double Free**\n```hemlock\n// BAD: Double free\nlet p = alloc(100);\nfree(p);\nfree(p);  // CRASH: double free\n\n// GOOD: Free once\nlet p2 = alloc(100);\nfree(p2);\n```\n\n**4. Buffer Overflow (ptr)**\n```hemlock\n// BAD: Buffer overflow with ptr\nlet p = alloc(10);\nmemset(p, 65, 100);  // CRASH: writing past allocation\n\n// GOOD: Use buffer for bounds checking\nlet buf = buffer(10);\n// buf[100] = 65;  // ERROR: bounds check fails\n```\n\n**5. Dangling Pointers**\n```hemlock\n// BAD: Dangling pointer\nlet p1 = alloc(100);\nlet p2 = p1;\nfree(p1);\nmemset(p2, 0, 100);  // CRASH: p2 is dangling\n\n// GOOD: Track ownership carefully\nlet p = alloc(100);\n// ... use p ...\nfree(p);\n// Don't keep other references to p\n```\n\n---\n\n## When to Use What\n\n### Use `buffer()` when:\n- You need bounds checking\n- Working with dynamic data\n- Safety is important\n- Learning Hemlock\n\n### Use `alloc()` when:\n- Maximum performance needed\n- FFI/interfacing with C\n- You know exact memory layout\n- You're an expert\n\n### Use `realloc()` when:\n- Growing/shrinking allocations\n- Dynamic arrays\n- You need to preserve data\n\n---\n\n## Complete Function Summary\n\n| Function  | Signature                              | Returns  | Description                |\n|-----------|----------------------------------------|----------|----------------------------|\n| `alloc`   | `(size: i32)`                          | `ptr`    | Allocate raw memory        |\n| `buffer`  | `(size: i32)`                          | `buffer` | Allocate safe buffer       |\n| `free`    | `(ptr: ptr \\| buffer)`                 | `null`   | Free memory                |\n| `realloc` | `(ptr: ptr, new_size: i32)`            | `ptr`    | Resize allocation          |\n| `memset`  | `(ptr: ptr, byte: i32, size: i32)`     | `null`   | Fill memory                |\n| `memcpy`  | `(dest: ptr, src: ptr, size: i32)`     | `null`   | Copy memory                |\n| `sizeof`  | `(type)`                               | `i32`    | Get type size (TODO)       |\n| `talloc`  | `(type, count: i32)`                   | `ptr`    | Allocate typed array (TODO)|\n\n---\n\n## See Also\n\n- [Type System](type-system.md) - Pointer and buffer types\n- [Built-in Functions](builtins.md) - All built-in functions\n- [String API](string-api.md) - String `.to_bytes()` method\n"}, "API Reference  Operators": {"id": "reference-operators", "content": "# Operators Reference\n\nComplete reference for all operators in Hemlock, including precedence, associativity, and behavior.\n\n---\n\n## Overview\n\nHemlock provides C-style operators with explicit precedence rules. All operators follow strict typing rules with automatic type promotion where applicable.\n\n---\n\n## Arithmetic Operators\n\n### Binary Arithmetic\n\n| Operator | Name           | Example    | Description                  |\n|----------|----------------|------------|------------------------------|\n| `+`      | Addition       | `a + b`    | Add two values               |\n| `-`      | Subtraction    | `a - b`    | Subtract b from a            |\n| `*`      | Multiplication | `a * b`    | Multiply two values          |\n| `/`      | Division       | `a / b`    | Divide a by b                |\n\n**Type Promotion:**\nResults follow type promotion rules (see [Type System](type-system.md#type-promotion-rules)).\n\n**Examples:**\n```hemlock\nlet a = 10 + 5;        // 15 (i32)\nlet b = 10 - 3;        // 7 (i32)\nlet c = 4 * 5;         // 20 (i32)\nlet d = 20 / 4;        // 5 (i32)\n\n// Float division\nlet e = 10.0 / 3.0;    // 3.333... (f64)\n\n// Mixed types\nlet f: u8 = 10;\nlet g: i32 = 20;\nlet h = f + g;         // 30 (i32, promoted)\n```\n\n**Division by Zero:**\n- Integer division by zero: Runtime error\n- Float division by zero: Returns `inf` or `-inf`\n\n---\n\n### Unary Arithmetic\n\n| Operator | Name     | Example | Description          |\n|----------|----------|---------|----------------------|\n| `-`      | Negation | `-a`    | Negate value         |\n| `+`      | Plus     | `+a`    | Identity (no-op)     |\n\n**Examples:**\n```hemlock\nlet a = 5;\nlet b = -a;            // -5\nlet c = +a;            // 5 (no change)\n\nlet x = -3.14;         // -3.14\n```\n\n---\n\n## Comparison Operators\n\n| Operator | Name                  | Example    | Returns |\n|----------|-----------------------|------------|---------|\n| `==`     | Equal                 | `a == b`   | `bool`  |\n| `!=`     | Not equal             | `a != b`   | `bool`  |\n| `<`      | Less than             | `a < b`    | `bool`  |\n| `>`      | Greater than          | `a > b`    | `bool`  |\n| `<=`     | Less than or equal    | `a <= b`   | `bool`  |\n| `>=`     | Greater than or equal | `a >= b`   | `bool`  |\n\n**Type Promotion:**\nOperands are promoted before comparison.\n\n**Examples:**\n```hemlock\nprint(5 == 5);         // true\nprint(10 != 5);        // true\nprint(3 < 7);          // true\nprint(10 > 5);         // true\nprint(5 <= 5);         // true\nprint(10 >= 5);        // true\n\n// String comparison\nprint(\"hello\" == \"hello\");  // true\nprint(\"abc\" < \"def\");       // true (lexicographic)\n\n// Mixed types\nlet a: u8 = 10;\nlet b: i32 = 10;\nprint(a == b);         // true (promoted to i32)\n```\n\n---\n\n## Logical Operators\n\n| Operator | Name        | Example      | Description              |\n|----------|-------------|--------------|--------------------------|\n| `&&`     | Logical AND | `a && b`     | True if both are true    |\n| `||`     | Logical OR  | `a || b`     | True if either is true   |\n| `!`      | Logical NOT | `!a`         | Negate boolean           |\n\n**Short-Circuit Evaluation:**\n- `&&` - Stops at first false value\n- `||` - Stops at first true value\n\n**Examples:**\n```hemlock\nlet a = true;\nlet b = false;\n\nprint(a && b);         // false\nprint(a || b);         // true\nprint(!a);             // false\nprint(!b);             // true\n\n// Short-circuit\nif (x != 0 && (10 / x) > 2) {\n    print(\"safe\");\n}\n\nif (x == 0 || (10 / x) > 2) {\n    print(\"safe\");\n}\n```\n\n---\n\n## Bitwise Operators\n\n**Restriction:** Integer types only (i8-i64, u8-u64)\n\n### Binary Bitwise\n\n| Operator | Name         | Example    | Description              |\n|----------|--------------|------------|--------------------------|\n| `&`      | Bitwise AND  | `a & b`    | AND each bit             |\n| `|`      | Bitwise OR   | `a | b`    | OR each bit              |\n| `^`      | Bitwise XOR  | `a ^ b`    | XOR each bit             |\n| `<<`     | Left shift   | `a << b`   | Shift left by b bits     |\n| `>>`     | Right shift  | `a >> b`   | Shift right by b bits    |\n\n**Type Preservation:**\nResult type matches operand types (with type promotion).\n\n**Examples:**\n```hemlock\nlet a = 12;  // 1100 in binary\nlet b = 10;  // 1010 in binary\n\nprint(a & b);          // 8  (1000)\nprint(a | b);          // 14 (1110)\nprint(a ^ b);          // 6  (0110)\nprint(a << 2);         // 48 (110000)\nprint(a >> 1);         // 6  (110)\n```\n\n**Unsigned Example:**\n```hemlock\nlet c: u8 = 15;        // 00001111\nlet d: u8 = 7;         // 00000111\n\nprint(c & d);          // 7  (00000111)\nprint(c | d);          // 15 (00001111)\nprint(c ^ d);          // 8  (00001000)\n```\n\n**Right Shift Behavior:**\n- Signed types: Arithmetic shift (sign-extends)\n- Unsigned types: Logical shift (zero-fills)\n\n---\n\n### Unary Bitwise\n\n| Operator | Name        | Example | Description              |\n|----------|-------------|---------|--------------------------|\n| `~`      | Bitwise NOT | `~a`    | Flip all bits            |\n\n**Examples:**\n```hemlock\nlet a = 12;            // 00001100 (i32)\nprint(~a);             // -13 (two's complement)\n\nlet b: u8 = 15;        // 00001111\nprint(~b);             // 240 (11110000)\n```\n\n---\n\n## String Operators\n\n### Concatenation\n\n| Operator | Name           | Example    | Description        |\n|----------|----------------|------------|--------------------|\n| `+`      | Concatenation  | `a + b`    | Join strings       |\n\n**Examples:**\n```hemlock\nlet s = \"hello\" + \" \" + \"world\";  // \"hello world\"\nlet msg = \"Count: \" + typeof(42); // \"Count: 42\"\n\n// String + rune\nlet greeting = \"Hello\" + '!';      // \"Hello!\"\n\n// Rune + string\nlet prefix = '>' + \" Message\";     // \"> Message\"\n```\n\n---\n\n## Assignment Operators\n\n### Basic Assignment\n\n| Operator | Name       | Example    | Description              |\n|----------|------------|------------|--------------------------|\n| `=`      | Assignment | `a = b`    | Assign value to variable |\n\n**Examples:**\n```hemlock\nlet x = 10;\nx = 20;\n\nlet arr = [1, 2, 3];\narr[0] = 99;\n\nlet obj = { x: 10 };\nobj.x = 20;\n```\n\n**Note:** Hemlock does NOT support compound assignment operators (`+=`, `-=`, etc.)\n\n---\n\n## Member Access Operators\n\n### Dot Operator\n\n| Operator | Name             | Example      | Description           |\n|----------|------------------|--------------|-----------------------|\n| `.`      | Member access    | `obj.field`  | Access object field   |\n| `.`      | Property access  | `arr.length` | Access property       |\n\n**Examples:**\n```hemlock\n// Object field access\nlet person = { name: \"Alice\", age: 30 };\nprint(person.name);        // \"Alice\"\n\n// Array property\nlet arr = [1, 2, 3];\nprint(arr.length);         // 3\n\n// String property\nlet s = \"hello\";\nprint(s.length);           // 5\n\n// Method call\nlet result = s.to_upper(); // \"HELLO\"\n```\n\n---\n\n### Index Operator\n\n| Operator | Name    | Example   | Description          |\n|----------|---------|-----------|----------------------|\n| `[]`     | Index   | `arr[i]`  | Access element       |\n\n**Examples:**\n```hemlock\n// Array indexing\nlet arr = [10, 20, 30];\nprint(arr[0]);             // 10\narr[1] = 99;\n\n// String indexing (returns rune)\nlet s = \"hello\";\nprint(s[0]);               // 'h'\ns[0] = 'H';                // \"Hello\"\n\n// Buffer indexing\nlet buf = buffer(10);\nbuf[0] = 65;\nprint(buf[0]);             // 65\n```\n\n---\n\n## Function Call Operator\n\n| Operator | Name          | Example      | Description        |\n|----------|---------------|--------------|--------------------|\n| `()`     | Function call | `f(a, b)`    | Call function      |\n\n**Examples:**\n```hemlock\nfn add(a, b) {\n    return a + b;\n}\n\nlet result = add(5, 3);    // 8\n\n// Method call\nlet s = \"hello\";\nlet upper = s.to_upper();  // \"HELLO\"\n\n// Builtin call\nprint(\"message\");\n```\n\n---\n\n## Operator Precedence\n\nOperators are listed from highest to lowest precedence:\n\n| Precedence | Operators                  | Description                    | Associativity |\n|------------|----------------------------|--------------------------------|---------------|\n| 1          | `()` `[]` `.`              | Call, index, member access     | Left-to-right |\n| 2          | `!` `~` `-` (unary) `+` (unary) | Logical NOT, bitwise NOT, negation | Right-to-left |\n| 3          | `*` `/`                    | Multiplication, division       | Left-to-right |\n| 4          | `+` `-`                    | Addition, subtraction          | Left-to-right |\n| 5          | `<<` `>>`                  | Bit shifts                     | Left-to-right |\n| 6          | `<` `<=` `>` `>=`          | Relational                     | Left-to-right |\n| 7          | `==` `!=`                  | Equality                       | Left-to-right |\n| 8          | `&`                        | Bitwise AND                    | Left-to-right |\n| 9          | `^`                        | Bitwise XOR                    | Left-to-right |\n| 10         | `|`                        | Bitwise OR                     | Left-to-right |\n| 11         | `&&`                       | Logical AND                    | Left-to-right |\n| 12         | `||`                       | Logical OR                     | Left-to-right |\n| 13         | `=`                        | Assignment                     | Right-to-left |\n\n---\n\n## Precedence Examples\n\n### Example 1: Arithmetic and Comparison\n```hemlock\nlet result = 5 + 3 * 2;\n// Evaluated as: 5 + (3 * 2) = 11\n// Multiplication has higher precedence than addition\n\nlet cmp = 10 > 5 + 3;\n// Evaluated as: 10 > (5 + 3) = true\n// Addition has higher precedence than comparison\n```\n\n### Example 2: Bitwise Operators\n```hemlock\nlet result1 = 12 | 10 & 8;\n// Evaluated as: 12 | (10 & 8) = 12 | 8 = 12\n// & has higher precedence than |\n\nlet result2 = 8 | 1 << 2;\n// Evaluated as: 8 | (1 << 2) = 8 | 4 = 12\n// Shift has higher precedence than bitwise OR\n\n// Use parentheses for clarity\nlet result3 = (5 & 3) | (2 << 1);\n// Evaluated as: 1 | 4 = 5\n```\n\n### Example 3: Logical Operators\n```hemlock\nlet result = true || false && false;\n// Evaluated as: true || (false && false) = true\n// && has higher precedence than ||\n\nlet cmp = 5 < 10 && 10 < 20;\n// Evaluated as: (5 < 10) && (10 < 20) = true\n// Comparison has higher precedence than &&\n```\n\n### Example 4: Using Parentheses\n```hemlock\n// Without parentheses\nlet a = 2 + 3 * 4;        // 14\n\n// With parentheses\nlet b = (2 + 3) * 4;      // 20\n\n// Complex expression\nlet c = (a + b) * (a - b);\n```\n\n---\n\n## Type-Specific Operator Behavior\n\n### Integer Division\n\nInteger division truncates toward zero:\n\n```hemlock\nprint(10 / 3);             // 3 (i32)\nprint(-10 / 3);            // -3 (i32)\nprint(10 / -3);            // -3 (i32)\n```\n\n### Float Division\n\nFloat division preserves precision:\n\n```hemlock\nprint(10.0 / 3.0);         // 3.333... (f64)\nprint(10.0 / 4.0);         // 2.5 (f64)\n```\n\n### String Comparison\n\nStrings are compared lexicographically:\n\n```hemlock\nprint(\"abc\" < \"def\");      // true\nprint(\"apple\" > \"banana\"); // false\nprint(\"hello\" == \"hello\"); // true\n```\n\n### Null Comparison\n\n```hemlock\nlet x = null;\n\nprint(x == null);          // true\nprint(x != null);          // false\n```\n\n### Type Errors\n\nSome operations are not allowed between incompatible types:\n\n```hemlock\n// ERROR: Cannot use bitwise operators on floats\nlet x = 3.14 & 2.71;\n\n// ERROR: Cannot use bitwise operators on strings\nlet y = \"hello\" & \"world\";\n\n// OK: Type promotion for arithmetic\nlet a: u8 = 10;\nlet b: i32 = 20;\nlet c = a + b;             // i32 (promoted)\n```\n\n---\n\n## See Also\n\n- [Type System](type-system.md) - Type promotion and conversion rules\n- [Built-in Functions](builtins.md) - Built-in operations\n- [String API](string-api.md) - String concatenation and methods\n"}, "API Reference  String Api": {"id": "reference-string-api", "content": "# String API Reference\n\nComplete reference for Hemlock's string type and all 18 string methods.\n\n---\n\n## Overview\n\nStrings in Hemlock are **UTF-8 encoded, mutable, heap-allocated** sequences with full Unicode support. All operations work with **codepoints** (characters), not bytes.\n\n**Key Features:**\n- UTF-8 encoding (U+0000 to U+10FFFF)\n- Mutable (can modify characters in place)\n- Codepoint-based indexing\n- 18 built-in methods\n- Automatic concatenation with `+` operator\n\n---\n\n## String Type\n\n**Type:** `string`\n\n**Properties:**\n- `.length` - Number of codepoints (characters)\n- `.byte_length` - Number of UTF-8 bytes\n\n**Literal Syntax:** Double quotes `\"text\"`\n\n**Examples:**\n```hemlock\nlet s = \"hello\";\nprint(s.length);        // 5 (codepoints)\nprint(s.byte_length);   // 5 (bytes)\n\nlet emoji = \"\";\nprint(emoji.length);        // 1 (one codepoint)\nprint(emoji.byte_length);   // 4 (four UTF-8 bytes)\n```\n\n---\n\n## Indexing\n\nStrings support codepoint-based indexing using `[]`:\n\n**Read Access:**\n```hemlock\nlet s = \"hello\";\nlet ch = s[0];          // Returns rune 'h'\n```\n\n**Write Access:**\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';             // Mutate with rune (now \"Hello\")\n```\n\n**UTF-8 Example:**\n```hemlock\nlet text = \"Hi!\";\nprint(text[0]);         // 'H'\nprint(text[1]);         // 'i'\nprint(text[2]);         // '' (one codepoint)\nprint(text[3]);         // '!'\n```\n\n---\n\n## Concatenation\n\nUse the `+` operator to concatenate strings and runes:\n\n**String + String:**\n```hemlock\nlet s = \"hello\" + \" \" + \"world\";  // \"hello world\"\nlet msg = \"Count: \" + typeof(42); // \"Count: 42\"\n```\n\n**String + Rune:**\n```hemlock\nlet greeting = \"Hello\" + '!';      // \"Hello!\"\nlet decorated = \"Text\" + '';      // \"Text\"\n```\n\n**Rune + String:**\n```hemlock\nlet prefix = '>' + \" Message\";     // \"> Message\"\nlet bullet = '' + \" Item\";        // \" Item\"\n```\n\n**Multiple Concatenations:**\n```hemlock\nlet msg = \"Hi \" + '' + \" World \" + '';  // \"Hi  World \"\n```\n\n---\n\n## String Properties\n\n### .length\n\nGet the number of Unicode codepoints (characters).\n\n**Type:** `i32`\n\n**Examples:**\n```hemlock\nlet s = \"hello\";\nprint(s.length);        // 5\n\nlet emoji = \"\";\nprint(emoji.length);    // 1 (one codepoint)\n\nlet text = \"Hello !\";\nprint(text.length);     // 8 (7 ASCII + 1 emoji)\n```\n\n---\n\n### .byte_length\n\nGet the number of UTF-8 bytes.\n\n**Type:** `i32`\n\n**Examples:**\n```hemlock\nlet s = \"hello\";\nprint(s.byte_length);   // 5 (1 byte per ASCII char)\n\nlet emoji = \"\";\nprint(emoji.byte_length); // 4 (emoji is 4 UTF-8 bytes)\n\nlet text = \"Hello !\";\nprint(text.byte_length);  // 11 (7 ASCII + 4 for emoji)\n```\n\n---\n\n## String Methods\n\n### Substring & Slicing\n\n#### substr\n\nExtract substring by position and length.\n\n**Signature:**\n```hemlock\nstring.substr(start: i32, length: i32): string\n```\n\n**Parameters:**\n- `start` - Starting codepoint index (0-based)\n- `length` - Number of codepoints to extract\n\n**Returns:** New string\n\n**Examples:**\n```hemlock\nlet s = \"hello world\";\nlet sub = s.substr(6, 5);       // \"world\"\nlet first = s.substr(0, 5);     // \"hello\"\n\n// UTF-8 example\nlet text = \"Hi!\";\nlet emoji = text.substr(2, 1);  // \"\"\n```\n\n---\n\n#### slice\n\nExtract substring by range (end exclusive).\n\n**Signature:**\n```hemlock\nstring.slice(start: i32, end: i32): string\n```\n\n**Parameters:**\n- `start` - Starting codepoint index (0-based)\n- `end` - Ending codepoint index (exclusive)\n\n**Returns:** New string\n\n**Examples:**\n```hemlock\nlet s = \"hello world\";\nlet sub = s.slice(0, 5);        // \"hello\"\nlet world = s.slice(6, 11);     // \"world\"\n\n// UTF-8 example\nlet text = \"Hi!\";\nlet first_three = text.slice(0, 3);  // \"Hi\"\n```\n\n---\n\n### Search & Find\n\n#### find\n\nFind first occurrence of substring.\n\n**Signature:**\n```hemlock\nstring.find(needle: string): i32\n```\n\n**Parameters:**\n- `needle` - Substring to search for\n\n**Returns:** Codepoint index of first occurrence, or `-1` if not found\n\n**Examples:**\n```hemlock\nlet s = \"hello world\";\nlet pos = s.find(\"world\");      // 6\nlet pos2 = s.find(\"foo\");       // -1 (not found)\nlet pos3 = s.find(\"l\");         // 2 (first 'l')\n```\n\n---\n\n#### contains\n\nCheck if string contains substring.\n\n**Signature:**\n```hemlock\nstring.contains(needle: string): bool\n```\n\n**Parameters:**\n- `needle` - Substring to search for\n\n**Returns:** `true` if found, `false` otherwise\n\n**Examples:**\n```hemlock\nlet s = \"hello world\";\nlet has = s.contains(\"world\");  // true\nlet has2 = s.contains(\"foo\");   // false\n```\n\n---\n\n### Split & Join\n\n#### split\n\nSplit string into array by delimiter.\n\n**Signature:**\n```hemlock\nstring.split(delimiter: string): array\n```\n\n**Parameters:**\n- `delimiter` - String to split on\n\n**Returns:** Array of strings\n\n**Examples:**\n```hemlock\nlet csv = \"a,b,c\";\nlet parts = csv.split(\",\");     // [\"a\", \"b\", \"c\"]\n\nlet path = \"/usr/local/bin\";\nlet dirs = path.split(\"/\");     // [\"\", \"usr\", \"local\", \"bin\"]\n\nlet text = \"hello world foo\";\nlet words = text.split(\" \");    // [\"hello\", \"world\", \"foo\"]\n```\n\n---\n\n#### trim\n\nRemove leading and trailing whitespace.\n\n**Signature:**\n```hemlock\nstring.trim(): string\n```\n\n**Returns:** New string with whitespace removed\n\n**Examples:**\n```hemlock\nlet s = \"  hello  \";\nlet clean = s.trim();           // \"hello\"\n\nlet text = \"\\n\\t  world  \\n\";\nlet clean2 = text.trim();       // \"world\"\n```\n\n---\n\n### Case Conversion\n\n#### to_upper\n\nConvert string to uppercase.\n\n**Signature:**\n```hemlock\nstring.to_upper(): string\n```\n\n**Returns:** New string in uppercase\n\n**Examples:**\n```hemlock\nlet s = \"hello world\";\nlet upper = s.to_upper();       // \"HELLO WORLD\"\n\nlet mixed = \"HeLLo\";\nlet upper2 = mixed.to_upper();  // \"HELLO\"\n```\n\n---\n\n#### to_lower\n\nConvert string to lowercase.\n\n**Signature:**\n```hemlock\nstring.to_lower(): string\n```\n\n**Returns:** New string in lowercase\n\n**Examples:**\n```hemlock\nlet s = \"HELLO WORLD\";\nlet lower = s.to_lower();       // \"hello world\"\n\nlet mixed = \"HeLLo\";\nlet lower2 = mixed.to_lower();  // \"hello\"\n```\n\n---\n\n### Prefix & Suffix\n\n#### starts_with\n\nCheck if string starts with prefix.\n\n**Signature:**\n```hemlock\nstring.starts_with(prefix: string): bool\n```\n\n**Parameters:**\n- `prefix` - Prefix to check\n\n**Returns:** `true` if string starts with prefix, `false` otherwise\n\n**Examples:**\n```hemlock\nlet s = \"hello world\";\nlet starts = s.starts_with(\"hello\");  // true\nlet starts2 = s.starts_with(\"world\"); // false\n```\n\n---\n\n#### ends_with\n\nCheck if string ends with suffix.\n\n**Signature:**\n```hemlock\nstring.ends_with(suffix: string): bool\n```\n\n**Parameters:**\n- `suffix` - Suffix to check\n\n**Returns:** `true` if string ends with suffix, `false` otherwise\n\n**Examples:**\n```hemlock\nlet s = \"hello world\";\nlet ends = s.ends_with(\"world\");      // true\nlet ends2 = s.ends_with(\"hello\");     // false\n```\n\n---\n\n### Replacement\n\n#### replace\n\nReplace first occurrence of substring.\n\n**Signature:**\n```hemlock\nstring.replace(old: string, new: string): string\n```\n\n**Parameters:**\n- `old` - Substring to replace\n- `new` - Replacement string\n\n**Returns:** New string with first occurrence replaced\n\n**Examples:**\n```hemlock\nlet s = \"hello world\";\nlet s2 = s.replace(\"world\", \"there\");  // \"hello there\"\n\nlet text = \"foo foo foo\";\nlet text2 = text.replace(\"foo\", \"bar\"); // \"bar foo foo\" (only first)\n```\n\n---\n\n#### replace_all\n\nReplace all occurrences of substring.\n\n**Signature:**\n```hemlock\nstring.replace_all(old: string, new: string): string\n```\n\n**Parameters:**\n- `old` - Substring to replace\n- `new` - Replacement string\n\n**Returns:** New string with all occurrences replaced\n\n**Examples:**\n```hemlock\nlet text = \"foo foo foo\";\nlet text2 = text.replace_all(\"foo\", \"bar\"); // \"bar bar bar\"\n\nlet s = \"hello world hello\";\nlet s2 = s.replace_all(\"hello\", \"hi\");      // \"hi world hi\"\n```\n\n---\n\n### Repetition\n\n#### repeat\n\nRepeat string n times.\n\n**Signature:**\n```hemlock\nstring.repeat(count: i32): string\n```\n\n**Parameters:**\n- `count` - Number of repetitions\n\n**Returns:** New string repeated count times\n\n**Examples:**\n```hemlock\nlet s = \"ha\";\nlet repeated = s.repeat(3);     // \"hahaha\"\n\nlet line = \"-\";\nlet separator = line.repeat(40); // \"----------------------------------------\"\n```\n\n---\n\n### Character Access\n\n#### char_at\n\nGet Unicode codepoint at index.\n\n**Signature:**\n```hemlock\nstring.char_at(index: i32): rune\n```\n\n**Parameters:**\n- `index` - Codepoint index (0-based)\n\n**Returns:** Rune (Unicode codepoint)\n\n**Examples:**\n```hemlock\nlet s = \"hello\";\nlet ch = s.char_at(0);          // 'h'\nlet ch2 = s.char_at(1);         // 'e'\n\n// UTF-8 example\nlet emoji = \"\";\nlet ch3 = emoji.char_at(0);     // U+1F680 (rocket)\n```\n\n---\n\n#### chars\n\nConvert string to array of runes.\n\n**Signature:**\n```hemlock\nstring.chars(): array\n```\n\n**Returns:** Array of runes (codepoints)\n\n**Examples:**\n```hemlock\nlet s = \"hello\";\nlet chars = s.chars();          // ['h', 'e', 'l', 'l', 'o']\n\n// UTF-8 example\nlet text = \"Hi!\";\nlet chars2 = text.chars();      // ['H', 'i', '', '!']\n```\n\n---\n\n### Byte Access\n\n#### byte_at\n\nGet byte value at index.\n\n**Signature:**\n```hemlock\nstring.byte_at(index: i32): u8\n```\n\n**Parameters:**\n- `index` - Byte index (0-based, NOT codepoint index)\n\n**Returns:** Byte value (u8)\n\n**Examples:**\n```hemlock\nlet s = \"hello\";\nlet byte = s.byte_at(0);        // 104 (ASCII 'h')\nlet byte2 = s.byte_at(1);       // 101 (ASCII 'e')\n\n// UTF-8 example\nlet emoji = \"\";\nlet byte3 = emoji.byte_at(0);   // 240 (first UTF-8 byte)\n```\n\n---\n\n#### bytes\n\nConvert string to array of bytes.\n\n**Signature:**\n```hemlock\nstring.bytes(): array\n```\n\n**Returns:** Array of u8 bytes\n\n**Examples:**\n```hemlock\nlet s = \"hello\";\nlet bytes = s.bytes();          // [104, 101, 108, 108, 111]\n\n// UTF-8 example\nlet emoji = \"\";\nlet bytes2 = emoji.bytes();     // [240, 159, 154, 128] (4 UTF-8 bytes)\n```\n\n---\n\n#### to_bytes\n\nConvert string to buffer.\n\n**Signature:**\n```hemlock\nstring.to_bytes(): buffer\n```\n\n**Returns:** Buffer containing UTF-8 bytes\n\n**Examples:**\n```hemlock\nlet s = \"hello\";\nlet buf = s.to_bytes();\nprint(buf.length);              // 5\n\n// UTF-8 example\nlet emoji = \"\";\nlet buf2 = emoji.to_bytes();\nprint(buf2.length);             // 4\n```\n\n**Note:** This is a legacy method. Prefer `.bytes()` for most use cases.\n\n---\n\n### JSON Deserialization\n\n#### deserialize\n\nParse JSON string to value.\n\n**Signature:**\n```hemlock\nstring.deserialize(): any\n```\n\n**Returns:** Parsed value (object, array, number, string, bool, or null)\n\n**Examples:**\n```hemlock\nlet json = '{\"x\":10,\"y\":20}';\nlet obj = json.deserialize();\nprint(obj.x);                   // 10\nprint(obj.y);                   // 20\n\nlet arr_json = '[1,2,3]';\nlet arr = arr_json.deserialize();\nprint(arr[0]);                  // 1\n\nlet num_json = '42';\nlet num = num_json.deserialize();\nprint(num);                     // 42\n```\n\n**Supported Types:**\n- Objects: `{\"key\": value}`\n- Arrays: `[1, 2, 3]`\n- Numbers: `42`, `3.14`\n- Strings: `\"text\"`\n- Booleans: `true`, `false`\n- Null: `null`\n\n**See Also:** Object `.serialize()` method\n\n---\n\n## Method Chaining\n\nString methods can be chained for concise operations:\n\n**Examples:**\n```hemlock\nlet result = \"  Hello World  \"\n    .trim()\n    .to_lower()\n    .replace(\"world\", \"hemlock\");  // \"hello hemlock\"\n\nlet processed = \"foo,bar,baz\"\n    .split(\",\")\n    .join(\" | \");                  // \"foo | bar | baz\"\n\nlet cleaned = \"  HELLO  \"\n    .trim()\n    .to_lower();                   // \"hello\"\n```\n\n---\n\n## Complete Method Summary\n\n| Method         | Signature                                    | Returns   | Description                           |\n|----------------|----------------------------------------------|-----------|---------------------------------------|\n| `substr`       | `(start: i32, length: i32)`                  | `string`  | Extract substring by position/length  |\n| `slice`        | `(start: i32, end: i32)`                     | `string`  | Extract substring by range            |\n| `find`         | `(needle: string)`                           | `i32`     | Find first occurrence (-1 if not found)|\n| `contains`     | `(needle: string)`                           | `bool`    | Check if contains substring           |\n| `split`        | `(delimiter: string)`                        | `array`   | Split into array                      |\n| `trim`         | `()`                                         | `string`  | Remove whitespace                     |\n| `to_upper`     | `()`                                         | `string`  | Convert to uppercase                  |\n| `to_lower`     | `()`                                         | `string`  | Convert to lowercase                  |\n| `starts_with`  | `(prefix: string)`                           | `bool`    | Check if starts with prefix           |\n| `ends_with`    | `(suffix: string)`                           | `bool`    | Check if ends with suffix             |\n| `replace`      | `(old: string, new: string)`                 | `string`  | Replace first occurrence              |\n| `replace_all`  | `(old: string, new: string)`                 | `string`  | Replace all occurrences               |\n| `repeat`       | `(count: i32)`                               | `string`  | Repeat string n times                 |\n| `char_at`      | `(index: i32)`                               | `rune`    | Get codepoint at index                |\n| `byte_at`      | `(index: i32)`                               | `u8`      | Get byte at index                     |\n| `chars`        | `()`                                         | `array`   | Convert to array of runes             |\n| `bytes`        | `()`                                         | `array`   | Convert to array of bytes             |\n| `to_bytes`     | `()`                                         | `buffer`  | Convert to buffer (legacy)            |\n| `deserialize`  | `()`                                         | `any`     | Parse JSON string                     |\n\n---\n\n## See Also\n\n- [Type System](type-system.md) - String type details\n- [Array API](array-api.md) - Array methods for split() results\n- [Operators](operators.md) - String concatenation operator\n"}, "API Reference  Type System": {"id": "reference-type-system", "content": "# Type System Reference\n\nComplete reference for Hemlock's type system, including all primitive and composite types.\n\n---\n\n## Overview\n\nHemlock uses a **dynamic type system** with runtime type tags and optional type annotations. Every value has a runtime type, and type conversions follow explicit promotion rules.\n\n**Key Features:**\n- Runtime type checking\n- Optional type annotations\n- Automatic type inference for literals\n- Explicit type promotion rules\n- No implicit conversions that lose precision\n\n---\n\n## Primitive Types\n\n### Numeric Types\n\n#### Signed Integers\n\n| Type   | Size    | Range                                      | Alias     |\n|--------|---------|-------------------------------------------|-----------|\n| `i8`   | 1 byte  | -128 to 127                               | -         |\n| `i16`  | 2 bytes | -32,768 to 32,767                         | -         |\n| `i32`  | 4 bytes | -2,147,483,648 to 2,147,483,647           | `integer` |\n| `i64`  | 8 bytes | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 | - |\n\n**Examples:**\n```hemlock\nlet a: i8 = 127;\nlet b: i16 = 32000;\nlet c: i32 = 1000000;\nlet d: i64 = 9223372036854775807;\n\n// Type alias\nlet x: integer = 42;  // Same as i32\n```\n\n#### Unsigned Integers\n\n| Type   | Size    | Range                     | Alias  |\n|--------|---------|---------------------------|--------|\n| `u8`   | 1 byte  | 0 to 255                  | `byte` |\n| `u16`  | 2 bytes | 0 to 65,535               | -      |\n| `u32`  | 4 bytes | 0 to 4,294,967,295        | -      |\n| `u64`  | 8 bytes | 0 to 18,446,744,073,709,551,615 | - |\n\n**Examples:**\n```hemlock\nlet a: u8 = 255;\nlet b: u16 = 65535;\nlet c: u32 = 4294967295;\nlet d: u64 = 18446744073709551615;\n\n// Type alias\nlet byte_val: byte = 65;  // Same as u8\n```\n\n#### Floating Point\n\n| Type   | Size    | Precision      | Alias    |\n|--------|---------|----------------|----------|\n| `f32`  | 4 bytes | ~7 digits      | -        |\n| `f64`  | 8 bytes | ~15 digits     | `number` |\n\n**Examples:**\n```hemlock\nlet pi: f32 = 3.14159;\nlet precise: f64 = 3.14159265359;\n\n// Type alias\nlet x: number = 2.718;  // Same as f64\n```\n\n---\n\n### Integer Literal Inference\n\nInteger literals are automatically typed based on their value:\n\n**Rules:**\n- Values in i32 range (-2,147,483,648 to 2,147,483,647): infer as `i32`\n- Values outside i32 range but within i64 range: infer as `i64`\n- Use explicit type annotations for other types (i8, i16, u8, u16, u32, u64)\n\n**Examples:**\n```hemlock\nlet small = 42;                    // i32 (fits in i32)\nlet large = 5000000000;            // i64 (> i32 max)\nlet max_i64 = 9223372036854775807; // i64 (INT64_MAX)\nlet explicit: u32 = 100;           // u32 (type annotation overrides)\n```\n\n---\n\n### Boolean Type\n\n**Type:** `bool`\n\n**Values:** `true`, `false`\n\n**Size:** 1 byte (internally)\n\n**Examples:**\n```hemlock\nlet is_active: bool = true;\nlet done = false;\n\nif (is_active && !done) {\n    print(\"working\");\n}\n```\n\n---\n\n### Character Types\n\n#### Rune\n\n**Type:** `rune`\n\n**Description:** Unicode codepoint (U+0000 to U+10FFFF)\n\n**Size:** 4 bytes (32-bit value)\n\n**Range:** 0 to 0x10FFFF (1,114,111)\n\n**Literal Syntax:** Single quotes `'x'`\n\n**Examples:**\n```hemlock\n// ASCII\nlet a = 'A';\nlet digit = '0';\n\n// Multi-byte UTF-8\nlet rocket = '';      // U+1F680\nlet heart = '';        // U+2764\nlet chinese = '';     // U+4E2D\n\n// Escape sequences\nlet newline = '\\n';\nlet tab = '\\t';\nlet backslash = '\\\\';\nlet quote = '\\'';\nlet null = '\\0';\n\n// Unicode escapes\nlet emoji = '\\u{1F680}';   // Up to 6 hex digits\nlet max = '\\u{10FFFF}';    // Maximum codepoint\n```\n\n**Type Conversions:**\n```hemlock\n// Integer to rune\nlet code: rune = 65;        // 'A'\nlet r: rune = 128640;       // \n\n// Rune to integer\nlet value: i32 = 'Z';       // 90\n\n// Rune to string\nlet s: string = 'H';        // \"H\"\n\n// u8 to rune\nlet byte: u8 = 65;\nlet rune_val: rune = byte;  // 'A'\n```\n\n**See Also:** [String API](string-api.md) for string + rune concatenation\n\n---\n\n### String Type\n\n**Type:** `string`\n\n**Description:** UTF-8 encoded, mutable, heap-allocated text\n\n**Encoding:** UTF-8 (U+0000 to U+10FFFF)\n\n**Mutability:** Mutable (unlike most languages)\n\n**Properties:**\n- `.length` - Codepoint count (number of characters)\n- `.byte_length` - Byte count (UTF-8 encoding size)\n\n**Literal Syntax:** Double quotes `\"text\"`\n\n**Examples:**\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';             // Mutate (now \"Hello\")\nprint(s.length);        // 5 (codepoint count)\nprint(s.byte_length);   // 5 (UTF-8 bytes)\n\nlet emoji = \"\";\nprint(emoji.length);        // 1 (one codepoint)\nprint(emoji.byte_length);   // 4 (four UTF-8 bytes)\n```\n\n**Indexing:**\n```hemlock\nlet s = \"hello\";\nlet ch = s[0];          // Returns rune 'h'\ns[0] = 'H';             // Set with rune\n```\n\n**See Also:** [String API](string-api.md) for complete method reference\n\n---\n\n### Null Type\n\n**Type:** `null`\n\n**Description:** The null value (absence of value)\n\n**Size:** 8 bytes (internally)\n\n**Value:** `null`\n\n**Examples:**\n```hemlock\nlet x = null;\nlet y: i32 = null;  // ERROR: type mismatch\n\nif (x == null) {\n    print(\"x is null\");\n}\n```\n\n---\n\n## Composite Types\n\n### Array Type\n\n**Type:** `array`\n\n**Description:** Dynamic, heap-allocated, mixed-type array\n\n**Properties:**\n- `.length` - Number of elements\n\n**Zero-indexed:** Yes\n\n**Literal Syntax:** `[elem1, elem2, ...]`\n\n**Examples:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr[0]);         // 1\nprint(arr.length);     // 5\n\n// Mixed types\nlet mixed = [1, \"hello\", true, null];\n```\n\n**See Also:** [Array API](array-api.md) for complete method reference\n\n---\n\n### Object Type\n\n**Type:** `object`\n\n**Description:** JavaScript-style object with dynamic fields\n\n**Literal Syntax:** `{ field: value, ... }`\n\n**Examples:**\n```hemlock\nlet person = { name: \"Alice\", age: 30 };\nprint(person.name);  // \"Alice\"\n\n// Add field dynamically\nperson.email = \"alice@example.com\";\n```\n\n**Type Definitions:**\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: bool,  // Optional field\n}\n\nlet p: Person = { name: \"Bob\", age: 25 };\nprint(typeof(p));  // \"Person\"\n```\n\n---\n\n### Pointer Types\n\n#### Raw Pointer (ptr)\n\n**Type:** `ptr`\n\n**Description:** Raw memory address (unsafe)\n\n**Size:** 8 bytes\n\n**Bounds Checking:** None\n\n**Examples:**\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);\n```\n\n#### Buffer (buffer)\n\n**Type:** `buffer`\n\n**Description:** Safe pointer wrapper with bounds checking\n\n**Structure:** Pointer + length + capacity\n\n**Properties:**\n- `.length` - Buffer size\n- `.capacity` - Allocated capacity\n\n**Examples:**\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // Bounds checked\nprint(b.length);        // 64\nfree(b);\n```\n\n**See Also:** [Memory API](memory-api.md) for allocation functions\n\n---\n\n## Special Types\n\n### File Type\n\n**Type:** `file`\n\n**Description:** File handle for I/O operations\n\n**Properties:**\n- `.path` - File path (string)\n- `.mode` - Open mode (string)\n- `.closed` - Whether file is closed (bool)\n\n**See Also:** [File API](file-api.md)\n\n---\n\n### Task Type\n\n**Type:** `task`\n\n**Description:** Handle for concurrent task\n\n**See Also:** [Concurrency API](concurrency-api.md)\n\n---\n\n### Channel Type\n\n**Type:** `channel`\n\n**Description:** Thread-safe communication channel\n\n**See Also:** [Concurrency API](concurrency-api.md)\n\n---\n\n### Function Type\n\n**Type:** `function`\n\n**Description:** First-class function value\n\n**Examples:**\n```hemlock\nfn add(a, b) {\n    return a + b;\n}\n\nlet multiply = fn(x, y) {\n    return x * y;\n};\n\nprint(typeof(add));      // \"function\"\nprint(typeof(multiply)); // \"function\"\n```\n\n---\n\n### Void Type\n\n**Type:** `void`\n\n**Description:** Absence of return value (internal use)\n\n---\n\n## Type Promotion Rules\n\nWhen mixing types in operations, Hemlock promotes to the \"higher\" type:\n\n**Promotion Hierarchy:**\n```\nf64 (highest precision)\n \nf32\n \nu64\n \ni64\n \nu32\n \ni32\n \nu16\n \ni16\n \nu8\n \ni8 (lowest)\n```\n\n**Rules:**\n1. Float always wins over integer\n2. Larger size wins within same category (int/uint/float)\n3. Both operands are promoted to result type\n\n**Examples:**\n```hemlock\n// Size promotion\nu8 + i32     i32    // Larger size wins\ni32 + i64    i64    // Larger size wins\nu32 + u64    u64    // Larger size wins\n\n// Float promotion\ni32 + f32    f32    // Float always wins\ni64 + f64    f64    // Float always wins\ni8 + f64     f64    // Float + largest wins\n```\n\n---\n\n## Range Checking\n\nType annotations enforce range checks at assignment:\n\n**Valid Assignments:**\n```hemlock\nlet x: u8 = 255;             // OK\nlet y: i8 = 127;             // OK\nlet a: i64 = 2147483647;     // OK\nlet b: u64 = 4294967295;     // OK\n```\n\n**Invalid Assignments (Runtime Error):**\n```hemlock\nlet x: u8 = 256;             // ERROR: out of range\nlet y: i8 = 128;             // ERROR: max is 127\nlet z: u64 = -1;             // ERROR: u64 cannot be negative\n```\n\n---\n\n## Type Introspection\n\n### typeof(value)\n\nReturns the type name as a string.\n\n**Signature:**\n```hemlock\ntypeof(value: any): string\n```\n\n**Returns:**\n- Primitive types: `\"i8\"`, `\"i16\"`, `\"i32\"`, `\"i64\"`, `\"u8\"`, `\"u16\"`, `\"u32\"`, `\"u64\"`, `\"f32\"`, `\"f64\"`, `\"bool\"`, `\"string\"`, `\"rune\"`, `\"null\"`\n- Composite types: `\"array\"`, `\"object\"`, `\"ptr\"`, `\"buffer\"`, `\"function\"`\n- Special types: `\"file\"`, `\"task\"`, `\"channel\"`\n- Typed objects: Custom type name (e.g., `\"Person\"`)\n\n**Examples:**\n```hemlock\nprint(typeof(42));              // \"i32\"\nprint(typeof(3.14));            // \"f64\"\nprint(typeof(\"hello\"));         // \"string\"\nprint(typeof('A'));             // \"rune\"\nprint(typeof(true));            // \"bool\"\nprint(typeof([1, 2, 3]));       // \"array\"\nprint(typeof({ x: 10 }));       // \"object\"\n\ndefine Person { name: string }\nlet p: Person = { name: \"Alice\" };\nprint(typeof(p));               // \"Person\"\n```\n\n**See Also:** [Built-in Functions](builtins.md#typeof)\n\n---\n\n## Type Conversions\n\n### Implicit Conversions\n\nHemlock performs implicit type conversions in arithmetic operations following the type promotion rules.\n\n**Examples:**\n```hemlock\nlet a: u8 = 10;\nlet b: i32 = 20;\nlet result = a + b;     // result is i32 (promoted)\n```\n\n### Explicit Conversions\n\nUse type annotations for explicit conversions:\n\n**Examples:**\n```hemlock\n// Integer to float\nlet i: i32 = 42;\nlet f: f64 = i;         // 42.0\n\n// Float to integer (truncates)\nlet x: f64 = 3.14;\nlet y: i32 = x;         // 3\n\n// Integer to rune\nlet code: rune = 65;    // 'A'\n\n// Rune to integer\nlet value: i32 = 'Z';   // 90\n\n// Rune to string\nlet s: string = 'H';    // \"H\"\n```\n\n---\n\n## Type Aliases\n\nHemlock provides type aliases for common types:\n\n| Alias     | Actual Type | Usage                    |\n|-----------|-------------|--------------------------|\n| `integer` | `i32`       | General-purpose integers |\n| `number`  | `f64`       | General-purpose floats   |\n| `byte`    | `u8`        | Byte values              |\n\n**Examples:**\n```hemlock\nlet count: integer = 100;       // Same as i32\nlet price: number = 19.99;      // Same as f64\nlet b: byte = 255;              // Same as u8\n```\n\n---\n\n## Summary Table\n\n| Type       | Size     | Mutable | Heap-allocated | Description                    |\n|------------|----------|---------|----------------|--------------------------------|\n| `i8`-`i64` | 1-8 bytes| No      | No             | Signed integers                |\n| `u8`-`u64` | 1-8 bytes| No      | No             | Unsigned integers              |\n| `f32`      | 4 bytes  | No      | No             | Single-precision float         |\n| `f64`      | 8 bytes  | No      | No             | Double-precision float         |\n| `bool`     | 1 byte   | No      | No             | Boolean                        |\n| `rune`     | 4 bytes  | No      | No             | Unicode codepoint              |\n| `string`   | Variable | Yes     | Yes            | UTF-8 text                     |\n| `array`    | Variable | Yes     | Yes            | Dynamic array                  |\n| `object`   | Variable | Yes     | Yes            | Dynamic object                 |\n| `ptr`      | 8 bytes  | No      | No             | Raw pointer                    |\n| `buffer`   | Variable | Yes     | Yes            | Safe pointer wrapper           |\n| `file`     | Opaque   | Yes     | Yes            | File handle                    |\n| `task`     | Opaque   | No      | Yes            | Concurrent task handle         |\n| `channel`  | Opaque   | Yes     | Yes            | Thread-safe channel            |\n| `function` | Opaque   | No      | Yes            | Function value                 |\n| `null`     | 8 bytes  | No      | No             | Null value                     |\n\n---\n\n## See Also\n\n- [Operators Reference](operators.md) - Type behavior in operations\n- [Built-in Functions](builtins.md) - Type introspection and conversion\n- [String API](string-api.md) - String type methods\n- [Array API](array-api.md) - Array type methods\n- [Memory API](memory-api.md) - Pointer and buffer operations\n"}, "Design & Philosophy  Implementation": {"id": "design-implementation", "content": "# Hemlock Implementation Details\n\nThis document describes the technical implementation of the Hemlock language, including project structure, compilation pipeline, runtime architecture, and design decisions.\n\n---\n\n## Table of Contents\n\n- [Project Structure](#project-structure)\n- [Compilation Pipeline](#compilation-pipeline)\n- [Modular Interpreter Design](#modular-interpreter-design)\n- [Runtime Architecture](#runtime-architecture)\n- [Value Representation](#value-representation)\n- [Type System Implementation](#type-system-implementation)\n- [Memory Management](#memory-management)\n- [Concurrency Model](#concurrency-model)\n- [Future Plans](#future-plans)\n\n---\n\n## Project Structure\n\n```\nhemlock/\n include/              # Public headers\n    ast.h            # AST node definitions\n    lexer.h          # Tokenization API\n    parser.h         # Parsing API\n    interpreter.h    # Interpreter public API\n src/                  # Implementation\n    ast.c             # AST node constructors and cleanup\n    lexer.c           # Tokenization implementation\n    parser.c          # Parsing (tokens  AST)\n    main.c            # CLI entry point, REPL\n    interpreter/      # Interpreter subsystem (modular)\n        internal.h        # Internal API shared between modules\n        environment.c     # Variable scoping (121 lines)\n        values.c          # Value constructors, data structures (394 lines)\n        types.c           # Type system, conversions, duck typing (440 lines)\n        builtins.c        # Builtin functions, registration (955 lines)\n        io.c              # File I/O, serialization (449 lines)\n        ffi.c             # Foreign function interface (libffi)\n        runtime.c         # eval_expr, eval_stmt, control flow (865 lines)\n tests/                # Test suite\n    primitives/       # Type system tests\n    conversions/      # Type conversion tests\n    memory/           # Pointer/buffer tests\n    strings/          # String operation tests\n    control/          # Control flow tests\n    functions/        # Function and closure tests\n    objects/          # Object, method, serialization tests\n    arrays/           # Array operations tests\n    loops/            # For, while, break, continue tests\n    exceptions/       # Try/catch/finally/throw tests\n    io/               # File I/O tests\n    async/            # Async/concurrency tests\n    ffi/              # FFI tests\n    args/             # Command-line argument tests\n    run_tests.sh      # Test runner\n examples/             # Example programs\n docs/                 # Documentation\n```\n\n### Directory Organization\n\n**`include/`** - Public API headers that define the interface between components:\n- Clean separation between lexer, parser, AST, and interpreter\n- Forward declarations to minimize dependencies\n- Public API for embedding Hemlock in other programs\n\n**`src/`** - Implementation files:\n- Top-level files handle lexing, parsing, AST management\n- `main.c` provides CLI and REPL\n- Interpreter is modularized into separate subsystems\n\n**`src/interpreter/`** - Modular interpreter implementation:\n- Each module has a single, clear responsibility\n- Internal API defined in `internal.h` for inter-module communication\n- Modules can be compiled independently for faster builds\n\n**`tests/`** - Comprehensive test suite:\n- Organized by feature area\n- Each directory contains focused test cases\n- `run_tests.sh` orchestrates test execution\n\n---\n\n## Compilation Pipeline\n\nHemlock uses a traditional compilation pipeline with distinct phases:\n\n### Phase 1: Lexical Analysis (Lexer)\n\n**Input:** Source code text\n**Output:** Token stream\n**Implementation:** `src/lexer.c`\n\n```\nSource: \"let x = 42;\"\n   \nTokens: [LET, IDENTIFIER(\"x\"), EQUALS, INTEGER(42), SEMICOLON]\n```\n\n**Key features:**\n- Recognizes keywords, identifiers, literals, operators, punctuation\n- Handles UTF-8 string literals and rune literals\n- Reports line numbers for error messages\n- Single-pass, no backtracking\n\n### Phase 2: Syntax Analysis (Parser)\n\n**Input:** Token stream\n**Output:** Abstract Syntax Tree (AST)\n**Implementation:** `src/parser.c`\n\n```\nTokens: [LET, IDENTIFIER(\"x\"), EQUALS, INTEGER(42), SEMICOLON]\n   \nAST: LetStmt {\n    name: \"x\",\n    type: null,\n    value: IntLiteral(42)\n}\n```\n\n**Key features:**\n- Recursive descent parser\n- Builds tree representation of program structure\n- Handles operator precedence\n- Validates syntax (braces, semicolons, etc.)\n- No semantic analysis yet (done at runtime)\n\n**Operator Precedence (lowest to highest):**\n1. Assignment: `=`\n2. Logical OR: `||`\n3. Logical AND: `&&`\n4. Bitwise OR: `|`\n5. Bitwise XOR: `^`\n6. Bitwise AND: `&`\n7. Equality: `==`, `!=`\n8. Comparison: `<`, `>`, `<=`, `>=`\n9. Bitwise shifts: `<<`, `>>`\n10. Addition/Subtraction: `+`, `-`\n11. Multiplication/Division/Modulo: `*`, `/`, `%`\n12. Unary: `!`, `-`, `~`\n13. Call/Index/Member: `()`, `[]`, `.`\n\n### Phase 3: Interpretation (Tree-Walking)\n\n**Input:** AST\n**Output:** Program execution\n**Implementation:** `src/interpreter/runtime.c`\n\n```\nAST: LetStmt { ... }\n   \nExecution: Evaluates AST nodes recursively\n   \nResult: Variable x created with value 42\n```\n\n**Key features:**\n- Direct AST traversal (tree-walking interpreter)\n- Dynamic type checking at runtime\n- Environment-based variable storage\n- No optimization passes (yet)\n\n---\n\n## Modular Interpreter Design\n\nThe interpreter is split into focused modules for maintainability and scalability.\n\n### Module Responsibilities\n\n#### 1. Environment (`environment.c`) - 121 lines\n\n**Purpose:** Variable scoping and name resolution\n\n**Key functions:**\n- `env_create()` - Create new environment with optional parent\n- `env_define()` - Define new variable in current scope\n- `env_get()` - Lookup variable in current or parent scopes\n- `env_set()` - Update existing variable value\n- `env_free()` - Free environment and all variables\n\n**Design:**\n- Linked scopes (each environment has pointer to parent)\n- HashMap for fast variable lookup\n- Supports lexical scoping for closures\n\n#### 2. Values (`values.c`) - 394 lines\n\n**Purpose:** Value constructors and data structure management\n\n**Key functions:**\n- `value_create_*()` - Constructors for each value type\n- `value_copy()` - Deep/shallow copying logic\n- `value_free()` - Cleanup and memory deallocation\n- `value_to_string()` - String representation for printing\n\n**Data structures:**\n- Objects (dynamic field arrays)\n- Arrays (dynamic resizing)\n- Buffers (ptr + length + capacity)\n- Closures (function + captured environment)\n- Tasks and Channels (concurrency primitives)\n\n#### 3. Types (`types.c`) - 440 lines\n\n**Purpose:** Type system, conversions, and duck typing\n\n**Key functions:**\n- `type_check()` - Runtime type validation\n- `type_convert()` - Implicit type conversions/promotions\n- `duck_type_check()` - Structural type checking for objects\n- `type_name()` - Get printable type name\n\n**Features:**\n- Type promotion hierarchy (i8  i16  i32  i64  f32  f64)\n- Range checking for numeric types\n- Duck typing for object type definitions\n- Optional field defaults\n\n#### 4. Builtins (`builtins.c`) - 955 lines\n\n**Purpose:** Built-in functions and global registration\n\n**Key functions:**\n- `register_builtins()` - Register all built-in functions and constants\n- Built-in function implementations (print, typeof, alloc, free, etc.)\n- Signal handling functions\n- Command execution (exec)\n\n**Categories of builtins:**\n- I/O: print, open, read_file, write_file\n- Memory: alloc, free, memset, memcpy, realloc\n- Types: typeof, assert\n- Concurrency: spawn, join, detach, channel\n- System: exec, signal, raise, panic\n- FFI: dlopen, dlsym, dlcall, dlclose\n\n#### 5. I/O (`io.c`) - 449 lines\n\n**Purpose:** File I/O and JSON serialization\n\n**Key functions:**\n- File object methods (read, write, seek, tell, close)\n- JSON serialization/deserialization\n- Circular reference detection\n\n**Features:**\n- File object with properties (path, mode, closed)\n- UTF-8 aware text I/O\n- Binary I/O support\n- JSON round-tripping for objects and arrays\n\n#### 6. FFI (`ffi.c`) - Foreign Function Interface\n\n**Purpose:** Calling C functions from shared libraries\n\n**Key functions:**\n- `dlopen()` - Load shared library\n- `dlsym()` - Get function pointer by name\n- `dlcall()` - Call C function with type conversion\n- `dlclose()` - Unload library\n\n**Features:**\n- Integration with libffi for dynamic function calls\n- Automatic type conversion (Hemlock  C types)\n- Support for all primitive types\n- Pointer and buffer support\n\n#### 7. Runtime (`runtime.c`) - 865 lines\n\n**Purpose:** Expression evaluation and statement execution\n\n**Key functions:**\n- `eval_expr()` - Evaluate expressions (recursive)\n- `eval_stmt()` - Execute statements\n- Control flow handling (if, while, for, switch, etc.)\n- Exception handling (try/catch/finally/throw)\n\n**Features:**\n- Recursive expression evaluation\n- Short-circuit boolean evaluation\n- Method call detection and `self` binding\n- Exception propagation\n- Break/continue/return handling\n\n### Benefits of Modular Design\n\n**1. Separation of Concerns**\n- Each module has one clear responsibility\n- Easy to find where features are implemented\n- Reduces cognitive load when making changes\n\n**2. Faster Incremental Builds**\n- Only modified modules need recompilation\n- Parallel compilation possible\n- Shorter iteration times during development\n\n**3. Easier Testing and Debugging**\n- Modules can be tested in isolation\n- Bugs are localized to specific subsystems\n- Mock implementations possible for testing\n\n**4. Scalability**\n- New features can be added to appropriate modules\n- Modules can be refactored independently\n- Code size per file stays manageable\n\n**5. Code Organization**\n- Logical grouping of related functionality\n- Clear dependency graph\n- Easier onboarding for new contributors\n\n---\n\n## Runtime Architecture\n\n### Value Representation\n\nAll values in Hemlock are represented by the `Value` struct using a tagged union:\n\n```c\ntypedef struct Value {\n    ValueType type;  // Runtime type tag\n    union {\n        int32_t i32_value;\n        int64_t i64_value;\n        uint8_t u8_value;\n        uint32_t u32_value;\n        uint64_t u64_value;\n        float f32_value;\n        double f64_value;\n        bool bool_value;\n        char *string_value;\n        uint32_t rune_value;\n        void *ptr_value;\n        Buffer *buffer_value;\n        Array *array_value;\n        Object *object_value;\n        Function *function_value;\n        File *file_value;\n        Task *task_value;\n        Channel *channel_value;\n    };\n} Value;\n```\n\n**Design decisions:**\n- **Tagged union** for type safety while maintaining flexibility\n- **Runtime type tags** enable dynamic typing with type checking\n- **Direct value storage** for primitives (no boxing)\n- **Pointer storage** for heap-allocated types (strings, objects, arrays)\n\n### Memory Layout Examples\n\n**Integer (i32):**\n```\nValue {\n    type: TYPE_I32,\n    i32_value: 42\n}\n```\n- Total size: ~16 bytes (8-byte tag + 8-byte union)\n- Stack allocated\n- No heap allocation needed\n\n**String:**\n```\nValue {\n    type: TYPE_STRING,\n    string_value: 0x7f8a4c000000  // Pointer to heap\n}\n\nHeap: \"hello\\0\" (6 bytes, null-terminated UTF-8)\n```\n- Value is 16 bytes on stack\n- String data is heap-allocated\n- Must be freed manually\n\n**Object:**\n```\nValue {\n    type: TYPE_OBJECT,\n    object_value: 0x7f8a4c001000  // Pointer to heap\n}\n\nHeap: Object {\n    type_name: \"Person\",\n    fields: [\n        { name: \"name\", value: Value{TYPE_STRING, \"Alice\"} },\n        { name: \"age\", value: Value{TYPE_I32, 30} }\n    ],\n    field_count: 2,\n    capacity: 4\n}\n```\n- Object structure on heap\n- Fields stored in dynamic array\n- Field values are embedded Value structs\n\n### Environment Implementation\n\nVariables are stored in environment chains:\n\n```c\ntypedef struct Environment {\n    HashMap *bindings;           // name  Value\n    struct Environment *parent;  // Lexical parent scope\n} Environment;\n```\n\n**Scope chain example:**\n```\nGlobal Scope: { print: <builtin>, args: <array> }\n    \nFunction Scope: { x: 10, y: 20 }\n    \nBlock Scope: { i: 0 }\n```\n\n**Lookup algorithm:**\n1. Check current environment's hashmap\n2. If not found, check parent environment\n3. Repeat until found or reach global scope\n4. Error if not found in any scope\n\n---\n\n## Type System Implementation\n\n### Type Checking Strategy\n\nHemlock uses **runtime type checking** with **optional type annotations**:\n\n```hemlock\nlet x = 42;           // No type check, infers i32\nlet y: u8 = 255;      // Runtime check: value must fit in u8\nlet z: i32 = x + y;   // Runtime check + type promotion\n```\n\n**Implementation flow:**\n1. **Literal inference** - Lexer/parser determine initial type from literal\n2. **Type annotation check** - If annotation present, validate at assignment\n3. **Promotion** - Binary operations promote to common type\n4. **Conversion** - Explicit conversions happen on demand\n\n### Type Promotion Implementation\n\nType promotion follows a fixed hierarchy:\n\n```c\n// Simplified promotion logic\nValueType promote_types(ValueType a, ValueType b) {\n    // Floats always win\n    if (a == TYPE_F64 || b == TYPE_F64) return TYPE_F64;\n    if (a == TYPE_F32 || b == TYPE_F32) return TYPE_F32;\n\n    // Larger integer types win\n    int rank_a = get_type_rank(a);\n    int rank_b = get_type_rank(b);\n    return (rank_a > rank_b) ? a : b;\n}\n```\n\n**Type ranks:**\n- i8: 0\n- u8: 1\n- i16: 2\n- u16: 3\n- i32: 4\n- u32: 5\n- i64: 6\n- u64: 7\n- f32: 8\n- f64: 9\n\n### Duck Typing Implementation\n\nObject type checking uses structural comparison:\n\n```c\nbool duck_type_check(Object *obj, TypeDef *type_def) {\n    // Check all required fields\n    for (each field in type_def) {\n        if (!object_has_field(obj, field.name)) {\n            return false;  // Missing field\n        }\n\n        Value *field_value = object_get_field(obj, field.name);\n        if (!type_matches(field_value, field.type)) {\n            return false;  // Wrong type\n        }\n    }\n\n    return true;  // All required fields present and correct type\n}\n```\n\n**Duck typing allows:**\n- Extra fields in objects (ignored)\n- Substructural typing (object can have more than required)\n- Type name assignment after validation\n\n---\n\n## Memory Management\n\n### Allocation Strategy\n\nHemlock uses **manual memory management** with two allocation primitives:\n\n**1. Raw pointers (`ptr`):**\n```c\nvoid *alloc(size_t bytes) {\n    void *ptr = malloc(bytes);\n    if (!ptr) {\n        fprintf(stderr, \"Out of memory\\n\");\n        exit(1);\n    }\n    return ptr;\n}\n```\n- Direct malloc/free\n- No tracking\n- User responsibility to free\n\n**2. Buffers (`buffer`):**\n```c\ntypedef struct Buffer {\n    void *data;\n    size_t length;\n    size_t capacity;\n} Buffer;\n\nBuffer *create_buffer(size_t size) {\n    Buffer *buf = malloc(sizeof(Buffer));\n    buf->data = malloc(size);\n    buf->length = size;\n    buf->capacity = size;\n    return buf;\n}\n```\n- Tracks size and capacity\n- Bounds checking on access\n- Still requires manual free\n\n### Heap-Allocated Types\n\n**Strings:**\n- UTF-8 byte array on heap\n- Null-terminated for C interop\n- Mutable (can modify in place)\n- No refcounting (manual free required)\n\n**Objects:**\n- Dynamic field array\n- Field names and values on heap\n- No automatic cleanup\n- Circular references possible (user must avoid)\n\n**Arrays:**\n- Dynamic capacity doubling growth\n- Elements are embedded Value structs\n- Automatic reallocation on growth\n- Manual free required\n\n**Closures:**\n- Captures environment by reference\n- Environment is heap-allocated\n- **Known leak:** Closure environments never freed (to be fixed in v0.2)\n\n### Memory Leak Patterns\n\n**Current known leaks:**\n1. Closure environments (captured variables)\n2. Detached task structures (Task metadata)\n3. Objects with circular references\n4. Unclosed files (file descriptor leak)\n\n**Future improvements (v0.2):**\n- Reference counting for objects and closures\n- Weak references for circular structures\n- Automatic file descriptor cleanup (defer/RAII)\n- Memory leak detection in debug builds\n\n---\n\n## Concurrency Model\n\n### Threading Architecture\n\nHemlock uses **1:1 threading** with POSIX threads (pthreads):\n\n```\nUser Task          OS Thread          CPU Core\n---------          ---------          --------\nspawn(f1) ------>  pthread_create --> Core 0\nspawn(f2) ------>  pthread_create --> Core 1\nspawn(f3) ------>  pthread_create --> Core 2\n```\n\n**Key characteristics:**\n- Each `spawn()` creates a new pthread\n- Kernel schedules threads across cores\n- True parallel execution (no GIL)\n- Pre-emptive multitasking\n\n### Task Implementation\n\n```c\ntypedef struct Task {\n    pthread_t thread;        // OS thread handle\n    Value result;            // Return value\n    char *error;             // Exception message (if thrown)\n    pthread_mutex_t lock;    // Protects state\n    TaskState state;         // RUNNING, FINISHED, ERROR\n} Task;\n```\n\n**Task lifecycle:**\n1. `spawn(func, args)`  Create Task, start pthread\n2. Thread runs function with arguments\n3. On return: Store result, set state to FINISHED\n4. On exception: Store error message, set state to ERROR\n5. `join(task)`  Wait for thread, return result or throw exception\n\n### Channel Implementation\n\n```c\ntypedef struct Channel {\n    void **buffer;           // Circular buffer of Value*\n    size_t capacity;         // Maximum buffered items\n    size_t count;            // Current items in buffer\n    size_t read_index;       // Next read position\n    size_t write_index;      // Next write position\n    bool closed;             // Channel closed flag\n    pthread_mutex_t lock;    // Protects buffer\n    pthread_cond_t not_full; // Signal when space available\n    pthread_cond_t not_empty;// Signal when data available\n} Channel;\n```\n\n**Send operation:**\n1. Lock mutex\n2. Wait if buffer full (cond_wait on not_full)\n3. Write value to buffer[write_index]\n4. Increment write_index (circular)\n5. Signal not_empty\n6. Unlock mutex\n\n**Receive operation:**\n1. Lock mutex\n2. Wait if buffer empty (cond_wait on not_empty)\n3. Read value from buffer[read_index]\n4. Increment read_index (circular)\n5. Signal not_full\n6. Unlock mutex\n\n**Synchronization guarantees:**\n- Thread-safe send/recv (protected by mutex)\n- Blocking semantics (producer waits if full, consumer waits if empty)\n- Ordered delivery (FIFO within a channel)\n\n---\n\n## Future Plans\n\n### v0.2 - Compiler Backend\n\n**Goal:** Compile Hemlock to C code for better performance\n\n**Planned architecture:**\n```\nHemlock Source  Lexer  Parser  AST  C Code Generator  C Compiler  Binary\n```\n\n**Benefits:**\n- Significant performance improvement\n- Better optimization (leverage C compiler)\n- Static analysis opportunities\n- Still keep runtime library for dynamic features\n\n**Challenges:**\n- Dynamic typing requires runtime support\n- Closure capture needs careful codegen\n- Exception handling in C (setjmp/longjmp)\n- FFI integration with generated code\n\n### v0.3 - Advanced Features\n\n**Potential additions:**\n- Generics/templates\n- Pattern matching\n- More comprehensive standard library\n- Module system\n- Package manager integration\n\n### Long-term Optimizations\n\n**Possible improvements:**\n- Reference counting for automatic memory management (opt-in)\n- Escape analysis for stack allocation\n- Inline caching for method calls\n- JIT compilation for hot code paths\n- Work-stealing scheduler for better concurrency\n\n---\n\n## Implementation Guidelines\n\n### Adding New Features\n\nWhen implementing new features, follow these guidelines:\n\n**1. Choose the right module:**\n- New value types  `values.c`\n- Type conversions  `types.c`\n- Built-in functions  `builtins.c`\n- I/O operations  `io.c`\n- Control flow  `runtime.c`\n\n**2. Update all layers:**\n- Add AST node types if needed (`ast.h`, `ast.c`)\n- Add lexer tokens if needed (`lexer.c`)\n- Add parser rules (`parser.c`)\n- Implement runtime behavior (`runtime.c` or appropriate module)\n- Add tests (`tests/`)\n\n**3. Maintain consistency:**\n- Follow existing code style\n- Use consistent naming conventions\n- Document public API in headers\n- Keep error messages clear and consistent\n\n**4. Test thoroughly:**\n- Add test cases before implementing\n- Test success and error paths\n- Test edge cases\n- Verify no memory leaks (valgrind)\n\n### Performance Considerations\n\n**Current bottlenecks:**\n- HashMap lookups for variable access\n- Recursive function calls (no TCO)\n- String concatenation (allocates new string each time)\n- Type checking overhead on every operation\n\n**Optimization opportunities:**\n- Cache variable locations (inline caching)\n- Tail call optimization\n- String builder for concatenation\n- Type inference to skip runtime checks\n\n### Debugging Tips\n\n**Useful tools:**\n- `valgrind` - Memory leak detection\n- `gdb` - Debugging crashes\n- `-g` flag - Debug symbols\n- `printf` debugging - Simple but effective\n\n**Common issues:**\n- Segfault  Null pointer dereference (check return values)\n- Memory leak  Missing free() call (check value_free paths)\n- Type error  Check type_convert() and type_check() logic\n- Crash in threads  Race condition (check mutex usage)\n\n---\n\n## Conclusion\n\nHemlock's implementation prioritizes:\n- **Modularity** - Clean separation of concerns\n- **Simplicity** - Straightforward implementation\n- **Explicitness** - No hidden magic\n- **Maintainability** - Easy to understand and modify\n\nThe current tree-walking interpreter is intentionally simple to facilitate rapid feature development and experimentation. Future compiler backend will improve performance while maintaining the same semantics.\n"}, "Design & Philosophy  Philosophy": {"id": "design-philosophy", "content": "# Hemlock Language Design Philosophy\n\n> \"A small, unsafe language for writing unsafe things safely.\"\n\nThis document captures the core design principles and philosophy of Hemlock. Read this first before making any changes or additions to the language.\n\n---\n\n## Table of Contents\n\n- [Core Identity](#core-identity)\n- [Design Principles](#design-principles)\n- [Philosophy on Safety](#philosophy-on-safety)\n- [What NOT to Add](#what-not-to-add)\n- [Future Considerations](#future-considerations)\n- [Final Thoughts](#final-thoughts)\n\n---\n\n## Core Identity\n\nHemlock is a **systems scripting language** that embraces manual memory management and explicit control. It's designed for programmers who want:\n\n- The power of C\n- The ergonomics of modern scripting languages\n- Structured async concurrency built-in\n- No hidden behavior or magic\n\n### What Hemlock IS NOT\n\n- **Memory-safe** (dangling pointers are your responsibility)\n- **A replacement for Rust, Go, or Lua**\n- **A language that hides complexity from you**\n\n### What Hemlock IS\n\n- **Explicit over implicit, always**\n- **Educational and experimental**\n- **A \"C scripting layer\" for systems work**\n- **Honest about tradeoffs**\n\n---\n\n## Design Principles\n\n### 1. Explicit Over Implicit\n\nHemlock favors explicitness in all language constructs. There should be no surprises, no magic, and no hidden behavior.\n\n**Bad (implicit):**\n```hemlock\nlet x = 5  // Missing semicolon - should error\n```\n\n**Good (explicit):**\n```hemlock\nlet x = 5;\nfree(ptr);  // You allocated it, you free it\n```\n\n**Key aspects:**\n- Semicolons are mandatory (no automatic semicolon insertion)\n- No garbage collection\n- Manual memory management (alloc/free)\n- Type annotations are optional but checked at runtime\n- No automatic resource cleanup (no RAII, no defer yet)\n\n### 2. Dynamic by Default, Typed by Choice\n\nEvery value has a runtime type tag, but the system is designed to be flexible while still catching errors.\n\n**Type inference:**\n- Small integers (fits in i32): `42`  `i32`\n- Large integers (> i32 range): `9223372036854775807`  `i64`\n- Floats: `3.14`  `f64`\n\n**Explicit typing when needed:**\n```hemlock\nlet x = 42;              // i32 inferred (small value)\nlet y: u8 = 255;         // explicit u8\nlet z = x + y;           // promotes to i32\nlet big = 5000000000;    // i64 inferred (> i32 max)\n```\n\n**Type promotion rules** follow a clear hierarchy from smallest to largest, with floats always winning over integers.\n\n### 3. Unsafe is a Feature, Not a Bug\n\nHemlock doesn't try to prevent all errors. Instead, it gives you the tools to be safe while allowing you to opt into unsafe behavior when needed.\n\n**Examples of intentional unsafety:**\n- Pointer arithmetic can overflow (user's responsibility)\n- No bounds checking on raw `ptr` (use `buffer` if you want safety)\n- Double-free crashes are allowed (manual memory management)\n- Type system prevents accidents but allows footguns when needed\n\n```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // Way past allocation - allowed but dangerous\n```\n\n**The philosophy:** The type system should prevent *accidents* but allow *intentional* unsafe operations.\n\n### 4. Structured Concurrency First-Class\n\nConcurrency is not an afterthought in Hemlock. It's built into the language from the ground up.\n\n**Key features:**\n- `async`/`await` built into the language\n- Channels for communication\n- `spawn`/`join`/`detach` for task management\n- No raw threads, no locks - structured only\n- True multi-threaded parallelism using POSIX threads\n\n**Not an event loop or green threads** - Hemlock uses real OS threads for true parallelism across multiple CPU cores.\n\n### 5. C-like Syntax, Low Ceremony\n\nHemlock should feel familiar to systems programmers while reducing boilerplate.\n\n**Design choices:**\n- `{}` blocks always, no optional braces\n- Operators match C: `+`, `-`, `*`, `/`, `&&`, `||`, `!`\n- Type syntax matches Rust/TypeScript: `let x: type = value;`\n- Functions are first-class values\n- Minimal keywords and special forms\n\n---\n\n## Philosophy on Safety\n\n**Hemlock's take on safety:**\n\n> \"We give you the tools to be safe (`buffer`, type annotations, bounds checking) but we don't force you to use them (`ptr`, manual memory, unsafe operations).\n>\n> The default should guide toward safety, but the escape hatch should always be available.\"\n\n### Safety Tools Provided\n\n**1. Safe buffer type:**\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // bounds checked\nprint(b.length);        // 64\nfree(b);                // still manual\n```\n\n**2. Unsafe raw pointers:**\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);  // You must remember to free\n```\n\n**3. Type annotations:**\n```hemlock\nlet x: u8 = 255;   // OK\nlet y: u8 = 256;   // ERROR: out of range\n```\n\n**4. Runtime type checking:**\n```hemlock\nlet val = some_function();\nif (typeof(val) == \"i32\") {\n    // Safe to use as integer\n}\n```\n\n### Guiding Principles\n\n1. **Default to safe patterns in documentation** - Show `buffer` before `ptr`, encourage type annotations\n2. **Make unsafe operations obvious** - Raw pointer arithmetic should look intentional\n3. **Provide escape hatches** - Don't prevent experienced users from doing low-level work\n4. **Be honest about tradeoffs** - Document what can go wrong\n\n### Examples of Safety vs. Unsafety\n\n| Safe Pattern | Unsafe Pattern | When to Use Unsafe |\n|-------------|----------------|-------------------|\n| `buffer` type | `ptr` type | FFI, performance-critical code |\n| Type annotations | No annotations | External interfaces, validation |\n| Bounds-checked access | Pointer arithmetic | Low-level memory operations |\n| Exception handling | Returning null/error codes | When exceptions are too heavyweight |\n\n---\n\n## What NOT to Add\n\nUnderstanding what **not** to add is as important as knowing what to add.\n\n###  Don't Add Implicit Behavior\n\n**Bad examples:**\n\n```hemlock\n// BAD: Automatic semicolon insertion\nlet x = 5\nlet y = 10\n\n// BAD: Automatic memory management\nlet s = \"hello\"  // String auto-freed at end of scope? NO!\n\n// BAD: Implicit type conversions that lose precision\nlet x: i32 = 3.14  // Should truncate or error?\n```\n\n**Why:** Implicit behavior creates surprises and makes code harder to reason about.\n\n###  Don't Hide Complexity\n\n**Bad examples:**\n\n```hemlock\n// BAD: Magic behind-the-scenes optimization\nlet arr = [1, 2, 3]  // Is this stack or heap? User should know!\n\n// BAD: Automatic reference counting\nlet p = create_thing()  // Does this increment a refcount? NO!\n```\n\n**Why:** Hidden complexity makes it impossible to predict performance and debug issues.\n\n###  Don't Break Existing Semantics\n\n**Never change these core decisions:**\n- Semicolons are mandatory - don't make them optional\n- Manual memory management - don't add GC\n- Mutable strings - don't make them immutable\n- Runtime type checking - don't remove it\n\n**Why:** Consistency and stability are more important than trendy features.\n\n###  Don't Add \"Convenient\" Features That Reduce Explicitness\n\n**Examples of features to avoid:**\n- Operator overloading (maybe for user types, but carefully)\n- Implicit type coercion that loses information\n- Automatic resource cleanup (RAII)\n- Method chaining that hides complexity\n- DSLs and magic syntax\n\n**Exception:** Convenience features are OK if they're **explicit sugar** over simple operations:\n- `else if` is fine (it's just nested if statements)\n- String interpolation might be OK if it's clearly syntactic sugar\n- Method syntax for objects is fine (it's explicit what it does)\n\n---\n\n## Future Considerations\n\n### Maybe Add (Under Discussion)\n\nThese features align with Hemlock's philosophy but need careful design:\n\n**1. `defer` for cleanup**\n```hemlock\nlet f = open(\"file.txt\");\ndefer f.close();  // Explicit, not automatic\n// ... use file\n```\n- Explicit resource cleanup without RAII\n- User controls when/where cleanup happens\n- Still requires manual thought\n\n**2. Pattern matching**\n```hemlock\nmatch (value) {\n    case i32: print(\"integer\");\n    case string: print(\"text\");\n    case _: print(\"other\");\n}\n```\n- Explicit type checking\n- No hidden costs\n- Compile-time exhaustiveness checking possible\n\n**3. Error types (`Result<T, E>`)**\n```hemlock\nfn divide(a: i32, b: i32): Result<i32, string> {\n    if (b == 0) {\n        return Err(\"division by zero\");\n    }\n    return Ok(a / b);\n}\n```\n- Explicit error handling\n- Forces users to think about errors\n- Alternative to exceptions\n\n**4. Array/slice types**\n- Already have dynamic arrays\n- Could add fixed-size arrays for stack allocation\n- Would need to be explicit about stack vs. heap\n\n**5. Improved memory safety tools**\n- Optional bounds checking flag\n- Memory leak detection in debug builds\n- Sanitizer integration\n\n### Probably Never Add\n\nThese features violate core principles:\n\n**1. Garbage collection**\n- Hides memory management complexity\n- Unpredictable performance\n- Against explicit control principle\n\n**2. Automatic memory management**\n- Same reasons as GC\n- Reference counting might be OK if explicit\n\n**3. Implicit type conversions that lose data**\n- Goes against \"explicit over implicit\"\n- Source of subtle bugs\n\n**4. Macros (complex ones)**\n- Too much power, too much complexity\n- Simple macro system might be OK\n- Prefer code generation or functions\n\n**5. Class-based OOP with inheritance**\n- Too much implicit behavior\n- Duck typing and objects are sufficient\n- Composition over inheritance\n\n**6. Module system with complex resolution**\n- Keep imports simple and explicit\n- No magic search paths\n- No version resolution (use OS package manager)\n\n---\n\n## Final Thoughts\n\n### Trust and Responsibility\n\nHemlock is about **trust and responsibility**. We trust the programmer to:\n\n- Manage memory correctly\n- Use types appropriately\n- Handle errors properly\n- Understand the tradeoffs\n\nIn return, Hemlock provides:\n\n- No hidden costs\n- No surprise behavior\n- Full control when needed\n- Safety tools when wanted\n\n### The Guiding Question\n\n**When considering a new feature, ask:**\n\n> \"Does this give the programmer more explicit control, or does it hide something?\"\n\n- If it **adds explicit control**  probably fits Hemlock\n- If it **hides complexity**  probably doesn't belong\n- If it's **optional sugar** that's clearly documented  might be OK\n\n### Examples of Good Additions\n\n **Switch statements** - Explicit control flow, no magic, clear semantics\n\n **Async/await with pthreads** - Explicit concurrency, true parallelism, user controls spawning\n\n **Buffer type alongside ptr** - Gives choice between safe and unsafe\n\n **Optional type annotations** - Helps catch bugs without forcing strictness\n\n **Try/catch/finally** - Explicit error handling with clear control flow\n\n### Examples of Bad Additions\n\n **Automatic semicolon insertion** - Hides syntax errors, makes code ambiguous\n\n **RAII/destructors** - Automatic cleanup hides when resources are released\n\n **Implicit null coalescing** - Hides null checks, makes code harder to reason about\n\n **Auto-growing strings** - Hides memory allocation, unpredictable performance\n\n---\n\n## Conclusion\n\nHemlock is not trying to be the safest language, the fastest language, or the most feature-rich language.\n\n**Hemlock is trying to be the most *honest* language.**\n\nIt tells you exactly what it's doing, gives you control when you need it, and doesn't hide the sharp edges. It's a language for people who want to understand their code at a low level while still enjoying modern ergonomics.\n\nIf you're not sure whether a feature belongs in Hemlock, remember:\n\n> **Explicit over implicit, always.**\n> **Unsafe is a feature, not a bug.**\n> **The user is responsible, and that's OK.**\n"}, "Contributing  Guidelines": {"id": "contributing-guidelines", "content": "# Contributing to Hemlock\n\nThank you for your interest in contributing to Hemlock! This guide will help you understand how to contribute effectively while maintaining the language's design philosophy and code quality.\n\n---\n\n## Table of Contents\n\n- [Before You Start](#before-you-start)\n- [Contribution Workflow](#contribution-workflow)\n- [Code Style Guidelines](#code-style-guidelines)\n- [What to Contribute](#what-to-contribute)\n- [What NOT to Contribute](#what-not-to-contribute)\n- [Common Patterns](#common-patterns)\n- [Adding New Features](#adding-new-features)\n- [Code Review Process](#code-review-process)\n\n---\n\n## Before You Start\n\n### Required Reading\n\nBefore contributing, please read these documents in order:\n\n1. **`/home/user/hemlock/docs/design/philosophy.md`** - Understand Hemlock's core principles\n2. **`/home/user/hemlock/docs/design/implementation.md`** - Learn the codebase structure\n3. **`/home/user/hemlock/docs/contributing/testing.md`** - Understand testing requirements\n4. **This document** - Learn contribution guidelines\n\n### Prerequisites\n\n**Required knowledge:**\n- C programming (pointers, memory management, structs)\n- Compiler/interpreter basics (lexing, parsing, AST)\n- Git and GitHub workflow\n- Unix/Linux command line\n\n**Required tools:**\n- GCC or Clang compiler\n- Make build system\n- Git version control\n- Valgrind (for memory leak detection)\n- Basic text editor or IDE\n\n### Communication Channels\n\n**Where to ask questions:**\n- GitHub Issues - Bug reports and feature requests\n- GitHub Discussions - General questions and design discussions\n- Pull Request comments - Specific code feedback\n\n---\n\n## Contribution Workflow\n\n### 1. Find or Create an Issue\n\n**Before writing code:**\n- Check if an issue exists for your contribution\n- If not, create one describing what you want to do\n- Wait for maintainer feedback before starting large changes\n- Small bug fixes can skip this step\n\n**Good issue descriptions include:**\n- Problem statement (what's broken or missing)\n- Proposed solution (how you plan to fix it)\n- Examples (code snippets showing the issue)\n- Rationale (why this change aligns with Hemlock's philosophy)\n\n### 2. Fork and Clone\n\n```bash\n# Fork the repository on GitHub first, then:\ngit clone https://github.com/YOUR_USERNAME/hemlock.git\ncd hemlock\ngit checkout -b feature/your-feature-name\n```\n\n### 3. Make Your Changes\n\nFollow these guidelines:\n- Write tests first (TDD approach)\n- Implement the feature\n- Ensure all tests pass\n- Check for memory leaks\n- Update documentation\n\n### 4. Test Your Changes\n\n```bash\n# Run the full test suite\nmake test\n\n# Run specific test category\n./tests/run_tests.sh tests/category/\n\n# Check for memory leaks\nvalgrind ./hemlock tests/your_test.hml\n\n# Build and test\nmake clean && make && make test\n```\n\n### 5. Commit Your Changes\n\n**Good commit messages:**\n```\nAdd bitwise operators for integer types\n\n- Implement &, |, ^, <<, >>, ~ operators\n- Add type checking to ensure integer-only operations\n- Update operator precedence table\n- Add comprehensive tests for all operators\n\nCloses #42\n```\n\n**Commit message format:**\n- First line: Brief summary (50 chars max)\n- Blank line\n- Detailed explanation (wrap at 72 chars)\n- Reference issue numbers\n\n### 6. Submit a Pull Request\n\n**Before submitting:**\n- Rebase on latest main branch\n- Ensure all tests pass\n- Run valgrind to check for leaks\n- Update CLAUDE.md if adding user-facing features\n\n**Pull request description should include:**\n- What problem this solves\n- How it solves it\n- Breaking changes (if any)\n- Examples of new syntax or behavior\n- Test coverage summary\n\n---\n\n## Code Style Guidelines\n\n### C Code Style\n\n**Formatting:**\n```c\n// Indent with 4 spaces (no tabs)\n// K&R brace style for functions\nvoid function_name(int arg1, char *arg2)\n{\n    if (condition) {\n        // Brace on same line for control structures\n        do_something();\n    }\n}\n\n// Line length: 100 characters max\n// Use spaces around operators\nint result = (a + b) * c;\n\n// Pointer asterisk with type\nchar *string;   // Good\nchar* string;   // Avoid\nchar * string;  // Avoid\n```\n\n**Naming conventions:**\n```c\n// Functions: lowercase_with_underscores\nvoid eval_expression(ASTNode *node);\n\n// Types: PascalCase\ntypedef struct Value Value;\ntypedef enum ValueType ValueType;\n\n// Constants: UPPERCASE_WITH_UNDERSCORES\n#define MAX_BUFFER_SIZE 4096\n\n// Variables: lowercase_with_underscores\nint item_count;\nValue *current_value;\n\n// Enums: TYPE_PREFIX_NAME\ntypedef enum {\n    TYPE_I32,\n    TYPE_STRING,\n    TYPE_OBJECT\n} ValueType;\n```\n\n**Comments:**\n```c\n// Single-line comments for brief explanations\n// Use complete sentences with proper capitalization\n\n/*\n * Multi-line comments for longer explanations\n * Align asterisks for readability\n */\n\n/**\n * Function documentation comment\n * @param node - AST node to evaluate\n * @return Evaluated value\n */\nValue eval_expr(ASTNode *node);\n```\n\n**Error handling:**\n```c\n// Check all malloc calls\nchar *buffer = malloc(size);\nif (!buffer) {\n    fprintf(stderr, \"Error: Out of memory\\n\");\n    exit(1);\n}\n\n// Provide context in error messages\nif (file == NULL) {\n    fprintf(stderr, \"Error: Failed to open '%s': %s\\n\",\n            filename, strerror(errno));\n    exit(1);\n}\n\n// Use meaningful error messages\n// Bad: \"Error: Invalid value\"\n// Good: \"Error: Expected integer, got string\"\n```\n\n**Memory management:**\n```c\n// Always free what you allocate\nValue *val = value_create_i32(42);\n// ... use val\nvalue_free(val);\n\n// Set pointers to NULL after freeing (prevents double-free)\nfree(ptr);\nptr = NULL;\n\n// Document ownership in comments\n// This function takes ownership of 'value' and will free it\nvoid store_value(Value *value);\n\n// This function does NOT take ownership (caller must free)\nValue *get_value(void);\n```\n\n### Code Organization\n\n**File structure:**\n```c\n// 1. Includes (system headers first, then local)\n#include <stdio.h>\n#include <stdlib.h>\n#include \"internal.h\"\n#include \"values.h\"\n\n// 2. Constants and macros\n#define INITIAL_CAPACITY 16\n\n// 3. Type definitions\ntypedef struct Foo Foo;\n\n// 4. Static function declarations (internal helpers)\nstatic void helper_function(void);\n\n// 5. Public function implementations\nvoid public_api_function(void)\n{\n    // Implementation\n}\n\n// 6. Static function implementations\nstatic void helper_function(void)\n{\n    // Implementation\n}\n```\n\n**Header files:**\n```c\n// Use header guards\n#ifndef HEMLOCK_MODULE_H\n#define HEMLOCK_MODULE_H\n\n// Forward declarations\ntypedef struct Value Value;\n\n// Public API only in headers\nvoid public_function(Value *val);\n\n// Document parameters and return values\n/**\n * Evaluates an expression AST node\n * @param node - The AST node to evaluate\n * @param env - The current environment\n * @return The result value\n */\nValue *eval_expr(ASTNode *node, Environment *env);\n\n#endif // HEMLOCK_MODULE_H\n```\n\n---\n\n## What to Contribute\n\n###  Encouraged Contributions\n\n**Bug fixes:**\n- Memory leaks\n- Segmentation faults\n- Incorrect behavior\n- Error message improvements\n\n**Documentation:**\n- Code comments\n- API documentation\n- User guides and tutorials\n- Example programs\n- Test case documentation\n\n**Tests:**\n- Additional test cases for existing features\n- Edge case coverage\n- Regression tests for fixed bugs\n- Performance benchmarks\n\n**Small feature additions:**\n- New built-in functions (if they fit the philosophy)\n- String/array methods\n- Utility functions\n- Error handling improvements\n\n**Performance improvements:**\n- Faster algorithms (without changing semantics)\n- Memory usage reduction\n- Benchmark suite\n- Profiling tools\n\n**Tooling:**\n- Editor syntax highlighting\n- Language server protocol (LSP)\n- Debugger integration\n- Build system improvements\n\n###  Discuss First\n\n**Major features:**\n- New language constructs\n- Type system changes\n- Syntax additions\n- Concurrency primitives\n\n**How to discuss:**\n1. Open a GitHub issue or discussion\n2. Describe the feature and rationale\n3. Show example code\n4. Explain how it fits Hemlock's philosophy\n5. Wait for maintainer feedback\n6. Iterate on design before implementing\n\n---\n\n## What NOT to Contribute\n\n###  Discouraged Contributions\n\n**Don't add features that:**\n- Hide complexity from the user\n- Make behavior implicit or magical\n- Break existing semantics or syntax\n- Add garbage collection or automatic memory management\n- Violate the \"explicit over implicit\" principle\n\n**Examples of rejected contributions:**\n\n**1. Automatic semicolon insertion**\n```hemlock\n// BAD: This would be rejected\nlet x = 5  // No semicolon\nlet y = 10 // No semicolon\n```\nWhy: Makes syntax ambiguous, hides errors\n\n**2. RAII/destructors**\n```hemlock\n// BAD: This would be rejected\nlet f = open(\"file.txt\");\n// File automatically closed at end of scope\n```\nWhy: Hides when resources are released, not explicit\n\n**3. Implicit type coercion that loses data**\n```hemlock\n// BAD: This would be rejected\nlet x: i32 = 3.14;  // Silently truncates to 3\n```\nWhy: Data loss should be explicit, not silent\n\n**4. Garbage collection**\n```c\n// BAD: This would be rejected\nvoid *gc_malloc(size_t size) {\n    // Track allocation for automatic cleanup\n}\n```\nWhy: Hides memory management, unpredictable performance\n\n**5. Complex macro system**\n```hemlock\n// BAD: This would be rejected\nmacro repeat($n, $block) {\n    for (let i = 0; i < $n; i++) $block\n}\n```\nWhy: Too much magic, makes code hard to reason about\n\n### Common Rejection Reasons\n\n**\"This is too implicit\"**\n- Solution: Make the behavior explicit and document it\n\n**\"This hides complexity\"**\n- Solution: Expose the complexity but make it ergonomic\n\n**\"This breaks existing code\"**\n- Solution: Find a non-breaking alternative or discuss versioning\n\n**\"This doesn't fit Hemlock's philosophy\"**\n- Solution: Re-read philosophy.md and reconsider the approach\n\n---\n\n## Common Patterns\n\n### Error Handling Pattern\n\n```c\n// Use this pattern for recoverable errors in Hemlock code\nValue *divide(Value *a, Value *b)\n{\n    // Check preconditions\n    if (b->type != TYPE_I32) {\n        // Return error value or throw exception\n        return create_error(\"Expected integer divisor\");\n    }\n\n    if (b->i32_value == 0) {\n        return create_error(\"Division by zero\");\n    }\n\n    // Perform operation\n    return value_create_i32(a->i32_value / b->i32_value);\n}\n```\n\n### Memory Management Pattern\n\n```c\n// Pattern: Allocate, use, free\nvoid process_data(void)\n{\n    // Allocate\n    Buffer *buf = create_buffer(1024);\n    char *str = malloc(256);\n\n    // Use\n    if (buf && str) {\n        // ... do work\n    }\n\n    // Free (in reverse order of allocation)\n    free(str);\n    free_buffer(buf);\n}\n```\n\n### Value Creation Pattern\n\n```c\n// Create values using constructors\nValue *create_integer(int32_t n)\n{\n    Value *val = malloc(sizeof(Value));\n    if (!val) {\n        fprintf(stderr, \"Out of memory\\n\");\n        exit(1);\n    }\n\n    val->type = TYPE_I32;\n    val->i32_value = n;\n    return val;\n}\n```\n\n### Type Checking Pattern\n\n```c\n// Check types before operations\nValue *add_values(Value *a, Value *b)\n{\n    // Type checking\n    if (a->type != TYPE_I32 || b->type != TYPE_I32) {\n        return create_error(\"Type mismatch\");\n    }\n\n    // Safe to proceed\n    return value_create_i32(a->i32_value + b->i32_value);\n}\n```\n\n### String Building Pattern\n\n```c\n// Build strings efficiently\nvoid build_error_message(char *buffer, size_t size, const char *detail)\n{\n    snprintf(buffer, size, \"Error: %s (line %d)\", detail, line_number);\n}\n```\n\n---\n\n## Adding New Features\n\n### Feature Addition Checklist\n\nWhen adding a new feature, follow these steps:\n\n#### 1. Design Phase\n\n- [ ] Read philosophy.md to ensure alignment\n- [ ] Create GitHub issue describing the feature\n- [ ] Get maintainer approval for design\n- [ ] Write specification (syntax, semantics, examples)\n- [ ] Consider edge cases and error conditions\n\n#### 2. Implementation Phase\n\n**If adding a language construct:**\n\n- [ ] Add token type to `lexer.h` (if needed)\n- [ ] Add lexer rule in `lexer.c` (if needed)\n- [ ] Add AST node type in `ast.h`\n- [ ] Add AST constructor in `ast.c`\n- [ ] Add parser rule in `parser.c`\n- [ ] Add runtime behavior in `runtime.c` or appropriate module\n- [ ] Handle cleanup in AST free functions\n\n**If adding a built-in function:**\n\n- [ ] Add function implementation in `builtins.c`\n- [ ] Register function in `register_builtins()`\n- [ ] Handle all parameter type combinations\n- [ ] Return appropriate error values\n- [ ] Document parameters and return type\n\n**If adding a value type:**\n\n- [ ] Add type enum in `values.h`\n- [ ] Add field to Value union\n- [ ] Add constructor in `values.c`\n- [ ] Add to `value_free()` for cleanup\n- [ ] Add to `value_copy()` for copying\n- [ ] Add to `value_to_string()` for printing\n- [ ] Add type promotion rules if numeric\n\n#### 3. Testing Phase\n\n- [ ] Write test cases (see testing.md)\n- [ ] Test success cases\n- [ ] Test error cases\n- [ ] Test edge cases\n- [ ] Run full test suite (`make test`)\n- [ ] Check for memory leaks with valgrind\n- [ ] Test on multiple platforms (if possible)\n\n#### 4. Documentation Phase\n\n- [ ] Update CLAUDE.md with user-facing documentation\n- [ ] Add code comments explaining implementation\n- [ ] Create examples in `examples/`\n- [ ] Update relevant docs/ files\n- [ ] Document any breaking changes\n\n#### 5. Submission Phase\n\n- [ ] Clean up debug code and comments\n- [ ] Verify code style compliance\n- [ ] Rebase on latest main\n- [ ] Create pull request with detailed description\n- [ ] Respond to code review feedback\n\n### Example: Adding a New Operator\n\nLet's walk through adding the modulo operator `%` as an example:\n\n**1. Lexer (lexer.c):**\n```c\n// Add to switch statement in get_next_token()\ncase '%':\n    return create_token(TOKEN_PERCENT, \"%\", line);\n```\n\n**2. Lexer header (lexer.h):**\n```c\ntypedef enum {\n    // ... existing tokens\n    TOKEN_PERCENT,\n    // ...\n} TokenType;\n```\n\n**3. AST (ast.h):**\n```c\ntypedef enum {\n    // ... existing operators\n    OP_MOD,\n    // ...\n} BinaryOp;\n```\n\n**4. Parser (parser.c):**\n```c\n// Add to parse_multiplicative() or appropriate precedence level\nif (match(TOKEN_PERCENT)) {\n    BinaryOp op = OP_MOD;\n    ASTNode *right = parse_unary();\n    left = create_binary_op_node(op, left, right);\n}\n```\n\n**5. Runtime (runtime.c):**\n```c\n// Add to eval_binary_op()\ncase OP_MOD:\n    // Type checking\n    if (left->type == TYPE_I32 && right->type == TYPE_I32) {\n        if (right->i32_value == 0) {\n            fprintf(stderr, \"Error: Modulo by zero\\n\");\n            exit(1);\n        }\n        return value_create_i32(left->i32_value % right->i32_value);\n    }\n    // ... handle other type combinations\n    break;\n```\n\n**6. Tests (tests/operators/modulo.hml):**\n```hemlock\n// Basic modulo\nprint(10 % 3);  // Expect: 2\n\n// Negative modulo\nprint(-10 % 3); // Expect: -1\n\n// Error case (should fail)\n// print(10 % 0);  // Division by zero\n```\n\n**7. Documentation (CLAUDE.md):**\n```markdown\n### Arithmetic Operators\n- `+` - Addition\n- `-` - Subtraction\n- `*` - Multiplication\n- `/` - Division\n- `%` - Modulo (remainder)\n```\n\n---\n\n## Code Review Process\n\n### What Reviewers Look For\n\n**1. Correctness**\n- Does the code do what it claims?\n- Are edge cases handled?\n- Are there memory leaks?\n- Are errors handled properly?\n\n**2. Philosophy Alignment**\n- Does this fit Hemlock's design principles?\n- Is it explicit or implicit?\n- Does it hide complexity?\n\n**3. Code Quality**\n- Is the code readable and maintainable?\n- Are variable names descriptive?\n- Are functions reasonably sized?\n- Is there adequate documentation?\n\n**4. Testing**\n- Are there sufficient test cases?\n- Do tests cover success and failure paths?\n- Are edge cases tested?\n\n**5. Documentation**\n- Is user-facing documentation updated?\n- Are code comments clear?\n- Are examples provided?\n\n### Responding to Feedback\n\n**Do:**\n- Thank reviewers for their time\n- Ask clarifying questions if you don't understand\n- Explain your reasoning if you disagree\n- Make requested changes promptly\n- Update the PR description if scope changes\n\n**Don't:**\n- Take criticism personally\n- Argue defensively\n- Ignore feedback\n- Force-push over review comments (unless rebasing)\n- Add unrelated changes to the PR\n\n### Getting Your PR Merged\n\n**Requirements for merge:**\n- [ ] All tests pass\n- [ ] No memory leaks (valgrind clean)\n- [ ] Code review approval from maintainer\n- [ ] Documentation updated\n- [ ] Follows code style guidelines\n- [ ] Aligns with Hemlock's philosophy\n\n**Timeline:**\n- Small PRs (bug fixes): Usually reviewed within a few days\n- Medium PRs (new features): May take 1-2 weeks\n- Large PRs (major changes): Requires extensive discussion\n\n---\n\n## Additional Resources\n\n### Learning Resources\n\n**Understanding interpreters:**\n- \"Crafting Interpreters\" by Robert Nystrom\n- \"Writing An Interpreter In Go\" by Thorsten Ball\n- \"Modern Compiler Implementation in C\" by Andrew Appel\n\n**C programming:**\n- \"The C Programming Language\" by K&R\n- \"Expert C Programming\" by Peter van der Linden\n- \"C Interfaces and Implementations\" by David Hanson\n\n**Memory management:**\n- Valgrind documentation\n- \"Understanding and Using C Pointers\" by Richard Reese\n\n### Useful Commands\n\n```bash\n# Build with debug symbols\nmake clean && make CFLAGS=\"-g -O0\"\n\n# Run with valgrind\nvalgrind --leak-check=full ./hemlock script.hml\n\n# Run specific test category\n./tests/run_tests.sh tests/strings/\n\n# Generate tags file for code navigation\nctags -R .\n\n# Find all TODOs and FIXMEs\ngrep -rn \"TODO\\|FIXME\" src/ include/\n```\n\n---\n\n## Questions?\n\nIf you have questions about contributing:\n\n1. Check the documentation in `docs/`\n2. Search existing GitHub issues\n3. Ask in GitHub Discussions\n4. Open a new issue with your question\n\n**Thank you for contributing to Hemlock!**\n"}, "Contributing  Testing": {"id": "contributing-testing", "content": "# Testing Guide for Hemlock\n\nThis guide explains Hemlock's testing philosophy, how to write tests, and how to run the test suite.\n\n---\n\n## Table of Contents\n\n- [Testing Philosophy](#testing-philosophy)\n- [Test Suite Structure](#test-suite-structure)\n- [Running Tests](#running-tests)\n- [Writing Tests](#writing-tests)\n- [Test Categories](#test-categories)\n- [Memory Leak Testing](#memory-leak-testing)\n- [Continuous Integration](#continuous-integration)\n- [Best Practices](#best-practices)\n\n---\n\n## Testing Philosophy\n\n### Core Principles\n\n**1. Test-Driven Development (TDD)**\n\nWrite tests **before** implementing features:\n\n```\n1. Write a failing test\n2. Implement the feature\n3. Run the test (should pass)\n4. Refactor if needed\n5. Repeat\n```\n\n**Benefits:**\n- Ensures features actually work\n- Prevents regressions\n- Documents expected behavior\n- Makes refactoring safer\n\n**2. Comprehensive Coverage**\n\nTest both success and failure cases:\n\n```hemlock\n// Success case\nlet x: u8 = 255;  // Should work\n\n// Failure case\nlet y: u8 = 256;  // Should error\n```\n\n**3. Test Early and Often**\n\nRun tests:\n- Before committing code\n- After making changes\n- Before submitting pull requests\n- During code review\n\n**Rule:** All tests must pass before merging.\n\n### What to Test\n\n**Always test:**\n-  Basic functionality (happy path)\n-  Error conditions (sad path)\n-  Edge cases (boundary conditions)\n-  Type checking and conversions\n-  Memory management (no leaks)\n-  Concurrency and race conditions\n\n**Example test coverage:**\n```hemlock\n// Feature: String.substr(start, length)\n\n// Happy path\nprint(\"hello\".substr(0, 5));  // \"hello\"\n\n// Edge cases\nprint(\"hello\".substr(0, 0));  // \"\" (empty)\nprint(\"hello\".substr(5, 0));  // \"\" (at end)\nprint(\"hello\".substr(2, 100)); // \"llo\" (past end)\n\n// Error cases\n// \"hello\".substr(-1, 5);  // Error: negative index\n// \"hello\".substr(0, -1);  // Error: negative length\n```\n\n---\n\n## Test Suite Structure\n\n### Directory Organization\n\n```\ntests/\n run_tests.sh          # Main test runner script\n primitives/           # Type system tests\n    integers.hml\n    floats.hml\n    booleans.hml\n    i64.hml\n    u64.hml\n conversions/          # Type conversion tests\n    int_to_float.hml\n    promotion.hml\n    rune_conversions.hml\n memory/               # Pointer/buffer tests\n    alloc.hml\n    buffer.hml\n    memcpy.hml\n strings/              # String operation tests\n    concat.hml\n    methods.hml\n    utf8.hml\n    runes.hml\n control/              # Control flow tests\n    if.hml\n    switch.hml\n    while.hml\n functions/            # Function and closure tests\n    basics.hml\n    closures.hml\n    recursion.hml\n objects/              # Object tests\n    literals.hml\n    methods.hml\n    duck_typing.hml\n    serialization.hml\n arrays/               # Array operation tests\n    basics.hml\n    methods.hml\n    slicing.hml\n loops/                # Loop tests\n    for.hml\n    while.hml\n    break.hml\n    continue.hml\n exceptions/           # Error handling tests\n    try_catch.hml\n    finally.hml\n    throw.hml\n io/                   # File I/O tests\n    file_object.hml\n    read_write.hml\n    seek.hml\n async/                # Concurrency tests\n    spawn_join.hml\n    channels.hml\n    exceptions.hml\n ffi/                  # FFI tests\n    basic_call.hml\n    types.hml\n    dlopen.hml\n signals/              # Signal handling tests\n    basic.hml\n    handlers.hml\n    raise.hml\n args/                 # Command-line args tests\n     basic.hml\n```\n\n### Test File Naming\n\n**Conventions:**\n- Use descriptive names: `method_chaining.hml` not `test1.hml`\n- Group related tests: `string_substr.hml`, `string_slice.hml`\n- One feature area per file\n- Keep files focused and small\n\n---\n\n## Running Tests\n\n### Run All Tests\n\n```bash\n# From hemlock root directory\nmake test\n\n# Or directly\n./tests/run_tests.sh\n```\n\n**Output:**\n```\nRunning tests in tests/primitives/...\n   integers.hml\n   floats.hml\n   booleans.hml\n\nRunning tests in tests/strings/...\n   concat.hml\n   methods.hml\n\n...\n\nTotal: 251 tests\nPassed: 251\nFailed: 0\n```\n\n### Run Specific Category\n\n```bash\n# Run only string tests\n./tests/run_tests.sh tests/strings/\n\n# Run only one test file\n./tests/run_tests.sh tests/strings/concat.hml\n\n# Run multiple categories\n./tests/run_tests.sh tests/strings/ tests/arrays/\n```\n\n### Run with Valgrind (Memory Leak Check)\n\n```bash\n# Check single test for leaks\nvalgrind --leak-check=full ./hemlock tests/memory/alloc.hml\n\n# Check all tests (slow!)\nfor test in tests/**/*.hml; do\n    echo \"Testing $test\"\n    valgrind --leak-check=full --error-exitcode=1 ./hemlock \"$test\"\ndone\n```\n\n### Debug Failed Tests\n\n```bash\n# Run with verbose output\n./hemlock tests/failing_test.hml\n\n# Run with gdb\ngdb --args ./hemlock tests/failing_test.hml\n(gdb) run\n(gdb) backtrace  # if it crashes\n```\n\n---\n\n## Writing Tests\n\n### Test File Format\n\nTest files are just Hemlock programs with expected output:\n\n**Example: tests/primitives/integers.hml**\n```hemlock\n// Test basic integer literals\nlet x = 42;\nprint(x);  // Expect: 42\n\nlet y: i32 = 100;\nprint(y);  // Expect: 100\n\n// Test arithmetic\nlet sum = x + y;\nprint(sum);  // Expect: 142\n\n// Test type inference\nlet small = 10;\nprint(typeof(small));  // Expect: i32\n\nlet large = 5000000000;\nprint(typeof(large));  // Expect: i64\n```\n\n**How tests work:**\n1. Test runner executes the .hml file\n2. Captures stdout output\n3. Compares with expected output (from comments or separate .out file)\n4. Reports pass/fail\n\n### Expected Output Methods\n\n**Method 1: Inline comments (recommended for simple tests)**\n\n```hemlock\nprint(\"hello\");  // Expect: hello\nprint(42);       // Expect: 42\n```\n\nThe test runner parses `// Expect: ...` comments.\n\n**Method 2: Separate .out file**\n\nCreate `test_name.hml.out` with expected output:\n\n**test_name.hml:**\n```hemlock\nprint(\"line 1\");\nprint(\"line 2\");\nprint(\"line 3\");\n```\n\n**test_name.hml.out:**\n```\nline 1\nline 2\nline 3\n```\n\n### Testing Error Cases\n\nError tests should cause the program to exit with non-zero status:\n\n**Example: tests/primitives/range_error.hml**\n```hemlock\n// This should fail with a type error\nlet x: u8 = 256;  // Out of range for u8\n```\n\n**Expected behavior:**\n- Program exits with non-zero status\n- Prints error message to stderr\n\n**Test runner handling:**\n- Tests expecting errors should be in separate files\n- Use naming convention: `*_error.hml` or `*_fail.hml`\n- Document expected error in comments\n\n### Testing Success Cases\n\n**Example: tests/strings/methods.hml**\n```hemlock\n// Test substr\nlet s = \"hello world\";\nlet sub = s.substr(6, 5);\nprint(sub);  // Expect: world\n\n// Test find\nlet pos = s.find(\"world\");\nprint(pos);  // Expect: 6\n\n// Test contains\nlet has = s.contains(\"lo\");\nprint(has);  // Expect: true\n\n// Test trim\nlet padded = \"  hello  \";\nlet trimmed = padded.trim();\nprint(trimmed);  // Expect: hello\n```\n\n### Testing Edge Cases\n\n**Example: tests/arrays/edge_cases.hml**\n```hemlock\n// Empty array\nlet empty = [];\nprint(empty.length);  // Expect: 0\n\n// Single element\nlet single = [42];\nprint(single[0]);  // Expect: 42\n\n// Negative index (should error in separate test file)\n// print(single[-1]);  // Error\n\n// Past-end index (should error)\n// print(single[100]);  // Error\n\n// Boundary conditions\nlet arr = [1, 2, 3];\nprint(arr.slice(0, 0));  // Expect: [] (empty)\nprint(arr.slice(3, 3));  // Expect: [] (empty)\nprint(arr.slice(1, 2));  // Expect: [2]\n```\n\n### Testing Type System\n\n**Example: tests/conversions/promotion.hml**\n```hemlock\n// Test type promotion in binary operations\n\n// i32 + i64 -> i64\nlet a: i32 = 10;\nlet b: i64 = 20;\nlet c = a + b;\nprint(typeof(c));  // Expect: i64\n\n// i32 + f32 -> f32\nlet d: i32 = 10;\nlet e: f32 = 3.14;\nlet f = d + e;\nprint(typeof(f));  // Expect: f32\n\n// u8 + i32 -> i32\nlet g: u8 = 5;\nlet h: i32 = 10;\nlet i = g + h;\nprint(typeof(i));  // Expect: i32\n```\n\n### Testing Concurrency\n\n**Example: tests/async/basic.hml**\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Spawn tasks\nlet t1 = spawn(compute, 10);\nlet t2 = spawn(compute, 20);\n\n// Join and print results\nlet r1 = join(t1);\nlet r2 = join(t2);\nprint(r1);  // Expect: 45\nprint(r2);  // Expect: 190\n```\n\n### Testing Exceptions\n\n**Example: tests/exceptions/try_catch.hml**\n```hemlock\n// Test basic try/catch\ntry {\n    throw \"error message\";\n} catch (e) {\n    print(\"Caught: \" + e);  // Expect: Caught: error message\n}\n\n// Test finally\nlet executed = false;\ntry {\n    print(\"try\");  // Expect: try\n} finally {\n    executed = true;\n    print(\"finally\");  // Expect: finally\n}\n\n// Test exception propagation\nfn risky(): i32 {\n    throw \"failure\";\n}\n\ntry {\n    risky();\n} catch (e) {\n    print(e);  // Expect: failure\n}\n```\n\n---\n\n## Test Categories\n\n### Primitives Tests\n\n**What to test:**\n- Integer types (i8, i16, i32, i64, u8, u16, u32, u64)\n- Float types (f32, f64)\n- Boolean type\n- String type\n- Rune type\n- Null type\n\n**Example areas:**\n- Literal syntax\n- Type inference\n- Range checking\n- Overflow behavior\n- Type annotations\n\n### Conversion Tests\n\n**What to test:**\n- Implicit type promotion\n- Explicit type conversion\n- Lossy conversions (should error)\n- Type promotion in operations\n- Cross-type comparisons\n\n### Memory Tests\n\n**What to test:**\n- alloc/free correctness\n- Buffer creation and access\n- Bounds checking on buffers\n- memset, memcpy, realloc\n- Memory leak detection (valgrind)\n\n### String Tests\n\n**What to test:**\n- Concatenation\n- All 18 string methods\n- UTF-8 handling\n- Rune indexing\n- String + rune concatenation\n- Edge cases (empty strings, single char, etc.)\n\n### Control Flow Tests\n\n**What to test:**\n- if/else/else if\n- while loops\n- for loops\n- switch statements\n- break/continue\n- return statements\n\n### Function Tests\n\n**What to test:**\n- Function definition and calling\n- Parameter passing\n- Return values\n- Recursion\n- Closures and capture\n- First-class functions\n- Anonymous functions\n\n### Object Tests\n\n**What to test:**\n- Object literals\n- Field access and assignment\n- Methods and self binding\n- Duck typing\n- Optional fields\n- JSON serialization/deserialization\n- Circular reference detection\n\n### Array Tests\n\n**What to test:**\n- Array creation\n- Indexing and assignment\n- All 15 array methods\n- Mixed types\n- Dynamic resizing\n- Edge cases (empty, single element)\n\n### Exception Tests\n\n**What to test:**\n- try/catch/finally\n- throw statement\n- Exception propagation\n- Nested try/catch\n- Return in try/catch/finally\n- Uncaught exceptions\n\n### I/O Tests\n\n**What to test:**\n- File opening modes\n- Read/write operations\n- Seek/tell\n- File properties\n- Error handling (missing files, etc.)\n- Resource cleanup\n\n### Async Tests\n\n**What to test:**\n- spawn/join/detach\n- Channel send/recv\n- Exception propagation in tasks\n- Multiple concurrent tasks\n- Channel blocking behavior\n\n### FFI Tests\n\n**What to test:**\n- dlopen/dlclose\n- dlsym\n- dlcall with various types\n- Type conversion\n- Error handling\n\n---\n\n## Memory Leak Testing\n\n### Using Valgrind\n\n**Basic usage:**\n```bash\nvalgrind --leak-check=full ./hemlock test.hml\n```\n\n**Example output (no leaks):**\n```\n==12345== HEAP SUMMARY:\n==12345==     in use at exit: 0 bytes in 0 blocks\n==12345==   total heap usage: 10 allocs, 10 frees, 1,024 bytes allocated\n==12345==\n==12345== All heap blocks were freed -- no leaks are possible\n```\n\n**Example output (with leak):**\n```\n==12345== LEAK SUMMARY:\n==12345==    definitely lost: 64 bytes in 1 blocks\n==12345==    indirectly lost: 0 bytes in 0 blocks\n==12345==      possibly lost: 0 bytes in 0 blocks\n==12345==    still reachable: 0 bytes in 0 blocks\n==12345==         suppressed: 0 bytes in 0 blocks\n```\n\n### Common Leak Sources\n\n**1. Missing free() calls:**\n```c\n// BAD\nchar *str = malloc(100);\n// ... use str\n// Forgot to free!\n\n// GOOD\nchar *str = malloc(100);\n// ... use str\nfree(str);\n```\n\n**2. Lost pointers:**\n```c\n// BAD\nchar *ptr = malloc(100);\nptr = malloc(200);  // Lost reference to first allocation!\n\n// GOOD\nchar *ptr = malloc(100);\nfree(ptr);\nptr = malloc(200);\n```\n\n**3. Exception paths:**\n```c\n// BAD\nvoid func() {\n    char *data = malloc(100);\n    if (error_condition) {\n        return;  // Leak!\n    }\n    free(data);\n}\n\n// GOOD\nvoid func() {\n    char *data = malloc(100);\n    if (error_condition) {\n        free(data);\n        return;\n    }\n    free(data);\n}\n```\n\n### Known Acceptable Leaks\n\nSome \"leaks\" are intentional in Hemlock v0.1:\n\n**1. Closure environments (to be fixed in v0.2):**\n```hemlock\nfn makeAdder(x) {\n    return fn(y) { return x + y; };  // Environment leaks\n}\n```\n\n**2. Detached task structures:**\n```hemlock\nasync fn background_work() { /* ... */ }\ndetach(spawn(background_work));  // Task struct leaks\n```\n\n**3. Global built-ins:**\n```hemlock\n// Built-in functions and constants are never freed\n```\n\nDocument these in tests with comments:\n```hemlock\n// NOTE: This test has a known leak in closure environment (v0.1)\nfn makeAdder(x) {\n    return fn(y) { return x + y; };\n}\n```\n\n---\n\n## Continuous Integration\n\n### GitHub Actions (Future)\n\nOnce CI is set up, all tests will run automatically on:\n- Push to main branch\n- Pull request creation/update\n- Scheduled daily runs\n\n**CI workflow:**\n1. Build Hemlock\n2. Run test suite\n3. Check for memory leaks (valgrind)\n4. Report results on PR\n\n### Pre-Commit Checks\n\nBefore committing, run:\n\n```bash\n# Build fresh\nmake clean && make\n\n# Run all tests\nmake test\n\n# Check a few tests for leaks\nvalgrind --leak-check=full ./hemlock tests/memory/alloc.hml\nvalgrind --leak-check=full ./hemlock tests/strings/concat.hml\n```\n\n---\n\n## Best Practices\n\n### Do's\n\n **Write tests first (TDD)**\n```bash\n1. Create tests/feature/new_feature.hml\n2. Implement feature in src/\n3. Run tests until they pass\n```\n\n **Test both success and failure**\n```hemlock\n// Success: tests/feature/success.hml\nlet result = do_thing();\nprint(result);  // Expect: expected value\n\n// Failure: tests/feature/failure.hml\ndo_invalid_thing();  // Should error\n```\n\n **Use descriptive test names**\n```\nGood: tests/strings/substr_utf8_boundary.hml\nBad:  tests/test1.hml\n```\n\n **Keep tests focused**\n- One feature area per file\n- Clear setup and assertions\n- Minimal code\n\n **Add comments explaining tricky tests**\n```hemlock\n// Test that closure captures outer variable by reference\nfn outer() {\n    let x = 10;\n    let f = fn() { return x; };\n    x = 20;  // Modify after closure creation\n    return f();  // Should return 20, not 10\n}\n```\n\n **Test edge cases**\n- Empty inputs\n- Null values\n- Boundary values (min/max)\n- Large inputs\n- Negative values\n\n### Don'ts\n\n **Don't skip tests**\n- All tests must pass before merging\n- Don't comment out failing tests\n- Fix the bug or remove the feature\n\n **Don't write tests that depend on each other**\n```hemlock\n// BAD: test2.hml depends on test1.hml output\n// Tests should be independent\n```\n\n **Don't use random values in tests**\n```hemlock\n// BAD: Non-deterministic\nlet x = random();\nprint(x);  // Can't predict output\n\n// GOOD: Deterministic\nlet x = 42;\nprint(x);  // Expect: 42\n```\n\n **Don't test implementation details**\n```hemlock\n// BAD: Testing internal structure\nlet obj = { x: 10 };\n// Don't check internal field order, capacity, etc.\n\n// GOOD: Testing behavior\nprint(obj.x);  // Expect: 10\n```\n\n **Don't ignore memory leaks**\n- All tests should be valgrind-clean\n- Document known/acceptable leaks\n- Fix leaks before merging\n\n### Test Maintenance\n\n**When to update tests:**\n- Feature behavior changes\n- Bug fixes require new test cases\n- Edge cases discovered\n- Performance improvements\n\n**When to remove tests:**\n- Feature removed from language\n- Test duplicates existing coverage\n- Test was incorrect\n\n**Refactoring tests:**\n- Group related tests together\n- Extract common setup code\n- Use consistent naming\n- Keep tests simple and readable\n\n---\n\n## Example Test Session\n\nHere's a complete example of adding a feature with tests:\n\n### Feature: Add `array.first()` method\n\n**1. Write the test first:**\n\n```bash\n# Create test file\ncat > tests/arrays/first_method.hml << 'EOF'\n// Test array.first() method\n\n// Basic case\nlet arr = [1, 2, 3];\nprint(arr.first());  // Expect: 1\n\n// Single element\nlet single = [42];\nprint(single.first());  // Expect: 42\n\n// Empty array (should error - separate test file)\n// let empty = [];\n// print(empty.first());  // Error\nEOF\n```\n\n**2. Run the test (should fail):**\n\n```bash\n./hemlock tests/arrays/first_method.hml\n# Error: Method 'first' not found on array\n```\n\n**3. Implement the feature:**\n\nEdit `src/interpreter/builtins.c`:\n\n```c\n// Add array_first method\nValue *array_first(Value *self, Value **args, int arg_count)\n{\n    if (self->array_value->length == 0) {\n        fprintf(stderr, \"Error: Cannot get first element of empty array\\n\");\n        exit(1);\n    }\n\n    return value_copy(&self->array_value->elements[0]);\n}\n\n// Register in array method table\n// ... add to array method registration\n```\n\n**4. Run the test (should pass):**\n\n```bash\n./hemlock tests/arrays/first_method.hml\n1\n42\n# Success!\n```\n\n**5. Check for memory leaks:**\n\n```bash\nvalgrind --leak-check=full ./hemlock tests/arrays/first_method.hml\n# All heap blocks were freed -- no leaks are possible\n```\n\n**6. Run full test suite:**\n\n```bash\nmake test\n# Total: 252 tests (251 + new one)\n# Passed: 252\n# Failed: 0\n```\n\n**7. Commit:**\n\n```bash\ngit add tests/arrays/first_method.hml src/interpreter/builtins.c\ngit commit -m \"Add array.first() method with tests\"\n```\n\n---\n\n## Summary\n\n**Remember:**\n- Write tests first (TDD)\n- Test success and failure cases\n- Run all tests before committing\n- Check for memory leaks\n- Document known issues\n- Keep tests simple and focused\n\n**Test quality is just as important as code quality!**\n"}};

        // Mobile menu toggle
        const menuToggle = document.getElementById('menuToggle');
        const sidebar = document.getElementById('sidebar');

        menuToggle.addEventListener('click', () => {
            sidebar.classList.toggle('open');
            menuToggle.textContent = sidebar.classList.contains('open') ? '' : '';
        });

        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', (e) => {
            if (window.innerWidth < 1024) {
                if (!sidebar.contains(e.target) && !menuToggle.contains(e.target)) {
                    sidebar.classList.remove('open');
                    menuToggle.textContent = '';
                }
            }
        });

        // Markdown parser
        function parseMarkdown(md) {
            let lines = md.split('\n');
            let html = '';
            let inCodeBlock = false;
            let codeBlockContent = '';
            let codeBlockLang = '';
            let inList = false;
            let listContent = '';
            let inBlockquote = false;
            let blockquoteContent = '';

            function processInlineMarkdown(text) {
                text = text.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
                text = text.replace(/\*([^*]+)\*/g, '<em>$1</em>');
                text = text.replace(/`([^`]+)`/g, '<code>$1</code>');
                text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');
                return text;
            }

            function makeId(text) {
                return text.toLowerCase()
                    .replace(/[^\w\s-]/g, '')
                    .replace(/\s+/g, '-')
                    .replace(/^-+|-+$/g, '');
            }

            function flushList() {
                if (inList && listContent) {
                    html += '<ul>\n' + listContent + '</ul>\n';
                    listContent = '';
                    inList = false;
                }
            }

            function flushBlockquote() {
                if (inBlockquote && blockquoteContent) {
                    html += '<blockquote>' + processInlineMarkdown(blockquoteContent.trim()) + '</blockquote>\n';
                    blockquoteContent = '';
                    inBlockquote = false;
                }
            }

            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];

                if (line.startsWith('```')) {
                    if (inCodeBlock) {
                        html += '<pre><code>' + escapeHtml(codeBlockContent) + '</code></pre>\n';
                        codeBlockContent = '';
                        inCodeBlock = false;
                    } else {
                        flushList();
                        flushBlockquote();
                        inCodeBlock = true;
                        codeBlockLang = line.substring(3).trim();
                    }
                    continue;
                }

                if (inCodeBlock) {
                    codeBlockContent += line + '\n';
                    continue;
                }

                if (line.startsWith('# ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(2).trim();
                    const id = makeId(text);
                    html += `<h1 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h1>\n`;
                    continue;
                }
                if (line.startsWith('## ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(3).trim();
                    const id = makeId(text);
                    html += `<h2 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h2>\n`;
                    continue;
                }
                if (line.startsWith('### ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(4).trim();
                    const id = makeId(text);
                    html += `<h3 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h3>\n`;
                    continue;
                }
                if (line.startsWith('#### ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(5).trim();
                    const id = makeId(text);
                    html += `<h4 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h4>\n`;
                    continue;
                }

                if (line.trim() === '---') {
                    flushList();
                    flushBlockquote();
                    html += '<hr>\n';
                    continue;
                }

                if (line.startsWith('> ')) {
                    flushList();
                    blockquoteContent += line.substring(2) + ' ';
                    inBlockquote = true;
                    continue;
                } else if (inBlockquote && line.trim() === '') {
                    flushBlockquote();
                    continue;
                }

                if (line.startsWith('- ') || line.startsWith('* ')) {
                    flushBlockquote();
                    const text = line.substring(2).trim();
                    listContent += '<li>' + processInlineMarkdown(text) + '</li>\n';
                    inList = true;
                    continue;
                } else if (inList && line.trim() !== '' && !line.startsWith('#')) {
                    listContent = listContent.trimEnd();
                    if (listContent.endsWith('</li>')) {
                        listContent = listContent.substring(0, listContent.length - 5);
                        listContent += ' ' + processInlineMarkdown(line.trim()) + '</li>\n';
                    }
                    continue;
                } else if (inList && line.trim() === '') {
                    flushList();
                    continue;
                }

                if (line.trim() === '') {
                    flushList();
                    flushBlockquote();
                    continue;
                }

                flushList();
                flushBlockquote();
                if (line.trim() !== '') {
                    html += '<p>' + processInlineMarkdown(line) + '</p>\n';
                }
            }

            flushList();
            flushBlockquote();

            return html;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Load a page
        function loadPage(pageId) {
            const pageData = Object.values(PAGES).find(p => p.id === pageId);
            if (!pageData) {
                console.error('Page not found:', pageId);
                return;
            }

            const content = parseMarkdown(pageData.content);
            document.getElementById('content').innerHTML = content;

            // Update active nav link
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
                if (link.dataset.page === pageId) {
                    link.classList.add('active');
                }
            });

            // Scroll to top
            window.scrollTo(0, 0);

            // Update URL hash
            window.location.hash = pageId;
        }

        // Setup navigation
        document.querySelectorAll('.nav-link').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const pageId = link.dataset.page;
                loadPage(pageId);

                // Close mobile menu
                if (window.innerWidth < 1024) {
                    sidebar.classList.remove('open');
                    menuToggle.textContent = '';
                }
            });
        });

        // Handle browser back/forward
        window.addEventListener('hashchange', () => {
            const hash = window.location.hash.substring(1);
            if (hash) {
                loadPage(hash);
            }
        });

        // Load initial page
        const initialHash = window.location.hash.substring(1);
        const firstPageId = Object.values(PAGES)[0].id;
        loadPage(initialHash || firstPageId);
    </script>
</body>
</html>